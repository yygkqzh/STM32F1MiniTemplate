; generated by Component: ARM Compiler 5.06 update 7 (build 960) Tool: ArmCC [4d365d]
; commandline ArmCC [--c99 --split_sections --debug -c --asm --interleave -otemplate\diskio.o --asm_dir=./ --list_dir=--list --depend=template\diskio.d --cpu=Cortex-M3 --apcs=interwork -O0 --diag_suppress=9931 -I../Inc -I../Drivers/STM32F1xx_HAL_Driver/Inc -I../Drivers/STM32F1xx_HAL_Driver/Inc/Legacy -I../Middlewares/Third_Party/FatFs/src -I../Drivers/CMSIS/Device/ST/STM32F1xx/Include -I../Drivers/CMSIS/Include -I.\RTE\_Template -ID:\Keil_v5\Pack\ARM\CMSIS\5.7.0\CMSIS\Core\Include -ID:\Keil_v5\Pack\Keil\STM32F1xx_DFP\2.3.0\Device\Include -D__MICROLIB -D__UVISION_VERSION=533 -D_RTE_ -DSTM32F10X_MD -D_RTE_ -DUSE_FULL_LL_DRIVER -DUSE_HAL_DRIVER -DSTM32F103xB --signed_chars --omf_browse=template\diskio.crf ../Middlewares/Third_Party/FatFs/src/diskio.c]
                          THUMB

                          AREA ||i.disk_initialize||, CODE, READONLY, ALIGN=2

                  disk_initialize PROC
;;;89       */
;;;90     DSTATUS disk_initialize (
000000  b570              PUSH     {r4-r6,lr}
;;;91     	BYTE pdrv				/* Physical drive nmuber to identify the drive */
;;;92     )
;;;93     {
000002  4604              MOV      r4,r0
;;;94       DSTATUS stat = RES_OK;
000004  2500              MOVS     r5,#0
;;;95       
;;;96       if(disk.is_initialized[pdrv] == 0)
000006  4808              LDR      r0,|L1.40|
000008  5d00              LDRB     r0,[r0,r4]
00000a  b958              CBNZ     r0,|L1.36|
;;;97       { 
;;;98         disk.is_initialized[pdrv] = 1;
00000c  2001              MOVS     r0,#1
00000e  4906              LDR      r1,|L1.40|
000010  5508              STRB     r0,[r1,r4]
;;;99         stat = disk.drv[pdrv]->disk_initialize(disk.lun[pdrv]);
000012  f1010208          ADD      r2,r1,#8
000016  5d10              LDRB     r0,[r2,r4]
000018  1d0a              ADDS     r2,r1,#4
00001a  f8522024          LDR      r2,[r2,r4,LSL #2]
00001e  6811              LDR      r1,[r2,#0]
000020  4788              BLX      r1
000022  4605              MOV      r5,r0
                  |L1.36|
;;;100      }
;;;101      return stat;
000024  4628              MOV      r0,r5
;;;102    }
000026  bd70              POP      {r4-r6,pc}
;;;103    
                          ENDP

                  |L1.40|
                          DCD      disk

                          AREA ||i.disk_ioctl||, CODE, READONLY, ALIGN=2

                  disk_ioctl PROC
;;;155    #if _USE_IOCTL == 1
;;;156    DRESULT disk_ioctl (
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;157    	BYTE pdrv,		/* Physical drive nmuber (0..) */
;;;158    	BYTE cmd,		/* Control code */
;;;159    	void *buff		/* Buffer to send/receive control data */
;;;160    )
;;;161    {
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
000008  4616              MOV      r6,r2
;;;162      DRESULT res;
;;;163    
;;;164      res = disk.drv[pdrv]->disk_ioctl(disk.lun[pdrv], cmd, buff);
00000a  4906              LDR      r1,|L2.36|
00000c  5d08              LDRB     r0,[r1,r4]
00000e  1f09              SUBS     r1,r1,#4
000010  f8511024          LDR      r1,[r1,r4,LSL #2]
000014  4632              MOV      r2,r6
000016  690b              LDR      r3,[r1,#0x10]
000018  4629              MOV      r1,r5
00001a  4798              BLX      r3
00001c  4607              MOV      r7,r0
;;;165      return res;
00001e  4638              MOV      r0,r7
;;;166    }
000020  e8bd81f0          POP      {r4-r8,pc}
;;;167    #endif /* _USE_IOCTL == 1 */
                          ENDP

                  |L2.36|
                          DCD      disk+0x8

                          AREA ||i.disk_read||, CODE, READONLY, ALIGN=2

                  disk_read PROC
;;;111      */
;;;112    DRESULT disk_read (
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;113    	BYTE pdrv,		/* Physical drive nmuber to identify the drive */
;;;114    	BYTE *buff,		/* Data buffer to store read data */
;;;115    	DWORD sector,	        /* Sector address in LBA */
;;;116    	UINT count		/* Number of sectors to read */
;;;117    )
;;;118    {
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
000008  4616              MOV      r6,r2
00000a  461f              MOV      r7,r3
;;;119      DRESULT res;
;;;120     
;;;121      res = disk.drv[pdrv]->disk_read(disk.lun[pdrv], buff, sector, count);
00000c  4907              LDR      r1,|L3.44|
00000e  5d08              LDRB     r0,[r1,r4]
000010  1f09              SUBS     r1,r1,#4
000012  f8511024          LDR      r1,[r1,r4,LSL #2]
000016  463b              MOV      r3,r7
000018  4632              MOV      r2,r6
00001a  f8d1c008          LDR      r12,[r1,#8]
00001e  4629              MOV      r1,r5
000020  47e0              BLX      r12
000022  4680              MOV      r8,r0
;;;122      return res;
000024  4640              MOV      r0,r8
;;;123    }
000026  e8bd81f0          POP      {r4-r8,pc}
;;;124    
                          ENDP

00002a  0000              DCW      0x0000
                  |L3.44|
                          DCD      disk+0x8

                          AREA ||i.disk_status||, CODE, READONLY, ALIGN=2

                  disk_status PROC
;;;74       */
;;;75     DSTATUS disk_status (
000000  b570              PUSH     {r4-r6,lr}
;;;76     	BYTE pdrv		/* Physical drive nmuber to identify the drive */
;;;77     )
;;;78     {
000002  4604              MOV      r4,r0
;;;79       DSTATUS stat;
;;;80       
;;;81       stat = disk.drv[pdrv]->disk_status(disk.lun[pdrv]);
000004  4a04              LDR      r2,|L4.24|
000006  5d10              LDRB     r0,[r2,r4]
000008  1f12              SUBS     r2,r2,#4
00000a  f8522024          LDR      r2,[r2,r4,LSL #2]
00000e  6851              LDR      r1,[r2,#4]
000010  4788              BLX      r1
000012  4605              MOV      r5,r0
;;;82       return stat;
000014  4628              MOV      r0,r5
;;;83     }
000016  bd70              POP      {r4-r6,pc}
;;;84     
                          ENDP

                  |L4.24|
                          DCD      disk+0x8

                          AREA ||i.disk_write||, CODE, READONLY, ALIGN=2

                  disk_write PROC
;;;133    #if _USE_WRITE == 1
;;;134    DRESULT disk_write (
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;135    	BYTE pdrv,		/* Physical drive nmuber to identify the drive */
;;;136    	const BYTE *buff,	/* Data to be written */
;;;137    	DWORD sector,		/* Sector address in LBA */
;;;138    	UINT count        	/* Number of sectors to write */
;;;139    )
;;;140    {
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
000008  4616              MOV      r6,r2
00000a  461f              MOV      r7,r3
;;;141      DRESULT res;
;;;142      
;;;143      res = disk.drv[pdrv]->disk_write(disk.lun[pdrv], buff, sector, count);
00000c  4907              LDR      r1,|L5.44|
00000e  5d08              LDRB     r0,[r1,r4]
000010  1f09              SUBS     r1,r1,#4
000012  f8511024          LDR      r1,[r1,r4,LSL #2]
000016  463b              MOV      r3,r7
000018  4632              MOV      r2,r6
00001a  f8d1c00c          LDR      r12,[r1,#0xc]
00001e  4629              MOV      r1,r5
000020  47e0              BLX      r12
000022  4680              MOV      r8,r0
;;;144      return res;
000024  4640              MOV      r0,r8
;;;145    }
000026  e8bd81f0          POP      {r4-r8,pc}
;;;146    #endif /* _USE_WRITE == 1 */
                          ENDP

00002a  0000              DCW      0x0000
                  |L5.44|
                          DCD      disk+0x8

                          AREA ||i.get_fattime||, CODE, READONLY, ALIGN=1

                  get_fattime PROC
;;;173      */
;;;174    __weak DWORD get_fattime (void)
000000  2000              MOVS     r0,#0
;;;175    {
;;;176      return 0;
;;;177    }
000002  4770              BX       lr
;;;178    
                          ENDP


                          AREA ||.constdata||, DATA, READONLY, ALIGN=0

                  CHANNEL_OFFSET_TAB
000000  081c3044          DCB      0x08,0x1c,0x30,0x44
000004  586c80            DCB      0x58,0x6c,0x80

;*** Start embedded assembler ***

#line 1 "../Middlewares/Third_Party/FatFs/src/diskio.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___8_diskio_c_fd8865f0____REV16|
#line 463 "../Drivers/CMSIS/Include/cmsis_armcc.h"
|__asm___8_diskio_c_fd8865f0____REV16| PROC
#line 464

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___8_diskio_c_fd8865f0____REVSH|
#line 478
|__asm___8_diskio_c_fd8865f0____REVSH| PROC
#line 479

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___8_diskio_c_fd8865f0____RRX|
#line 665
|__asm___8_diskio_c_fd8865f0____RRX| PROC
#line 666

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
