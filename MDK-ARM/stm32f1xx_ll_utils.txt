; generated by Component: ARM Compiler 5.06 update 7 (build 960) Tool: ArmCC [4d365d]
; commandline ArmCC [--c99 --split_sections --debug -c --asm --interleave -otemplate\stm32f1xx_ll_utils.o --asm_dir=./ --list_dir=--list --depend=template\stm32f1xx_ll_utils.d --cpu=Cortex-M3 --apcs=interwork -O0 --diag_suppress=9931 -I../Inc -I../Drivers/STM32F1xx_HAL_Driver/Inc -I../Drivers/STM32F1xx_HAL_Driver/Inc/Legacy -I../Middlewares/Third_Party/FatFs/src -I../Drivers/CMSIS/Device/ST/STM32F1xx/Include -I../Drivers/CMSIS/Include -I.\RTE\_Template -ID:\Keil_v5\Pack\ARM\CMSIS\5.7.0\CMSIS\Core\Include -ID:\Keil_v5\Pack\Keil\STM32F1xx_DFP\2.3.0\Device\Include -D__MICROLIB -D__UVISION_VERSION=533 -D_RTE_ -DSTM32F10X_MD -D_RTE_ -DUSE_FULL_LL_DRIVER -DUSE_HAL_DRIVER -DSTM32F103xB --signed_chars --omf_browse=template\stm32f1xx_ll_utils.crf ../Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_ll_utils.c]
                          THUMB

                          AREA ||i.LL_Init1msTick||, CODE, READONLY, ALIGN=1

                  LL_Init1msTick PROC
;;;165      */
;;;166    void LL_Init1msTick(uint32_t HCLKFrequency)
000000  f44f717a          MOV      r1,#0x3e8
;;;167    {
;;;168      /* Use frequency provided in argument */
;;;169      LL_InitTick(HCLKFrequency, 1000U);
000004  fbb0f2f1          UDIV     r2,r0,r1
000008  1e52              SUBS     r2,r2,#1
00000a  f04f23e0          MOV      r3,#0xe000e000
00000e  615a              STR      r2,[r3,#0x14]
000010  2200              MOVS     r2,#0
000012  619a              STR      r2,[r3,#0x18]
000014  2205              MOVS     r2,#5
000016  611a              STR      r2,[r3,#0x10]
000018  bf00              NOP      
;;;170    }
00001a  4770              BX       lr
;;;171    
                          ENDP


                          AREA ||i.LL_PLL_ConfigSystemClock_HSE||, CODE, READONLY, ALIGN=2

                  LL_PLL_ConfigSystemClock_HSE PROC
;;;398      */
;;;399    ErrorStatus LL_PLL_ConfigSystemClock_HSE(uint32_t HSEFrequency, uint32_t HSEBypass,
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;400                                             LL_UTILS_PLLInitTypeDef *UTILS_PLLInitStruct, LL_UTILS_ClkInitTypeDef *UTILS_ClkInitStruct)
;;;401    {
000004  4606              MOV      r6,r0
000006  460d              MOV      r5,r1
000008  4614              MOV      r4,r2
00000a  461f              MOV      r7,r3
;;;402      ErrorStatus status = SUCCESS;
00000c  f04f0800          MOV      r8,#0
;;;403      uint32_t pllfreq = 0U;
000010  46c1              MOV      r9,r8
;;;404    
;;;405      /* Check the parameters */
;;;406      assert_param(IS_LL_UTILS_HSE_FREQUENCY(HSEFrequency));
000012  4830              LDR      r0,|L2.212|
000014  4286              CMP      r6,r0
000016  d303              BCC      |L2.32|
000018  0080              LSLS     r0,r0,#2
00001a  4286              CMP      r6,r0
00001c  d800              BHI      |L2.32|
00001e  e004              B        |L2.42|
                  |L2.32|
000020  f44f71cb          MOV      r1,#0x196
000024  a02c              ADR      r0,|L2.216|
000026  f7fffffe          BL       assert_failed
                  |L2.42|
;;;407      assert_param(IS_LL_UTILS_HSE_BYPASS(HSEBypass));
00002a  2d01              CMP      r5,#1
00002c  d000              BEQ      |L2.48|
00002e  b905              CBNZ     r5,|L2.50|
                  |L2.48|
000030  e004              B        |L2.60|
                  |L2.50|
000032  f2401197          MOV      r1,#0x197
000036  a028              ADR      r0,|L2.216|
000038  f7fffffe          BL       assert_failed
                  |L2.60|
;;;408    
;;;409      /* Check if one of the PLL is enabled */
;;;410      if (UTILS_PLL_IsBusy() == SUCCESS)
00003c  f7fffffe          BL       UTILS_PLL_IsBusy
000040  2800              CMP      r0,#0
000042  d141              BNE      |L2.200|
;;;411      {
;;;412        assert_param(IS_LL_UTILS_PREDIV_VALUE(UTILS_PLLInitStruct->Prediv));
000044  6860              LDR      r0,[r4,#4]
000046  b118              CBZ      r0,|L2.80|
000048  6860              LDR      r0,[r4,#4]
00004a  f5b03f00          CMP      r0,#0x20000
00004e  d100              BNE      |L2.82|
                  |L2.80|
000050  e004              B        |L2.92|
                  |L2.82|
000052  f44f71ce          MOV      r1,#0x19c
000056  a020              ADR      r0,|L2.216|
000058  f7fffffe          BL       assert_failed
                  |L2.92|
;;;413    
;;;414        /* Calculate the new PLL output frequency */
;;;415        pllfreq = UTILS_GetPLLOutputFrequency(HSEFrequency, UTILS_PLLInitStruct);
00005c  4621              MOV      r1,r4
00005e  4630              MOV      r0,r6
000060  f7fffffe          BL       UTILS_GetPLLOutputFrequency
000064  4681              MOV      r9,r0
;;;416    
;;;417        /* Enable HSE if not enabled */
;;;418        if (LL_RCC_HSE_IsReady() != 1U)
000066  f7fffffe          BL       LL_RCC_HSE_IsReady
00006a  2801              CMP      r0,#1
00006c  d020              BEQ      |L2.176|
;;;419        {
;;;420          /* Check if need to enable HSE bypass feature or not */
;;;421          if (HSEBypass == LL_UTILS_HSEBYPASS_ON)
00006e  2d01              CMP      r5,#1
000070  d108              BNE      |L2.132|
;;;422          {
;;;423            LL_RCC_HSE_EnableBypass();
000072  bf00              NOP      
000074  4827              LDR      r0,|L2.276|
000076  6800              LDR      r0,[r0,#0]
000078  f4402080          ORR      r0,r0,#0x40000
00007c  4925              LDR      r1,|L2.276|
00007e  6008              STR      r0,[r1,#0]
000080  bf00              NOP      
000082  e008              B        |L2.150|
                  |L2.132|
;;;424          }
;;;425          else
;;;426          {
;;;427            LL_RCC_HSE_DisableBypass();
000084  bf00              NOP      
000086  4823              LDR      r0,|L2.276|
000088  6800              LDR      r0,[r0,#0]
00008a  f4202080          BIC      r0,r0,#0x40000
00008e  4921              LDR      r1,|L2.276|
000090  6008              STR      r0,[r1,#0]
000092  bf00              NOP      
000094  bf00              NOP      
                  |L2.150|
;;;428          }
;;;429    
;;;430          /* Enable HSE */
;;;431          LL_RCC_HSE_Enable();
000096  bf00              NOP      
000098  481e              LDR      r0,|L2.276|
00009a  6800              LDR      r0,[r0,#0]
00009c  f4403080          ORR      r0,r0,#0x10000
0000a0  491c              LDR      r1,|L2.276|
0000a2  6008              STR      r0,[r1,#0]
0000a4  bf00              NOP      
;;;432          while (LL_RCC_HSE_IsReady() != 1U)
0000a6  bf00              NOP      
                  |L2.168|
0000a8  f7fffffe          BL       LL_RCC_HSE_IsReady
0000ac  2801              CMP      r0,#1
0000ae  d1fb              BNE      |L2.168|
                  |L2.176|
;;;433          {
;;;434            /* Wait for HSE ready */
;;;435          }
;;;436        }
;;;437    
;;;438        /* Configure PLL */
;;;439        LL_RCC_PLL_ConfigDomain_SYS((RCC_CFGR_PLLSRC | UTILS_PLLInitStruct->Prediv), UTILS_PLLInitStruct->PLLMul);
0000b0  e9d41200          LDRD     r1,r2,[r4,#0]
0000b4  f4423080          ORR      r0,r2,#0x10000
0000b8  f7fffffe          BL       LL_RCC_PLL_ConfigDomain_SYS
;;;440    
;;;441        /* Enable PLL and switch system clock to PLL */
;;;442        status = UTILS_EnablePLLAndSwitchSystem(pllfreq, UTILS_ClkInitStruct);
0000bc  4639              MOV      r1,r7
0000be  4648              MOV      r0,r9
0000c0  f7fffffe          BL       UTILS_EnablePLLAndSwitchSystem
0000c4  4680              MOV      r8,r0
0000c6  e001              B        |L2.204|
                  |L2.200|
;;;443      }
;;;444      else
;;;445      {
;;;446        /* Current PLL configuration cannot be modified */
;;;447        status = ERROR;
0000c8  f04f0801          MOV      r8,#1
                  |L2.204|
;;;448      }
;;;449    
;;;450      return status;
0000cc  4640              MOV      r0,r8
;;;451    }
0000ce  e8bd87f0          POP      {r4-r10,pc}
;;;452    
                          ENDP

0000d2  0000              DCW      0x0000
                  |L2.212|
                          DCD      0x003d0900
                  |L2.216|
0000d8  2e2e2f44          DCB      "../Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_ll_utils."
0000dc  72697665
0000e0  72732f53
0000e4  544d3332
0000e8  46317878
0000ec  5f48414c
0000f0  5f447269
0000f4  7665722f
0000f8  5372632f
0000fc  73746d33
000100  32663178
000104  785f6c6c
000108  5f757469
00010c  6c732e  
00010f  6300              DCB      "c",0
000111  00                DCB      0
000112  00                DCB      0
000113  00                DCB      0
                  |L2.276|
                          DCD      0x40021000

                          AREA ||i.LL_PLL_ConfigSystemClock_HSI||, CODE, READONLY, ALIGN=2

                  LL_PLL_ConfigSystemClock_HSI PROC
;;;333      */
;;;334    ErrorStatus LL_PLL_ConfigSystemClock_HSI(LL_UTILS_PLLInitTypeDef *UTILS_PLLInitStruct,
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;335                                             LL_UTILS_ClkInitTypeDef *UTILS_ClkInitStruct)
;;;336    {
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
;;;337      ErrorStatus status = SUCCESS;
000008  2600              MOVS     r6,#0
;;;338      uint32_t pllfreq = 0U;
00000a  2700              MOVS     r7,#0
;;;339    
;;;340      /* Check if one of the PLL is enabled */
;;;341      if (UTILS_PLL_IsBusy() == SUCCESS)
00000c  f7fffffe          BL       UTILS_PLL_IsBusy
000010  bb10              CBNZ     r0,|L3.88|
;;;342      {
;;;343    #if defined(RCC_PLLSRC_PREDIV1_SUPPORT)
;;;344        /* Check PREDIV value */
;;;345        assert_param(IS_LL_UTILS_PREDIV_VALUE(UTILS_PLLInitStruct->PLLDiv));
;;;346    #else
;;;347        /* Force PREDIV value to 2 */
;;;348        UTILS_PLLInitStruct->Prediv = LL_RCC_PREDIV_DIV_2;
000012  f44f3000          MOV      r0,#0x20000
000016  6060              STR      r0,[r4,#4]
;;;349    #endif /*RCC_PLLSRC_PREDIV1_SUPPORT*/
;;;350        /* Calculate the new PLL output frequency */
;;;351        pllfreq = UTILS_GetPLLOutputFrequency(HSI_VALUE, UTILS_PLLInitStruct);
000018  4621              MOV      r1,r4
00001a  4811              LDR      r0,|L3.96|
00001c  f7fffffe          BL       UTILS_GetPLLOutputFrequency
000020  4607              MOV      r7,r0
;;;352    
;;;353        /* Enable HSI if not enabled */
;;;354        if (LL_RCC_HSI_IsReady() != 1U)
000022  f7fffffe          BL       LL_RCC_HSI_IsReady
000026  2801              CMP      r0,#1
000028  d00c              BEQ      |L3.68|
;;;355        {
;;;356          LL_RCC_HSI_Enable();
00002a  bf00              NOP      
00002c  480d              LDR      r0,|L3.100|
00002e  6800              LDR      r0,[r0,#0]
000030  f0400001          ORR      r0,r0,#1
000034  490b              LDR      r1,|L3.100|
000036  6008              STR      r0,[r1,#0]
000038  bf00              NOP      
;;;357          while (LL_RCC_HSI_IsReady() != 1U)
00003a  bf00              NOP      
                  |L3.60|
00003c  f7fffffe          BL       LL_RCC_HSI_IsReady
000040  2801              CMP      r0,#1
000042  d1fb              BNE      |L3.60|
                  |L3.68|
;;;358          {
;;;359            /* Wait for HSI ready */
;;;360          }
;;;361        }
;;;362    
;;;363        /* Configure PLL */
;;;364        LL_RCC_PLL_ConfigDomain_SYS(LL_RCC_PLLSOURCE_HSI_DIV_2, UTILS_PLLInitStruct->PLLMul);
000044  2000              MOVS     r0,#0
000046  6821              LDR      r1,[r4,#0]
000048  f7fffffe          BL       LL_RCC_PLL_ConfigDomain_SYS
;;;365    
;;;366        /* Enable PLL and switch system clock to PLL */
;;;367        status = UTILS_EnablePLLAndSwitchSystem(pllfreq, UTILS_ClkInitStruct);
00004c  4629              MOV      r1,r5
00004e  4638              MOV      r0,r7
000050  f7fffffe          BL       UTILS_EnablePLLAndSwitchSystem
000054  4606              MOV      r6,r0
000056  e000              B        |L3.90|
                  |L3.88|
;;;368      }
;;;369      else
;;;370      {
;;;371        /* Current PLL configuration cannot be modified */
;;;372        status = ERROR;
000058  2601              MOVS     r6,#1
                  |L3.90|
;;;373      }
;;;374    
;;;375      return status;
00005a  4630              MOV      r0,r6
;;;376    }
00005c  e8bd81f0          POP      {r4-r8,pc}
;;;377    
                          ENDP

                  |L3.96|
                          DCD      0x007a1200
                  |L3.100|
                          DCD      0x40021000

                          AREA ||i.LL_RCC_HSE_IsReady||, CODE, READONLY, ALIGN=2

                  LL_RCC_HSE_IsReady PROC
;;;793      */
;;;794    __STATIC_INLINE uint32_t LL_RCC_HSE_IsReady(void)
000000  4802              LDR      r0,|L4.12|
;;;795    {
;;;796      return (READ_BIT(RCC->CR, RCC_CR_HSERDY) == (RCC_CR_HSERDY));
000002  6800              LDR      r0,[r0,#0]
000004  f3c04040          UBFX     r0,r0,#17,#1
;;;797    }
000008  4770              BX       lr
;;;798    
                          ENDP

00000a  0000              DCW      0x0000
                  |L4.12|
                          DCD      0x40021000

                          AREA ||i.LL_RCC_HSI_IsReady||, CODE, READONLY, ALIGN=2

                  LL_RCC_HSI_IsReady PROC
;;;859      */
;;;860    __STATIC_INLINE uint32_t LL_RCC_HSI_IsReady(void)
000000  4802              LDR      r0,|L5.12|
;;;861    {
;;;862      return (READ_BIT(RCC->CR, RCC_CR_HSIRDY) == (RCC_CR_HSIRDY));
000002  6800              LDR      r0,[r0,#0]
000004  f3c00040          UBFX     r0,r0,#1,#1
;;;863    }
000008  4770              BX       lr
;;;864    
                          ENDP

00000a  0000              DCW      0x0000
                  |L5.12|
                          DCD      0x40021000

                          AREA ||i.LL_RCC_PLL_ConfigDomain_SYS||, CODE, READONLY, ALIGN=2

                  LL_RCC_PLL_ConfigDomain_SYS PROC
;;;1476     */
;;;1477   __STATIC_INLINE void LL_RCC_PLL_ConfigDomain_SYS(uint32_t Source, uint32_t PLLMul)
000000  4a05              LDR      r2,|L6.24|
;;;1478   {
;;;1479     MODIFY_REG(RCC->CFGR, RCC_CFGR_PLLSRC | RCC_CFGR_PLLXTPRE | RCC_CFGR_PLLMULL,
000002  6852              LDR      r2,[r2,#4]
000004  f422127c          BIC      r2,r2,#0x3f0000
000008  f4003340          AND      r3,r0,#0x30000
00000c  430b              ORRS     r3,r3,r1
00000e  431a              ORRS     r2,r2,r3
000010  4b01              LDR      r3,|L6.24|
000012  605a              STR      r2,[r3,#4]
;;;1480                (Source & (RCC_CFGR_PLLSRC | RCC_CFGR_PLLXTPRE)) | PLLMul);
;;;1481   #if defined(RCC_CFGR2_PREDIV1)
;;;1482   #if defined(RCC_CFGR2_PREDIV1SRC)
;;;1483     MODIFY_REG(RCC->CFGR2, (RCC_CFGR2_PREDIV1 | RCC_CFGR2_PREDIV1SRC),
;;;1484                (Source & RCC_CFGR2_PREDIV1) | ((Source & (RCC_CFGR2_PREDIV1SRC << 4U)) >> 4U));
;;;1485   #else
;;;1486     MODIFY_REG(RCC->CFGR2, RCC_CFGR2_PREDIV1, (Source & RCC_CFGR2_PREDIV1));
;;;1487   #endif /*RCC_CFGR2_PREDIV1SRC*/
;;;1488   #endif /*RCC_CFGR2_PREDIV1*/
;;;1489   }
000014  4770              BX       lr
;;;1490   
                          ENDP

000016  0000              DCW      0x0000
                  |L6.24|
                          DCD      0x40021000

                          AREA ||i.LL_RCC_PLL_IsReady||, CODE, READONLY, ALIGN=2

                  LL_RCC_PLL_IsReady PROC
;;;1407     */
;;;1408   __STATIC_INLINE uint32_t LL_RCC_PLL_IsReady(void)
000000  4802              LDR      r0,|L7.12|
;;;1409   {
;;;1410     return (READ_BIT(RCC->CR, RCC_CR_PLLRDY) == (RCC_CR_PLLRDY));
000002  6800              LDR      r0,[r0,#0]
000004  f3c06040          UBFX     r0,r0,#25,#1
;;;1411   }
000008  4770              BX       lr
;;;1412   
                          ENDP

00000a  0000              DCW      0x0000
                  |L7.12|
                          DCD      0x40021000

                          AREA ||i.LL_SetFlashLatency||, CODE, READONLY, ALIGN=2

                  LL_SetFlashLatency PROC
;;;254    #if defined(FLASH_ACR_LATENCY)
;;;255    ErrorStatus LL_SetFlashLatency(uint32_t Frequency)
000000  b570              PUSH     {r4-r6,lr}
;;;256    {
000002  4602              MOV      r2,r0
;;;257      uint32_t timeout;
;;;258      uint32_t getlatency;
;;;259      uint32_t latency = LL_FLASH_LATENCY_0; /* default value 0WS */
000004  2100              MOVS     r1,#0
;;;260      ErrorStatus status = SUCCESS;
000006  2000              MOVS     r0,#0
;;;261    
;;;262      /* Frequency cannot be equal to 0 */
;;;263      if (Frequency == 0U)
000008  b90a              CBNZ     r2,|L8.14|
;;;264      {
;;;265        status = ERROR;
00000a  2001              MOVS     r0,#1
00000c  e027              B        |L8.94|
                  |L8.14|
;;;266      }
;;;267      else
;;;268      {
;;;269        if (Frequency > UTILS_LATENCY2_FREQ)
00000e  4d14              LDR      r5,|L8.96|
000010  42aa              CMP      r2,r5
000012  d901              BLS      |L8.24|
;;;270        {
;;;271          /* 48 < SYSCLK <= 72 => 2WS (3 CPU cycles) */
;;;272          latency = LL_FLASH_LATENCY_2;
000014  2102              MOVS     r1,#2
000016  e005              B        |L8.36|
                  |L8.24|
;;;273        }
;;;274        else
;;;275        {
;;;276          if (Frequency > UTILS_LATENCY1_FREQ)
000018  4d12              LDR      r5,|L8.100|
00001a  42aa              CMP      r2,r5
00001c  d901              BLS      |L8.34|
;;;277          {
;;;278            /* 24 < SYSCLK <= 48 => 1WS (2 CPU cycles) */
;;;279            latency = LL_FLASH_LATENCY_1;
00001e  2101              MOVS     r1,#1
000020  e000              B        |L8.36|
                  |L8.34|
;;;280          }
;;;281          else
;;;282          {
;;;283            /* else SYSCLK < 24MHz default LL_FLASH_LATENCY_0 0WS */
;;;284            latency = LL_FLASH_LATENCY_0;
000022  2100              MOVS     r1,#0
                  |L8.36|
;;;285          }
;;;286        }
;;;287    
;;;288        if (status != ERROR)
000024  2801              CMP      r0,#1
000026  d01a              BEQ      |L8.94|
;;;289        {
;;;290          LL_FLASH_SetLatency(latency);
000028  bf00              NOP      
00002a  4d0f              LDR      r5,|L8.104|
00002c  682d              LDR      r5,[r5,#0]
00002e  f0250507          BIC      r5,r5,#7
000032  430d              ORRS     r5,r5,r1
000034  4e0c              LDR      r6,|L8.104|
000036  6035              STR      r5,[r6,#0]
000038  bf00              NOP      
;;;291    
;;;292          /* Check that the new number of wait states is taken into account to access the Flash
;;;293             memory by reading the FLASH_ACR register */
;;;294          timeout = 2;
00003a  2402              MOVS     r4,#2
;;;295          do
00003c  bf00              NOP      
                  |L8.62|
;;;296          {
;;;297          /* Wait for Flash latency to be updated */
;;;298          getlatency = LL_FLASH_GetLatency();
00003e  bf00              NOP      
000040  4d09              LDR      r5,|L8.104|
000042  682d              LDR      r5,[r5,#0]
000044  f0050307          AND      r3,r5,#7
000048  bf00              NOP      
;;;299          timeout--;
00004a  1e64              SUBS     r4,r4,#1
;;;300          } while ((getlatency != latency) && (timeout > 0));
00004c  428b              CMP      r3,r1
00004e  d001              BEQ      |L8.84|
000050  2c00              CMP      r4,#0
000052  d1f4              BNE      |L8.62|
                  |L8.84|
;;;301    
;;;302          if(getlatency != latency)
000054  428b              CMP      r3,r1
000056  d001              BEQ      |L8.92|
;;;303          {
;;;304            status = ERROR;
000058  2001              MOVS     r0,#1
00005a  e000              B        |L8.94|
                  |L8.92|
;;;305          }
;;;306          else
;;;307          {
;;;308            status = SUCCESS;
00005c  2000              MOVS     r0,#0
                  |L8.94|
;;;309          }
;;;310        }
;;;311      }
;;;312    
;;;313      return status;
;;;314    }
00005e  bd70              POP      {r4-r6,pc}
;;;315    #endif /* FLASH_ACR_LATENCY */
                          ENDP

                  |L8.96|
                          DCD      0x02dc6c00
                  |L8.100|
                          DCD      0x016e3600
                  |L8.104|
                          DCD      0x40022000

                          AREA ||i.LL_SetSystemCoreClock||, CODE, READONLY, ALIGN=2

                  LL_SetSystemCoreClock PROC
;;;239      */
;;;240    void LL_SetSystemCoreClock(uint32_t HCLKFrequency)
000000  4901              LDR      r1,|L9.8|
;;;241    {
;;;242      /* HCLK clock frequency */
;;;243      SystemCoreClock = HCLKFrequency;
000002  6008              STR      r0,[r1,#0]  ; SystemCoreClock
;;;244    }
000004  4770              BX       lr
;;;245    
                          ENDP

000006  0000              DCW      0x0000
                  |L9.8|
                          DCD      SystemCoreClock

                          AREA ||i.LL_mDelay||, CODE, READONLY, ALIGN=1

                  LL_mDelay PROC
;;;181      */
;;;182    void LL_mDelay(uint32_t Delay)
000000  b508              PUSH     {r3,lr}
;;;183    {
;;;184      __IO uint32_t  tmp = SysTick->CTRL;  /* Clear the COUNTFLAG first */
000002  f04f21e0          MOV      r1,#0xe000e000
000006  6909              LDR      r1,[r1,#0x10]
000008  9100              STR      r1,[sp,#0]
;;;185      /* Add this code to indicate that local variable is not used */
;;;186      ((void)tmp);
00000a  bf00              NOP      
;;;187    
;;;188      /* Add a period to guaranty minimum wait */
;;;189      if (Delay < LL_MAX_DELAY)
00000c  1c41              ADDS     r1,r0,#1
00000e  b101              CBZ      r1,|L10.18|
;;;190      {
;;;191        Delay++;
000010  1c40              ADDS     r0,r0,#1
                  |L10.18|
;;;192      }
;;;193    
;;;194      while (Delay)
000012  e006              B        |L10.34|
                  |L10.20|
;;;195      {
;;;196        if ((SysTick->CTRL & SysTick_CTRL_COUNTFLAG_Msk) != 0U)
000014  f04f21e0          MOV      r1,#0xe000e000
000018  6909              LDR      r1,[r1,#0x10]
00001a  f4013180          AND      r1,r1,#0x10000
00001e  b101              CBZ      r1,|L10.34|
;;;197        {
;;;198          Delay--;
000020  1e40              SUBS     r0,r0,#1
                  |L10.34|
000022  2800              CMP      r0,#0                 ;194
000024  d1f6              BNE      |L10.20|
;;;199        }
;;;200      }
;;;201    }
000026  bd08              POP      {r3,pc}
;;;202    
                          ENDP


                          AREA ||i.UTILS_EnablePLLAndSwitchSystem||, CODE, READONLY, ALIGN=2

                  UTILS_EnablePLLAndSwitchSystem PROC
;;;534      */
;;;535    static ErrorStatus UTILS_EnablePLLAndSwitchSystem(uint32_t SYSCLK_Frequency, LL_UTILS_ClkInitTypeDef *UTILS_ClkInitStruct)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;536    {
000004  4605              MOV      r5,r0
000006  460c              MOV      r4,r1
;;;537      ErrorStatus status = SUCCESS;
000008  2600              MOVS     r6,#0
;;;538    #if defined(FLASH_ACR_LATENCY)
;;;539      uint32_t sysclk_frequency_current = 0U;
00000a  2700              MOVS     r7,#0
;;;540    #endif /* FLASH_ACR_LATENCY */
;;;541    
;;;542      assert_param(IS_LL_UTILS_SYSCLK_DIV(UTILS_ClkInitStruct->AHBCLKDivider));
00000c  6820              LDR      r0,[r4,#0]
00000e  b1b8              CBZ      r0,|L11.64|
000010  6820              LDR      r0,[r4,#0]
000012  2880              CMP      r0,#0x80
000014  d014              BEQ      |L11.64|
000016  6820              LDR      r0,[r4,#0]
000018  2890              CMP      r0,#0x90
00001a  d011              BEQ      |L11.64|
00001c  6820              LDR      r0,[r4,#0]
00001e  28a0              CMP      r0,#0xa0
000020  d00e              BEQ      |L11.64|
000022  6820              LDR      r0,[r4,#0]
000024  28b0              CMP      r0,#0xb0
000026  d00b              BEQ      |L11.64|
000028  6820              LDR      r0,[r4,#0]
00002a  28c0              CMP      r0,#0xc0
00002c  d008              BEQ      |L11.64|
00002e  6820              LDR      r0,[r4,#0]
000030  28d0              CMP      r0,#0xd0
000032  d005              BEQ      |L11.64|
000034  6820              LDR      r0,[r4,#0]
000036  28e0              CMP      r0,#0xe0
000038  d002              BEQ      |L11.64|
00003a  6820              LDR      r0,[r4,#0]
00003c  28f0              CMP      r0,#0xf0
00003e  d100              BNE      |L11.66|
                  |L11.64|
000040  e004              B        |L11.76|
                  |L11.66|
000042  f240211e          MOV      r1,#0x21e
000046  a049              ADR      r0,|L11.364|
000048  f7fffffe          BL       assert_failed
                  |L11.76|
;;;543      assert_param(IS_LL_UTILS_APB1_DIV(UTILS_ClkInitStruct->APB1CLKDivider));
00004c  6860              LDR      r0,[r4,#4]
00004e  b178              CBZ      r0,|L11.112|
000050  6860              LDR      r0,[r4,#4]
000052  f5b06f80          CMP      r0,#0x400
000056  d00b              BEQ      |L11.112|
000058  6860              LDR      r0,[r4,#4]
00005a  f5b06fa0          CMP      r0,#0x500
00005e  d007              BEQ      |L11.112|
000060  6860              LDR      r0,[r4,#4]
000062  f5b06fc0          CMP      r0,#0x600
000066  d003              BEQ      |L11.112|
000068  6860              LDR      r0,[r4,#4]
00006a  f5b06fe0          CMP      r0,#0x700
00006e  d100              BNE      |L11.114|
                  |L11.112|
000070  e004              B        |L11.124|
                  |L11.114|
000072  f240211f          MOV      r1,#0x21f
000076  a03d              ADR      r0,|L11.364|
000078  f7fffffe          BL       assert_failed
                  |L11.124|
;;;544      assert_param(IS_LL_UTILS_APB2_DIV(UTILS_ClkInitStruct->APB2CLKDivider));
00007c  68a0              LDR      r0,[r4,#8]
00007e  b178              CBZ      r0,|L11.160|
000080  68a0              LDR      r0,[r4,#8]
000082  f5b05f00          CMP      r0,#0x2000
000086  d00b              BEQ      |L11.160|
000088  68a0              LDR      r0,[r4,#8]
00008a  f5b05f20          CMP      r0,#0x2800
00008e  d007              BEQ      |L11.160|
000090  68a0              LDR      r0,[r4,#8]
000092  f5b05f40          CMP      r0,#0x3000
000096  d003              BEQ      |L11.160|
000098  68a0              LDR      r0,[r4,#8]
00009a  f5b05f60          CMP      r0,#0x3800
00009e  d100              BNE      |L11.162|
                  |L11.160|
0000a0  e004              B        |L11.172|
                  |L11.162|
0000a2  f44f7108          MOV      r1,#0x220
0000a6  a031              ADR      r0,|L11.364|
0000a8  f7fffffe          BL       assert_failed
                  |L11.172|
;;;545    
;;;546    #if defined(FLASH_ACR_LATENCY)
;;;547      /* Calculate current SYSCLK frequency */
;;;548      sysclk_frequency_current = (SystemCoreClock << AHBPrescTable[LL_RCC_GetAHBPrescaler() >> RCC_CFGR_HPRE_Pos]);
0000ac  bf00              NOP      
0000ae  483e              LDR      r0,|L11.424|
0000b0  6840              LDR      r0,[r0,#4]
0000b2  f00000f0          AND      r0,r0,#0xf0
0000b6  493d              LDR      r1,|L11.428|
0000b8  eb011010          ADD      r0,r1,r0,LSR #4
0000bc  7801              LDRB     r1,[r0,#0]
0000be  483c              LDR      r0,|L11.432|
0000c0  6800              LDR      r0,[r0,#0]  ; SystemCoreClock
0000c2  fa00f701          LSL      r7,r0,r1
;;;549    #endif /* FLASH_ACR_LATENCY */
;;;550    
;;;551      /* Increasing the number of wait states because of higher CPU frequency */
;;;552    #if defined (FLASH_ACR_LATENCY)
;;;553      if (sysclk_frequency_current < SYSCLK_Frequency)
0000c6  42af              CMP      r7,r5
0000c8  d203              BCS      |L11.210|
;;;554      {
;;;555        /* Set FLASH latency to highest latency */
;;;556        status = LL_SetFlashLatency(SYSCLK_Frequency);
0000ca  4628              MOV      r0,r5
0000cc  f7fffffe          BL       LL_SetFlashLatency
0000d0  4606              MOV      r6,r0
                  |L11.210|
;;;557      }
;;;558    #endif /* FLASH_ACR_LATENCY */
;;;559    
;;;560      /* Update system clock configuration */
;;;561      if (status == SUCCESS)
0000d2  bbbe              CBNZ     r6,|L11.324|
;;;562      {
;;;563    #if defined(RCC_PLL2_SUPPORT)
;;;564        if (LL_RCC_PLL_GetMainSource() != LL_RCC_PLLSOURCE_HSI_DIV_2)
;;;565        {
;;;566          /* Enable PLL2 */
;;;567          LL_RCC_PLL2_Enable();
;;;568          while (LL_RCC_PLL2_IsReady() != 1U)
;;;569          {
;;;570            /* Wait for PLL2 ready */
;;;571          }
;;;572        }
;;;573    #endif /* RCC_PLL2_SUPPORT */
;;;574        /* Enable PLL */
;;;575        LL_RCC_PLL_Enable();
0000d4  bf00              NOP      
0000d6  4834              LDR      r0,|L11.424|
0000d8  6800              LDR      r0,[r0,#0]
0000da  f0407080          ORR      r0,r0,#0x1000000
0000de  4932              LDR      r1,|L11.424|
0000e0  6008              STR      r0,[r1,#0]
0000e2  bf00              NOP      
;;;576        while (LL_RCC_PLL_IsReady() != 1U)
0000e4  bf00              NOP      
                  |L11.230|
0000e6  f7fffffe          BL       LL_RCC_PLL_IsReady
0000ea  2801              CMP      r0,#1
0000ec  d1fb              BNE      |L11.230|
;;;577        {
;;;578          /* Wait for PLL ready */
;;;579        }
;;;580    
;;;581        /* Sysclk activation on the main PLL */
;;;582        LL_RCC_SetAHBPrescaler(UTILS_ClkInitStruct->AHBCLKDivider);
0000ee  6820              LDR      r0,[r4,#0]
0000f0  492d              LDR      r1,|L11.424|
0000f2  6849              LDR      r1,[r1,#4]
0000f4  f02101f0          BIC      r1,r1,#0xf0
0000f8  4301              ORRS     r1,r1,r0
0000fa  4a2b              LDR      r2,|L11.424|
0000fc  6051              STR      r1,[r2,#4]
0000fe  bf00              NOP      
;;;583        LL_RCC_SetSysClkSource(LL_RCC_SYS_CLKSOURCE_PLL);
000100  2002              MOVS     r0,#2
000102  4611              MOV      r1,r2
000104  6849              LDR      r1,[r1,#4]
000106  f0210103          BIC      r1,r1,#3
00010a  4301              ORRS     r1,r1,r0
00010c  6051              STR      r1,[r2,#4]
00010e  bf00              NOP      
;;;584        while (LL_RCC_GetSysClkSource() != LL_RCC_SYS_CLKSOURCE_STATUS_PLL)
000110  bf00              NOP      
                  |L11.274|
000112  bf00              NOP      
000114  4824              LDR      r0,|L11.424|
000116  6840              LDR      r0,[r0,#4]
000118  f000000c          AND      r0,r0,#0xc
00011c  2808              CMP      r0,#8
00011e  d1f8              BNE      |L11.274|
;;;585        {
;;;586          /* Wait for system clock switch to PLL */
;;;587        }
;;;588    
;;;589        /* Set APB1 & APB2 prescaler*/
;;;590        LL_RCC_SetAPB1Prescaler(UTILS_ClkInitStruct->APB1CLKDivider);
000120  6860              LDR      r0,[r4,#4]
000122  4921              LDR      r1,|L11.424|
000124  6849              LDR      r1,[r1,#4]
000126  f42161e0          BIC      r1,r1,#0x700
00012a  4301              ORRS     r1,r1,r0
00012c  4a1e              LDR      r2,|L11.424|
00012e  6051              STR      r1,[r2,#4]
000130  bf00              NOP      
;;;591        LL_RCC_SetAPB2Prescaler(UTILS_ClkInitStruct->APB2CLKDivider);
000132  68a0              LDR      r0,[r4,#8]
000134  4611              MOV      r1,r2
000136  6849              LDR      r1,[r1,#4]
000138  f4215160          BIC      r1,r1,#0x3800
00013c  4301              ORRS     r1,r1,r0
00013e  6051              STR      r1,[r2,#4]
000140  bf00              NOP      
000142  bf00              NOP      
                  |L11.324|
;;;592      }
;;;593    
;;;594      /* Decreasing the number of wait states because of lower CPU frequency */
;;;595    #if defined (FLASH_ACR_LATENCY)
;;;596      if (sysclk_frequency_current > SYSCLK_Frequency)
000144  42af              CMP      r7,r5
000146  d903              BLS      |L11.336|
;;;597      {
;;;598        /* Set FLASH latency to lowest latency */
;;;599        status = LL_SetFlashLatency(SYSCLK_Frequency);
000148  4628              MOV      r0,r5
00014a  f7fffffe          BL       LL_SetFlashLatency
00014e  4606              MOV      r6,r0
                  |L11.336|
;;;600      }
;;;601    #endif /* FLASH_ACR_LATENCY */
;;;602    
;;;603      /* Update SystemCoreClock variable */
;;;604      if (status == SUCCESS)
000150  b946              CBNZ     r6,|L11.356|
;;;605      {
;;;606        LL_SetSystemCoreClock(__LL_RCC_CALC_HCLK_FREQ(SYSCLK_Frequency, UTILS_ClkInitStruct->AHBCLKDivider));
000152  7821              LDRB     r1,[r4,#0]
000154  f3c11103          UBFX     r1,r1,#4,#4
000158  4a14              LDR      r2,|L11.428|
00015a  5c51              LDRB     r1,[r2,r1]
00015c  fa25f001          LSR      r0,r5,r1
000160  f7fffffe          BL       LL_SetSystemCoreClock
                  |L11.356|
;;;607      }
;;;608    
;;;609      return status;
000164  4630              MOV      r0,r6
;;;610    }
000166  e8bd81f0          POP      {r4-r8,pc}
;;;611    
                          ENDP

00016a  0000              DCW      0x0000
                  |L11.364|
00016c  2e2e2f44          DCB      "../Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_ll_utils."
000170  72697665
000174  72732f53
000178  544d3332
00017c  46317878
000180  5f48414c
000184  5f447269
000188  7665722f
00018c  5372632f
000190  73746d33
000194  32663178
000198  785f6c6c
00019c  5f757469
0001a0  6c732e  
0001a3  6300              DCB      "c",0
0001a5  00                DCB      0
0001a6  00                DCB      0
0001a7  00                DCB      0
                  |L11.424|
                          DCD      0x40021000
                  |L11.428|
                          DCD      AHBPrescTable
                  |L11.432|
                          DCD      SystemCoreClock

                          AREA ||i.UTILS_GetPLLOutputFrequency||, CODE, READONLY, ALIGN=2

                  UTILS_GetPLLOutputFrequency PROC
;;;470      */
;;;471    static uint32_t UTILS_GetPLLOutputFrequency(uint32_t PLL_InputFrequency, LL_UTILS_PLLInitTypeDef *UTILS_PLLInitStruct)
000000  b570              PUSH     {r4-r6,lr}
;;;472    {
000002  4605              MOV      r5,r0
000004  460c              MOV      r4,r1
;;;473      uint32_t pllfreq = 0U;
000006  2600              MOVS     r6,#0
;;;474    
;;;475      /* Check the parameters */
;;;476      assert_param(IS_LL_UTILS_PLLMUL_VALUE(UTILS_PLLInitStruct->PLLMul));
000008  6820              LDR      r0,[r4,#0]
00000a  b3b8              CBZ      r0,|L12.124|
00000c  6820              LDR      r0,[r4,#0]
00000e  f5b02f80          CMP      r0,#0x40000
000012  d033              BEQ      |L12.124|
000014  6820              LDR      r0,[r4,#0]
000016  f5b02f00          CMP      r0,#0x80000
00001a  d02f              BEQ      |L12.124|
00001c  6820              LDR      r0,[r4,#0]
00001e  f5b02f40          CMP      r0,#0xc0000
000022  d02b              BEQ      |L12.124|
000024  6820              LDR      r0,[r4,#0]
000026  f5b01f80          CMP      r0,#0x100000
00002a  d027              BEQ      |L12.124|
00002c  6820              LDR      r0,[r4,#0]
00002e  f5b01fa0          CMP      r0,#0x140000
000032  d023              BEQ      |L12.124|
000034  6820              LDR      r0,[r4,#0]
000036  f5b01fc0          CMP      r0,#0x180000
00003a  d01f              BEQ      |L12.124|
00003c  6820              LDR      r0,[r4,#0]
00003e  f5b01fe0          CMP      r0,#0x1c0000
000042  d01b              BEQ      |L12.124|
000044  6820              LDR      r0,[r4,#0]
000046  f5b01f00          CMP      r0,#0x200000
00004a  d017              BEQ      |L12.124|
00004c  6820              LDR      r0,[r4,#0]
00004e  f5b01f10          CMP      r0,#0x240000
000052  d013              BEQ      |L12.124|
000054  6820              LDR      r0,[r4,#0]
000056  f5b01f20          CMP      r0,#0x280000
00005a  d00f              BEQ      |L12.124|
00005c  6820              LDR      r0,[r4,#0]
00005e  f5b01f30          CMP      r0,#0x2c0000
000062  d00b              BEQ      |L12.124|
000064  6820              LDR      r0,[r4,#0]
000066  f5b01f40          CMP      r0,#0x300000
00006a  d007              BEQ      |L12.124|
00006c  6820              LDR      r0,[r4,#0]
00006e  f5b01f50          CMP      r0,#0x340000
000072  d003              BEQ      |L12.124|
000074  6820              LDR      r0,[r4,#0]
000076  f5b01f60          CMP      r0,#0x380000
00007a  d100              BNE      |L12.126|
                  |L12.124|
00007c  e004              B        |L12.136|
                  |L12.126|
00007e  f44f71ee          MOV      r1,#0x1dc
000082  a00d              ADR      r0,|L12.184|
000084  f7fffffe          BL       assert_failed
                  |L12.136|
;;;477    
;;;478      /* Check different PLL parameters according to RM                          */
;;;479    #if defined (RCC_CFGR2_PREDIV1)
;;;480      pllfreq = __LL_RCC_CALC_PLLCLK_FREQ(PLL_InputFrequency / (UTILS_PLLInitStruct->Prediv + 1U), UTILS_PLLInitStruct->PLLMul);
;;;481    #else
;;;482      pllfreq = __LL_RCC_CALC_PLLCLK_FREQ(PLL_InputFrequency / ((UTILS_PLLInitStruct->Prediv >> RCC_CFGR_PLLXTPRE_Pos) + 1U), UTILS_PLLInitStruct->PLLMul);
000088  2101              MOVS     r1,#1
00008a  6860              LDR      r0,[r4,#4]
00008c  eb014050          ADD      r0,r1,r0,LSR #17
000090  fbb5f0f0          UDIV     r0,r5,r0
000094  2202              MOVS     r2,#2
000096  6821              LDR      r1,[r4,#0]
000098  eb024191          ADD      r1,r2,r1,LSR #18
00009c  fb00f601          MUL      r6,r0,r1
;;;483    #endif /*RCC_CFGR2_PREDIV1SRC*/
;;;484      assert_param(IS_LL_UTILS_PLL_FREQUENCY(pllfreq));
0000a0  4814              LDR      r0,|L12.244|
0000a2  4286              CMP      r6,r0
0000a4  d800              BHI      |L12.168|
0000a6  e004              B        |L12.178|
                  |L12.168|
0000a8  f44f71f2          MOV      r1,#0x1e4
0000ac  a002              ADR      r0,|L12.184|
0000ae  f7fffffe          BL       assert_failed
                  |L12.178|
;;;485    
;;;486      return pllfreq;
0000b2  4630              MOV      r0,r6
;;;487    }
0000b4  bd70              POP      {r4-r6,pc}
;;;488    
                          ENDP

0000b6  0000              DCW      0x0000
                  |L12.184|
0000b8  2e2e2f44          DCB      "../Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_ll_utils."
0000bc  72697665
0000c0  72732f53
0000c4  544d3332
0000c8  46317878
0000cc  5f48414c
0000d0  5f447269
0000d4  7665722f
0000d8  5372632f
0000dc  73746d33
0000e0  32663178
0000e4  785f6c6c
0000e8  5f757469
0000ec  6c732e  
0000ef  6300              DCB      "c",0
0000f1  00                DCB      0
0000f2  00                DCB      0
0000f3  00                DCB      0
                  |L12.244|
                          DCD      0x044aa200

                          AREA ||i.UTILS_PLL_IsBusy||, CODE, READONLY, ALIGN=1

                  UTILS_PLL_IsBusy PROC
;;;494      */
;;;495    static ErrorStatus UTILS_PLL_IsBusy(void)
000000  b510              PUSH     {r4,lr}
;;;496    {
;;;497      ErrorStatus status = SUCCESS;
000002  2400              MOVS     r4,#0
;;;498    
;;;499      /* Check if PLL is busy*/
;;;500      if (LL_RCC_PLL_IsReady() != 0U)
000004  f7fffffe          BL       LL_RCC_PLL_IsReady
000008  b100              CBZ      r0,|L13.12|
;;;501      {
;;;502        /* PLL configuration cannot be modified */
;;;503        status = ERROR;
00000a  2401              MOVS     r4,#1
                  |L13.12|
;;;504      }
;;;505    #if defined(RCC_PLL2_SUPPORT)
;;;506      /* Check if PLL2 is busy*/
;;;507      if (LL_RCC_PLL2_IsReady() != 0U)
;;;508      {
;;;509        /* PLL2 configuration cannot be modified */
;;;510        status = ERROR;
;;;511      }
;;;512    #endif /* RCC_PLL2_SUPPORT */
;;;513    
;;;514    #if defined(RCC_PLLI2S_SUPPORT)
;;;515      /* Check if PLLI2S  is busy*/
;;;516      if (LL_RCC_PLLI2S_IsReady() != 0U)
;;;517      {
;;;518        /* PLLI2S configuration cannot be modified */
;;;519        status = ERROR;
;;;520      }
;;;521    #endif /* RCC_PLLI2S_SUPPORT */
;;;522    
;;;523      return status;
00000c  4620              MOV      r0,r4
;;;524    }
00000e  bd10              POP      {r4,pc}
;;;525    
                          ENDP


;*** Start embedded assembler ***

#line 1 "../Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_ll_utils.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___20_stm32f1xx_ll_utils_c_fa0b8999____REV16|
#line 463 "../Drivers/CMSIS/Include/cmsis_armcc.h"
|__asm___20_stm32f1xx_ll_utils_c_fa0b8999____REV16| PROC
#line 464

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___20_stm32f1xx_ll_utils_c_fa0b8999____REVSH|
#line 478
|__asm___20_stm32f1xx_ll_utils_c_fa0b8999____REVSH| PROC
#line 479

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___20_stm32f1xx_ll_utils_c_fa0b8999____RRX|
#line 665
|__asm___20_stm32f1xx_ll_utils_c_fa0b8999____RRX| PROC
#line 666

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
