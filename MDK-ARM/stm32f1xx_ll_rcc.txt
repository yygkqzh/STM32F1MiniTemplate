; generated by Component: ARM Compiler 5.06 update 7 (build 960) Tool: ArmCC [4d365d]
; commandline ArmCC [--c99 --split_sections --debug -c --asm --interleave -otemplate\stm32f1xx_ll_rcc.o --asm_dir=./ --list_dir=--list --depend=template\stm32f1xx_ll_rcc.d --cpu=Cortex-M3 --apcs=interwork -O0 --diag_suppress=9931 -I../Inc -I../Drivers/STM32F1xx_HAL_Driver/Inc -I../Drivers/STM32F1xx_HAL_Driver/Inc/Legacy -I../Middlewares/Third_Party/FatFs/src -I../Drivers/CMSIS/Device/ST/STM32F1xx/Include -I../Drivers/CMSIS/Include -I.\RTE\_Template -ID:\Keil_v5\Pack\ARM\CMSIS\5.7.0\CMSIS\Core\Include -ID:\Keil_v5\Pack\Keil\STM32F1xx_DFP\2.3.0\Device\Include -D__MICROLIB -D__UVISION_VERSION=533 -D_RTE_ -DSTM32F10X_MD -D_RTE_ -DUSE_FULL_LL_DRIVER -DUSE_HAL_DRIVER -DSTM32F103xB --signed_chars --omf_browse=template\stm32f1xx_ll_rcc.crf ../Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_ll_rcc.c]
                          THUMB

                          AREA ||i.LL_RCC_DeInit||, CODE, READONLY, ALIGN=2

                  LL_RCC_DeInit PROC
;;;102      */
;;;103    ErrorStatus LL_RCC_DeInit(void)
000000  b510              PUSH     {r4,lr}
;;;104    {
;;;105      /* Set HSION bit */
;;;106      LL_RCC_HSI_Enable();
000002  bf00              NOP      
000004  4823              LDR      r0,|L1.148|
000006  6800              LDR      r0,[r0,#0]
000008  f0400001          ORR      r0,r0,#1
00000c  4921              LDR      r1,|L1.148|
00000e  6008              STR      r0,[r1,#0]
000010  bf00              NOP      
;;;107    
;;;108      /* Wait for HSI READY bit */
;;;109      while (LL_RCC_HSI_IsReady() != 1U)
000012  bf00              NOP      
                  |L1.20|
000014  bf00              NOP      
000016  481f              LDR      r0,|L1.148|
000018  6800              LDR      r0,[r0,#0]
00001a  f3c00040          UBFX     r0,r0,#1,#1
00001e  2800              CMP      r0,#0
000020  d0f8              BEQ      |L1.20|
;;;110      {}
;;;111    
;;;112      /* Configure HSI as system clock source */
;;;113      LL_RCC_SetSysClkSource(LL_RCC_SYS_CLKSOURCE_HSI);
000022  2000              MOVS     r0,#0
000024  491b              LDR      r1,|L1.148|
000026  6849              LDR      r1,[r1,#4]
000028  f0210103          BIC      r1,r1,#3
00002c  4301              ORRS     r1,r1,r0
00002e  4a19              LDR      r2,|L1.148|
000030  6051              STR      r1,[r2,#4]
000032  bf00              NOP      
;;;114    
;;;115      /* Wait till clock switch is ready */
;;;116      while (LL_RCC_GetSysClkSource() != LL_RCC_SYS_CLKSOURCE_STATUS_HSI)
000034  bf00              NOP      
                  |L1.54|
000036  bf00              NOP      
000038  4816              LDR      r0,|L1.148|
00003a  6840              LDR      r0,[r0,#4]
00003c  f000000c          AND      r0,r0,#0xc
000040  2800              CMP      r0,#0
000042  d1f8              BNE      |L1.54|
;;;117      {}
;;;118    
;;;119      /* Reset PLLON bit */
;;;120      CLEAR_BIT(RCC->CR, RCC_CR_PLLON);
000044  4813              LDR      r0,|L1.148|
000046  6800              LDR      r0,[r0,#0]
000048  f0207080          BIC      r0,r0,#0x1000000
00004c  4911              LDR      r1,|L1.148|
00004e  6008              STR      r0,[r1,#0]
;;;121    
;;;122      /* Wait for PLL READY bit to be reset */
;;;123      while (LL_RCC_PLL_IsReady() != 0U)
000050  bf00              NOP      
                  |L1.82|
000052  f7fffffe          BL       LL_RCC_PLL_IsReady
000056  2800              CMP      r0,#0
000058  d1fb              BNE      |L1.82|
;;;124      {}
;;;125    
;;;126      /* Reset CFGR register */
;;;127      LL_RCC_WriteReg(CFGR, 0x00000000U);
00005a  490e              LDR      r1,|L1.148|
00005c  6048              STR      r0,[r1,#4]
;;;128    
;;;129      /* Reset HSEON, HSEBYP & CSSON bits */
;;;130      CLEAR_BIT(RCC->CR, (RCC_CR_CSSON | RCC_CR_HSEON | RCC_CR_HSEBYP));
00005e  4608              MOV      r0,r1
000060  6800              LDR      r0,[r0,#0]
000062  f4202050          BIC      r0,r0,#0xd0000
000066  6008              STR      r0,[r1,#0]
;;;131    
;;;132    #if defined(RCC_CR_PLL2ON)
;;;133      /* Reset PLL2ON bit */
;;;134      CLEAR_BIT(RCC->CR, RCC_CR_PLL2ON);
;;;135    #endif /* RCC_CR_PLL2ON */
;;;136    
;;;137    #if defined(RCC_CR_PLL3ON)
;;;138      /* Reset PLL3ON bit */
;;;139      CLEAR_BIT(RCC->CR, RCC_CR_PLL3ON);
;;;140    #endif /* RCC_CR_PLL3ON */
;;;141    
;;;142      /* Set HSITRIM bits to the reset value */
;;;143      LL_RCC_HSI_SetCalibTrimming(0x10U);
000068  2010              MOVS     r0,#0x10
00006a  6809              LDR      r1,[r1,#0]
00006c  f02101f8          BIC      r1,r1,#0xf8
000070  ea4101c0          ORR      r1,r1,r0,LSL #3
000074  4a07              LDR      r2,|L1.148|
000076  6011              STR      r1,[r2,#0]
000078  bf00              NOP      
;;;144    
;;;145    #if defined(RCC_CFGR2_PREDIV1)
;;;146      /* Reset CFGR2 register */
;;;147      LL_RCC_WriteReg(CFGR2, 0x00000000U);
;;;148    #endif /* RCC_CFGR2_PREDIV1 */
;;;149    
;;;150      /* Disable all interrupts */
;;;151      LL_RCC_WriteReg(CIR, 0x00000000U);
00007a  2000              MOVS     r0,#0
00007c  4611              MOV      r1,r2
00007e  6088              STR      r0,[r1,#8]
;;;152    
;;;153      /* Clear reset flags */
;;;154      LL_RCC_ClearResetFlags();
000080  bf00              NOP      
000082  4608              MOV      r0,r1
000084  6a40              LDR      r0,[r0,#0x24]
000086  f0407080          ORR      r0,r0,#0x1000000
00008a  6248              STR      r0,[r1,#0x24]
00008c  bf00              NOP      
;;;155    
;;;156      return SUCCESS;
00008e  2000              MOVS     r0,#0
;;;157    }
000090  bd10              POP      {r4,pc}
;;;158    
                          ENDP

000092  0000              DCW      0x0000
                  |L1.148|
                          DCD      0x40021000

                          AREA ||i.LL_RCC_GetADCClockFreq||, CODE, READONLY, ALIGN=2

                  LL_RCC_GetADCClockFreq PROC
;;;305      */
;;;306    uint32_t LL_RCC_GetADCClockFreq(uint32_t ADCxSource)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;307    {
000004  4604              MOV      r4,r0
;;;308      uint32_t adc_prescaler = 0U;
000006  2500              MOVS     r5,#0
;;;309      uint32_t adc_frequency = 0U;
000008  2600              MOVS     r6,#0
;;;310    
;;;311      /* Check parameter */
;;;312      assert_param(IS_LL_RCC_ADC_CLKSOURCE(ADCxSource));
00000a  f5b44f40          CMP      r4,#0xc000
00000e  d100              BNE      |L2.18|
000010  e004              B        |L2.28|
                  |L2.18|
000012  f44f719c          MOV      r1,#0x138
000016  a00f              ADR      r0,|L2.84|
000018  f7fffffe          BL       assert_failed
                  |L2.28|
;;;313    
;;;314      /* Get ADC prescaler */
;;;315      adc_prescaler = LL_RCC_GetADCClockSource(ADCxSource);
00001c  bf00              NOP      
00001e  481b              LDR      r0,|L2.140|
000020  6840              LDR      r0,[r0,#4]
000022  4020              ANDS     r0,r0,r4
000024  4605              MOV      r5,r0
;;;316    
;;;317      /* ADC frequency = PCLK2 frequency / ADC prescaler (2, 4, 6 or 8) */
;;;318      adc_frequency = RCC_GetPCLK2ClockFreq(RCC_GetHCLKClockFreq(RCC_GetSystemClockFreq()))
000026  f7fffffe          BL       RCC_GetSystemClockFreq
00002a  4680              MOV      r8,r0
00002c  f7fffffe          BL       RCC_GetHCLKClockFreq
000030  4607              MOV      r7,r0
000032  f7fffffe          BL       RCC_GetPCLK2ClockFreq
000036  4601              MOV      r1,r0
000038  fa94f2a4          RBIT     r2,r4
00003c  fab2f282          CLZ      r2,r2
000040  fa25f002          LSR      r0,r5,r2
000044  1c40              ADDS     r0,r0,#1
000046  0040              LSLS     r0,r0,#1
000048  fbb1f6f0          UDIV     r6,r1,r0
;;;319                      / (((adc_prescaler >> POSITION_VAL(ADCxSource)) + 1U) * 2U);
;;;320    
;;;321      return adc_frequency;
00004c  4630              MOV      r0,r6
;;;322    }
00004e  e8bd81f0          POP      {r4-r8,pc}
;;;323    
                          ENDP

000052  0000              DCW      0x0000
                  |L2.84|
000054  2e2e2f44          DCB      "../Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_ll_rcc.c",0
000058  72697665
00005c  72732f53
000060  544d3332
000064  46317878
000068  5f48414c
00006c  5f447269
000070  7665722f
000074  5372632f
000078  73746d33
00007c  32663178
000080  785f6c6c
000084  5f726363
000088  2e6300  
00008b  00                DCB      0
                  |L2.140|
                          DCD      0x40021000

                          AREA ||i.LL_RCC_GetSystemClocksFreq||, CODE, READONLY, ALIGN=1

                  LL_RCC_GetSystemClocksFreq PROC
;;;189      */
;;;190    void LL_RCC_GetSystemClocksFreq(LL_RCC_ClocksTypeDef *RCC_Clocks)
000000  b510              PUSH     {r4,lr}
;;;191    {
000002  4604              MOV      r4,r0
;;;192      /* Get SYSCLK frequency */
;;;193      RCC_Clocks->SYSCLK_Frequency = RCC_GetSystemClockFreq();
000004  f7fffffe          BL       RCC_GetSystemClockFreq
000008  6020              STR      r0,[r4,#0]
;;;194    
;;;195      /* HCLK clock frequency */
;;;196      RCC_Clocks->HCLK_Frequency   = RCC_GetHCLKClockFreq(RCC_Clocks->SYSCLK_Frequency);
00000a  6820              LDR      r0,[r4,#0]
00000c  f7fffffe          BL       RCC_GetHCLKClockFreq
000010  6060              STR      r0,[r4,#4]
;;;197    
;;;198      /* PCLK1 clock frequency */
;;;199      RCC_Clocks->PCLK1_Frequency  = RCC_GetPCLK1ClockFreq(RCC_Clocks->HCLK_Frequency);
000012  6860              LDR      r0,[r4,#4]
000014  f7fffffe          BL       RCC_GetPCLK1ClockFreq
000018  60a0              STR      r0,[r4,#8]
;;;200    
;;;201      /* PCLK2 clock frequency */
;;;202      RCC_Clocks->PCLK2_Frequency  = RCC_GetPCLK2ClockFreq(RCC_Clocks->HCLK_Frequency);
00001a  6860              LDR      r0,[r4,#4]
00001c  f7fffffe          BL       RCC_GetPCLK2ClockFreq
000020  60e0              STR      r0,[r4,#0xc]
;;;203    }
000022  bd10              POP      {r4,pc}
;;;204    
                          ENDP


                          AREA ||i.LL_RCC_GetUSBClockFreq||, CODE, READONLY, ALIGN=2

                  LL_RCC_GetUSBClockFreq PROC
;;;246      */
;;;247    uint32_t LL_RCC_GetUSBClockFreq(uint32_t USBxSource)
000000  b570              PUSH     {r4-r6,lr}
;;;248    {
000002  4604              MOV      r4,r0
;;;249      uint32_t usb_frequency = LL_RCC_PERIPH_FREQUENCY_NO;
000004  2500              MOVS     r5,#0
;;;250    
;;;251      /* Check parameter */
;;;252      assert_param(IS_LL_RCC_USB_CLKSOURCE(USBxSource));
000006  f5b40f80          CMP      r4,#0x400000
00000a  d100              BNE      |L4.14|
00000c  e003              B        |L4.22|
                  |L4.14|
00000e  21fc              MOVS     r1,#0xfc
000010  a00f              ADR      r0,|L4.80|
000012  f7fffffe          BL       assert_failed
                  |L4.22|
;;;253    
;;;254      /* USBCLK clock frequency */
;;;255      switch (LL_RCC_GetUSBClockSource(USBxSource))
000016  bf00              NOP      
000018  481b              LDR      r0,|L4.136|
00001a  6840              LDR      r0,[r0,#4]
00001c  4020              ANDS     r0,r0,r4
00001e  b150              CBZ      r0,|L4.54|
000020  f5b00f80          CMP      r0,#0x400000
000024  d106              BNE      |L4.52|
;;;256      {
;;;257    #if defined(RCC_CFGR_USBPRE)
;;;258        case LL_RCC_USB_CLKSOURCE_PLL:        /* PLL clock used as USB clock source */
;;;259          if (LL_RCC_PLL_IsReady())
000026  f7fffffe          BL       LL_RCC_PLL_IsReady
00002a  b110              CBZ      r0,|L4.50|
;;;260          {
;;;261            usb_frequency = RCC_PLL_GetFreqDomain_SYS();
00002c  f7fffffe          BL       RCC_PLL_GetFreqDomain_SYS
000030  4605              MOV      r5,r0
                  |L4.50|
;;;262          }
;;;263          break;
000032  e009              B        |L4.72|
                  |L4.52|
;;;264    
;;;265        case LL_RCC_USB_CLKSOURCE_PLL_DIV_1_5:        /* PLL clock divided by 1.5 used as USB clock source */
000034  bf00              NOP      
                  |L4.54|
;;;266        default:
;;;267          if (LL_RCC_PLL_IsReady())
000036  f7fffffe          BL       LL_RCC_PLL_IsReady
00003a  b120              CBZ      r0,|L4.70|
;;;268          {
;;;269            usb_frequency = (RCC_PLL_GetFreqDomain_SYS() * 3U) / 2U;
00003c  f7fffffe          BL       RCC_PLL_GetFreqDomain_SYS
000040  eb000040          ADD      r0,r0,r0,LSL #1
000044  0845              LSRS     r5,r0,#1
                  |L4.70|
;;;270          }
;;;271          break;
000046  bf00              NOP      
                  |L4.72|
000048  bf00              NOP                            ;263
;;;272    #endif /* RCC_CFGR_USBPRE */
;;;273    #if defined(RCC_CFGR_OTGFSPRE)
;;;274        /* USBCLK = PLLVCO/2
;;;275                  = (2 x PLLCLK) / 2
;;;276                  = PLLCLK */
;;;277        case LL_RCC_USB_CLKSOURCE_PLL_DIV_2:        /* PLL clock used as USB clock source */
;;;278          if (LL_RCC_PLL_IsReady())
;;;279          {
;;;280            usb_frequency = RCC_PLL_GetFreqDomain_SYS();
;;;281          }
;;;282          break;
;;;283    
;;;284        /* USBCLK = PLLVCO/3
;;;285                  = (2 x PLLCLK) / 3 */
;;;286        case LL_RCC_USB_CLKSOURCE_PLL_DIV_3:        /* PLL clock divided by 3 used as USB clock source */
;;;287        default:
;;;288          if (LL_RCC_PLL_IsReady())
;;;289          {
;;;290            usb_frequency = (RCC_PLL_GetFreqDomain_SYS() * 2U) / 3U;
;;;291          }
;;;292          break;
;;;293    #endif /* RCC_CFGR_OTGFSPRE */
;;;294      }
;;;295    
;;;296      return usb_frequency;
00004a  4628              MOV      r0,r5
;;;297    }
00004c  bd70              POP      {r4-r6,pc}
;;;298    #endif /* USB */
                          ENDP

00004e  0000              DCW      0x0000
                  |L4.80|
000050  2e2e2f44          DCB      "../Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_ll_rcc.c",0
000054  72697665
000058  72732f53
00005c  544d3332
000060  46317878
000064  5f48414c
000068  5f447269
00006c  7665722f
000070  5372632f
000074  73746d33
000078  32663178
00007c  785f6c6c
000080  5f726363
000084  2e6300  
000087  00                DCB      0
                  |L4.136|
                          DCD      0x40021000

                          AREA ||i.LL_RCC_PLL_IsReady||, CODE, READONLY, ALIGN=2

                  LL_RCC_PLL_IsReady PROC
;;;1407     */
;;;1408   __STATIC_INLINE uint32_t LL_RCC_PLL_IsReady(void)
000000  4802              LDR      r0,|L5.12|
;;;1409   {
;;;1410     return (READ_BIT(RCC->CR, RCC_CR_PLLRDY) == (RCC_CR_PLLRDY));
000002  6800              LDR      r0,[r0,#0]
000004  f3c06040          UBFX     r0,r0,#25,#1
;;;1411   }
000008  4770              BX       lr
;;;1412   
                          ENDP

00000a  0000              DCW      0x0000
                  |L5.12|
                          DCD      0x40021000

                          AREA ||i.RCC_GetHCLKClockFreq||, CODE, READONLY, ALIGN=2

                  RCC_GetHCLKClockFreq PROC
;;;371      */
;;;372    uint32_t RCC_GetHCLKClockFreq(uint32_t SYSCLK_Frequency)
000000  4601              MOV      r1,r0
;;;373    {
;;;374      /* HCLK clock frequency */
;;;375      return __LL_RCC_CALC_HCLK_FREQ(SYSCLK_Frequency, LL_RCC_GetAHBPrescaler());
000002  bf00              NOP      
000004  4804              LDR      r0,|L6.24|
000006  6840              LDR      r0,[r0,#4]
000008  f00000f0          AND      r0,r0,#0xf0
00000c  0900              LSRS     r0,r0,#4
00000e  4a03              LDR      r2,|L6.28|
000010  5c12              LDRB     r2,[r2,r0]
000012  fa21f002          LSR      r0,r1,r2
;;;376    }
000016  4770              BX       lr
;;;377    
                          ENDP

                  |L6.24|
                          DCD      0x40021000
                  |L6.28|
                          DCD      AHBPrescTable

                          AREA ||i.RCC_GetPCLK1ClockFreq||, CODE, READONLY, ALIGN=2

                  RCC_GetPCLK1ClockFreq PROC
;;;382      */
;;;383    uint32_t RCC_GetPCLK1ClockFreq(uint32_t HCLK_Frequency)
000000  4601              MOV      r1,r0
;;;384    {
;;;385      /* PCLK1 clock frequency */
;;;386      return __LL_RCC_CALC_PCLK1_FREQ(HCLK_Frequency, LL_RCC_GetAPB1Prescaler());
000002  bf00              NOP      
000004  4805              LDR      r0,|L7.28|
000006  6840              LDR      r0,[r0,#4]
000008  f40060e0          AND      r0,r0,#0x700
00000c  4a04              LDR      r2,|L7.32|
00000e  eb022010          ADD      r0,r2,r0,LSR #8
000012  7802              LDRB     r2,[r0,#0]
000014  fa21f002          LSR      r0,r1,r2
;;;387    }
000018  4770              BX       lr
;;;388    
                          ENDP

00001a  0000              DCW      0x0000
                  |L7.28|
                          DCD      0x40021000
                  |L7.32|
                          DCD      APBPrescTable

                          AREA ||i.RCC_GetPCLK2ClockFreq||, CODE, READONLY, ALIGN=2

                  RCC_GetPCLK2ClockFreq PROC
;;;393      */
;;;394    uint32_t RCC_GetPCLK2ClockFreq(uint32_t HCLK_Frequency)
000000  4601              MOV      r1,r0
;;;395    {
;;;396      /* PCLK2 clock frequency */
;;;397      return __LL_RCC_CALC_PCLK2_FREQ(HCLK_Frequency, LL_RCC_GetAPB2Prescaler());
000002  bf00              NOP      
000004  4805              LDR      r0,|L8.28|
000006  6840              LDR      r0,[r0,#4]
000008  f4005060          AND      r0,r0,#0x3800
00000c  4a04              LDR      r2,|L8.32|
00000e  eb0220d0          ADD      r0,r2,r0,LSR #11
000012  7802              LDRB     r2,[r0,#0]
000014  fa21f002          LSR      r0,r1,r2
;;;398    }
000018  4770              BX       lr
;;;399    
                          ENDP

00001a  0000              DCW      0x0000
                  |L8.28|
                          DCD      0x40021000
                  |L8.32|
                          DCD      APBPrescTable

                          AREA ||i.RCC_GetSystemClockFreq||, CODE, READONLY, ALIGN=2

                  RCC_GetSystemClockFreq PROC
;;;339      */
;;;340    uint32_t RCC_GetSystemClockFreq(void)
000000  b510              PUSH     {r4,lr}
;;;341    {
;;;342      uint32_t frequency = 0U;
000002  2400              MOVS     r4,#0
;;;343    
;;;344      /* Get SYSCLK source -------------------------------------------------------*/
;;;345      switch (LL_RCC_GetSysClkSource())
000004  bf00              NOP      
000006  480b              LDR      r0,|L9.52|
000008  6840              LDR      r0,[r0,#4]
00000a  f000000c          AND      r0,r0,#0xc
00000e  b120              CBZ      r0,|L9.26|
000010  2804              CMP      r0,#4
000012  d004              BEQ      |L9.30|
000014  2808              CMP      r0,#8
000016  d108              BNE      |L9.42|
000018  e003              B        |L9.34|
                  |L9.26|
;;;346      {
;;;347        case LL_RCC_SYS_CLKSOURCE_STATUS_HSI:  /* HSI used as system clock  source */
;;;348          frequency = HSI_VALUE;
00001a  4c07              LDR      r4,|L9.56|
;;;349          break;
00001c  e007              B        |L9.46|
                  |L9.30|
;;;350    
;;;351        case LL_RCC_SYS_CLKSOURCE_STATUS_HSE:  /* HSE used as system clock  source */
;;;352          frequency = HSE_VALUE;
00001e  4c06              LDR      r4,|L9.56|
;;;353          break;
000020  e005              B        |L9.46|
                  |L9.34|
;;;354    
;;;355        case LL_RCC_SYS_CLKSOURCE_STATUS_PLL:  /* PLL used as system clock  source */
;;;356          frequency = RCC_PLL_GetFreqDomain_SYS();
000022  f7fffffe          BL       RCC_PLL_GetFreqDomain_SYS
000026  4604              MOV      r4,r0
;;;357          break;
000028  e001              B        |L9.46|
                  |L9.42|
;;;358    
;;;359        default:
;;;360          frequency = HSI_VALUE;
00002a  4c03              LDR      r4,|L9.56|
;;;361          break;
00002c  bf00              NOP      
                  |L9.46|
00002e  bf00              NOP                            ;349
;;;362      }
;;;363    
;;;364      return frequency;
000030  4620              MOV      r0,r4
;;;365    }
000032  bd10              POP      {r4,pc}
;;;366    
                          ENDP

                  |L9.52|
                          DCD      0x40021000
                  |L9.56|
                          DCD      0x007a1200

                          AREA ||i.RCC_PLL_GetFreqDomain_SYS||, CODE, READONLY, ALIGN=2

                  RCC_PLL_GetFreqDomain_SYS PROC
;;;403      */
;;;404    uint32_t RCC_PLL_GetFreqDomain_SYS(void)
000000  2100              MOVS     r1,#0
;;;405    {
;;;406      uint32_t pllinputfreq = 0U, pllsource = 0U;
000002  2200              MOVS     r2,#0
;;;407    
;;;408      /* PLL_VCO = (HSE_VALUE, HSI_VALUE or PLL2 / PLL Predivider) * PLL Multiplicator */
;;;409    
;;;410      /* Get PLL source */
;;;411      pllsource = LL_RCC_PLL_GetMainSource();
000004  bf00              NOP      
000006  4811              LDR      r0,|L10.76|
000008  6840              LDR      r0,[r0,#4]
00000a  f4003080          AND      r0,r0,#0x10000
00000e  4602              MOV      r2,r0
;;;412    
;;;413      switch (pllsource)
000010  b11a              CBZ      r2,|L10.26|
000012  f5b23f80          CMP      r2,#0x10000
000016  d10c              BNE      |L10.50|
000018  e001              B        |L10.30|
                  |L10.26|
;;;414      {
;;;415        case LL_RCC_PLLSOURCE_HSI_DIV_2: /* HSI used as PLL clock source */
;;;416          pllinputfreq = HSI_VALUE / 2U;
00001a  490d              LDR      r1,|L10.80|
;;;417          break;
00001c  e00b              B        |L10.54|
                  |L10.30|
;;;418    
;;;419        case LL_RCC_PLLSOURCE_HSE:       /* HSE used as PLL clock source */
;;;420          pllinputfreq = HSE_VALUE / (LL_RCC_PLL_GetPrediv() + 1U);
00001e  bf00              NOP      
000020  480a              LDR      r0,|L10.76|
000022  6840              LDR      r0,[r0,#4]
000024  f3c04040          UBFX     r0,r0,#17,#1
000028  1c40              ADDS     r0,r0,#1
00002a  4b0a              LDR      r3,|L10.84|
00002c  fbb3f1f0          UDIV     r1,r3,r0
;;;421          break;
000030  e001              B        |L10.54|
                  |L10.50|
;;;422    
;;;423    #if defined(RCC_PLL2_SUPPORT)
;;;424        case LL_RCC_PLLSOURCE_PLL2:       /* PLL2 used as PLL clock source */
;;;425          pllinputfreq = RCC_PLL2_GetFreqClockFreq() / (LL_RCC_PLL_GetPrediv() + 1U);
;;;426          break;
;;;427    #endif /* RCC_PLL2_SUPPORT */
;;;428    
;;;429        default:
;;;430          pllinputfreq = HSI_VALUE / 2U;
000032  4907              LDR      r1,|L10.80|
;;;431          break;
000034  bf00              NOP      
                  |L10.54|
000036  bf00              NOP                            ;417
;;;432      }
;;;433      return __LL_RCC_CALC_PLLCLK_FREQ(pllinputfreq, LL_RCC_PLL_GetMultiplicator());
000038  bf00              NOP      
00003a  4804              LDR      r0,|L10.76|
00003c  6840              LDR      r0,[r0,#4]
00003e  f4001070          AND      r0,r0,#0x3c0000
000042  2302              MOVS     r3,#2
000044  eb034090          ADD      r0,r3,r0,LSR #18
000048  4348              MULS     r0,r1,r0
;;;434    }
00004a  4770              BX       lr
;;;435    
                          ENDP

                  |L10.76|
                          DCD      0x40021000
                  |L10.80|
                          DCD      0x003d0900
                  |L10.84|
                          DCD      0x007a1200

;*** Start embedded assembler ***

#line 1 "../Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_ll_rcc.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___18_stm32f1xx_ll_rcc_c_5c04acb7____REV16|
#line 463 "../Drivers/CMSIS/Include/cmsis_armcc.h"
|__asm___18_stm32f1xx_ll_rcc_c_5c04acb7____REV16| PROC
#line 464

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___18_stm32f1xx_ll_rcc_c_5c04acb7____REVSH|
#line 478
|__asm___18_stm32f1xx_ll_rcc_c_5c04acb7____REVSH| PROC
#line 479

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___18_stm32f1xx_ll_rcc_c_5c04acb7____RRX|
#line 665
|__asm___18_stm32f1xx_ll_rcc_c_5c04acb7____RRX| PROC
#line 666

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
