; generated by Component: ARM Compiler 5.06 update 7 (build 960) Tool: ArmCC [4d365d]
; commandline ArmCC [--c99 --split_sections --debug -c --asm --interleave -otemplate\stm32f1xx_hal_spi.o --asm_dir=./ --list_dir=--list --depend=template\stm32f1xx_hal_spi.d --cpu=Cortex-M3 --apcs=interwork -O0 --diag_suppress=9931 -I../Inc -I../Drivers/STM32F1xx_HAL_Driver/Inc -I../Drivers/STM32F1xx_HAL_Driver/Inc/Legacy -I../Middlewares/Third_Party/FatFs/src -I../Drivers/CMSIS/Device/ST/STM32F1xx/Include -I../Drivers/CMSIS/Include -I.\RTE\_Template -ID:\Keil_v5\Pack\ARM\CMSIS\5.7.0\CMSIS\Core\Include -ID:\Keil_v5\Pack\Keil\STM32F1xx_DFP\2.3.0\Device\Include -D__MICROLIB -D__UVISION_VERSION=533 -D_RTE_ -DSTM32F10X_MD -D_RTE_ -DUSE_FULL_LL_DRIVER -DUSE_HAL_DRIVER -DSTM32F103xB --signed_chars --omf_browse=template\stm32f1xx_hal_spi.crf ../Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_spi.c]
                          THUMB

                          AREA ||i.HAL_SPI_Abort||, CODE, READONLY, ALIGN=2

                  HAL_SPI_Abort PROC
;;;2032     */
;;;2033   HAL_StatusTypeDef HAL_SPI_Abort(SPI_HandleTypeDef *hspi)
000000  b53e              PUSH     {r1-r5,lr}
;;;2034   {
000002  4604              MOV      r4,r0
;;;2035     HAL_StatusTypeDef errorcode;
;;;2036     __IO uint32_t count;
;;;2037     __IO uint32_t resetcount;
;;;2038   
;;;2039     /* Initialized local variable  */
;;;2040     errorcode = HAL_OK;
000004  2500              MOVS     r5,#0
;;;2041     resetcount = SPI_DEFAULT_TIMEOUT * (SystemCoreClock / 24U / 1000U);
000006  4852              LDR      r0,|L1.336|
000008  6800              LDR      r0,[r0,#0]  ; SystemCoreClock
00000a  2118              MOVS     r1,#0x18
00000c  fbb0f0f1          UDIV     r0,r0,r1
000010  f44f717a          MOV      r1,#0x3e8
000014  fbb0f0f1          UDIV     r0,r0,r1
000018  2164              MOVS     r1,#0x64
00001a  4348              MULS     r0,r1,r0
00001c  9001              STR      r0,[sp,#4]
;;;2042     count = resetcount;
00001e  9801              LDR      r0,[sp,#4]
000020  9002              STR      r0,[sp,#8]
;;;2043   
;;;2044     /* Clear ERRIE interrupt to avoid error interrupts generation during Abort procedure */
;;;2045     CLEAR_BIT(hspi->Instance->CR2, SPI_CR2_ERRIE);
000022  6820              LDR      r0,[r4,#0]
000024  6840              LDR      r0,[r0,#4]
000026  f0200020          BIC      r0,r0,#0x20
00002a  6821              LDR      r1,[r4,#0]
00002c  6048              STR      r0,[r1,#4]
;;;2046   
;;;2047     /* Disable TXEIE, RXNEIE and ERRIE(mode fault event, overrun error, TI frame error) interrupts */
;;;2048     if (HAL_IS_BIT_SET(hspi->Instance->CR2, SPI_CR2_TXEIE))
00002e  6820              LDR      r0,[r4,#0]
000030  6840              LDR      r0,[r0,#4]
000032  f0000080          AND      r0,r0,#0x80
000036  b198              CBZ      r0,|L1.96|
;;;2049     {
;;;2050       hspi->TxISR = SPI_AbortTx_ISR;
000038  4846              LDR      r0,|L1.340|
00003a  6460              STR      r0,[r4,#0x44]
;;;2051       /* Wait HAL_SPI_STATE_ABORT state */
;;;2052       do
00003c  bf00              NOP      
                  |L1.62|
;;;2053       {
;;;2054         if (count == 0U)
00003e  9802              LDR      r0,[sp,#8]
000040  b920              CBNZ     r0,|L1.76|
;;;2055         {
;;;2056           SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_ABORT);
000042  6d60              LDR      r0,[r4,#0x54]
000044  f0400040          ORR      r0,r0,#0x40
000048  6560              STR      r0,[r4,#0x54]
;;;2057           break;
00004a  e006              B        |L1.90|
                  |L1.76|
;;;2058         }
;;;2059         count--;
00004c  9802              LDR      r0,[sp,#8]
00004e  1e40              SUBS     r0,r0,#1
000050  9002              STR      r0,[sp,#8]
;;;2060       } while (hspi->State != HAL_SPI_STATE_ABORT);
000052  f8940051          LDRB     r0,[r4,#0x51]
000056  2807              CMP      r0,#7
000058  d1f1              BNE      |L1.62|
                  |L1.90|
00005a  bf00              NOP                            ;2057
;;;2061       /* Reset Timeout Counter */
;;;2062       count = resetcount;
00005c  9801              LDR      r0,[sp,#4]
00005e  9002              STR      r0,[sp,#8]
                  |L1.96|
;;;2063     }
;;;2064   
;;;2065     if (HAL_IS_BIT_SET(hspi->Instance->CR2, SPI_CR2_RXNEIE))
000060  6820              LDR      r0,[r4,#0]
000062  6840              LDR      r0,[r0,#4]
000064  f0000040          AND      r0,r0,#0x40
000068  b198              CBZ      r0,|L1.146|
;;;2066     {
;;;2067       hspi->RxISR = SPI_AbortRx_ISR;
00006a  483b              LDR      r0,|L1.344|
00006c  6420              STR      r0,[r4,#0x40]
;;;2068       /* Wait HAL_SPI_STATE_ABORT state */
;;;2069       do
00006e  bf00              NOP      
                  |L1.112|
;;;2070       {
;;;2071         if (count == 0U)
000070  9802              LDR      r0,[sp,#8]
000072  b920              CBNZ     r0,|L1.126|
;;;2072         {
;;;2073           SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_ABORT);
000074  6d60              LDR      r0,[r4,#0x54]
000076  f0400040          ORR      r0,r0,#0x40
00007a  6560              STR      r0,[r4,#0x54]
;;;2074           break;
00007c  e006              B        |L1.140|
                  |L1.126|
;;;2075         }
;;;2076         count--;
00007e  9802              LDR      r0,[sp,#8]
000080  1e40              SUBS     r0,r0,#1
000082  9002              STR      r0,[sp,#8]
;;;2077       } while (hspi->State != HAL_SPI_STATE_ABORT);
000084  f8940051          LDRB     r0,[r4,#0x51]
000088  2807              CMP      r0,#7
00008a  d1f1              BNE      |L1.112|
                  |L1.140|
00008c  bf00              NOP                            ;2074
;;;2078       /* Reset Timeout Counter */
;;;2079       count = resetcount;
00008e  9801              LDR      r0,[sp,#4]
000090  9002              STR      r0,[sp,#8]
                  |L1.146|
;;;2080     }
;;;2081   
;;;2082     /* Disable the SPI DMA Tx request if enabled */
;;;2083     if (HAL_IS_BIT_SET(hspi->Instance->CR2, SPI_CR2_TXDMAEN))
000092  6820              LDR      r0,[r4,#0]
000094  6840              LDR      r0,[r0,#4]
000096  f0000002          AND      r0,r0,#2
00009a  b310              CBZ      r0,|L1.226|
;;;2084     {
;;;2085       /* Abort the SPI DMA Tx Stream/Channel : use blocking DMA Abort API (no callback) */
;;;2086       if (hspi->hdmatx != NULL)
00009c  6ca0              LDR      r0,[r4,#0x48]
00009e  b300              CBZ      r0,|L1.226|
;;;2087       {
;;;2088         /* Set the SPI DMA Abort callback :
;;;2089         will lead to call HAL_SPI_AbortCpltCallback() at end of DMA abort procedure */
;;;2090         hspi->hdmatx->XferAbortCallback = NULL;
0000a0  2000              MOVS     r0,#0
0000a2  6ca1              LDR      r1,[r4,#0x48]
0000a4  6348              STR      r0,[r1,#0x34]
;;;2091   
;;;2092         /* Abort DMA Tx Handle linked to SPI Peripheral */
;;;2093         if (HAL_DMA_Abort(hspi->hdmatx) != HAL_OK)
0000a6  6ca0              LDR      r0,[r4,#0x48]
0000a8  f7fffffe          BL       HAL_DMA_Abort
0000ac  b108              CBZ      r0,|L1.178|
;;;2094         {
;;;2095           hspi->ErrorCode = HAL_SPI_ERROR_ABORT;
0000ae  2040              MOVS     r0,#0x40
0000b0  6560              STR      r0,[r4,#0x54]
                  |L1.178|
;;;2096         }
;;;2097   
;;;2098         /* Disable Tx DMA Request */
;;;2099         CLEAR_BIT(hspi->Instance->CR2, (SPI_CR2_TXDMAEN));
0000b2  6820              LDR      r0,[r4,#0]
0000b4  6840              LDR      r0,[r0,#4]
0000b6  f0200002          BIC      r0,r0,#2
0000ba  6821              LDR      r1,[r4,#0]
0000bc  6048              STR      r0,[r1,#4]
;;;2100   
;;;2101         /* Wait until TXE flag is set */
;;;2102         do
0000be  bf00              NOP      
                  |L1.192|
;;;2103         {
;;;2104           if (count == 0U)
0000c0  9802              LDR      r0,[sp,#8]
0000c2  b920              CBNZ     r0,|L1.206|
;;;2105           {
;;;2106             SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_ABORT);
0000c4  6d60              LDR      r0,[r4,#0x54]
0000c6  f0400040          ORR      r0,r0,#0x40
0000ca  6560              STR      r0,[r4,#0x54]
;;;2107             break;
0000cc  e008              B        |L1.224|
                  |L1.206|
;;;2108           }
;;;2109           count--;
0000ce  9802              LDR      r0,[sp,#8]
0000d0  1e40              SUBS     r0,r0,#1
0000d2  9002              STR      r0,[sp,#8]
;;;2110         } while ((hspi->Instance->SR & SPI_FLAG_TXE) == RESET);
0000d4  6820              LDR      r0,[r4,#0]
0000d6  6880              LDR      r0,[r0,#8]
0000d8  f0000002          AND      r0,r0,#2
0000dc  2800              CMP      r0,#0
0000de  d0ef              BEQ      |L1.192|
                  |L1.224|
0000e0  bf00              NOP                            ;2107
                  |L1.226|
;;;2111       }
;;;2112     }
;;;2113   
;;;2114     /* Disable the SPI DMA Rx request if enabled */
;;;2115     if (HAL_IS_BIT_SET(hspi->Instance->CR2, SPI_CR2_RXDMAEN))
0000e2  6820              LDR      r0,[r4,#0]
0000e4  6840              LDR      r0,[r0,#4]
0000e6  f0000001          AND      r0,r0,#1
0000ea  b1b0              CBZ      r0,|L1.282|
;;;2116     {
;;;2117       /* Abort the SPI DMA Rx Stream/Channel : use blocking DMA Abort API (no callback) */
;;;2118       if (hspi->hdmarx != NULL)
0000ec  6ce0              LDR      r0,[r4,#0x4c]
0000ee  b1a0              CBZ      r0,|L1.282|
;;;2119       {
;;;2120         /* Set the SPI DMA Abort callback :
;;;2121         will lead to call HAL_SPI_AbortCpltCallback() at end of DMA abort procedure */
;;;2122         hspi->hdmarx->XferAbortCallback = NULL;
0000f0  2000              MOVS     r0,#0
0000f2  6ce1              LDR      r1,[r4,#0x4c]
0000f4  6348              STR      r0,[r1,#0x34]
;;;2123   
;;;2124         /* Abort DMA Rx Handle linked to SPI Peripheral */
;;;2125         if (HAL_DMA_Abort(hspi->hdmarx) != HAL_OK)
0000f6  6ce0              LDR      r0,[r4,#0x4c]
0000f8  f7fffffe          BL       HAL_DMA_Abort
0000fc  b108              CBZ      r0,|L1.258|
;;;2126         {
;;;2127           hspi->ErrorCode = HAL_SPI_ERROR_ABORT;
0000fe  2040              MOVS     r0,#0x40
000100  6560              STR      r0,[r4,#0x54]
                  |L1.258|
;;;2128         }
;;;2129   
;;;2130         /* Disable peripheral */
;;;2131         __HAL_SPI_DISABLE(hspi);
000102  6820              LDR      r0,[r4,#0]
000104  6800              LDR      r0,[r0,#0]
000106  f0200040          BIC      r0,r0,#0x40
00010a  6821              LDR      r1,[r4,#0]
00010c  6008              STR      r0,[r1,#0]
;;;2132   
;;;2133         /* Disable Rx DMA Request */
;;;2134         CLEAR_BIT(hspi->Instance->CR2, (SPI_CR2_RXDMAEN));
00010e  6820              LDR      r0,[r4,#0]
000110  6840              LDR      r0,[r0,#4]
000112  f0200001          BIC      r0,r0,#1
000116  6821              LDR      r1,[r4,#0]
000118  6048              STR      r0,[r1,#4]
                  |L1.282|
;;;2135       }
;;;2136     }
;;;2137     /* Reset Tx and Rx transfer counters */
;;;2138     hspi->RxXferCount = 0U;
00011a  2000              MOVS     r0,#0
00011c  87e0              STRH     r0,[r4,#0x3e]
;;;2139     hspi->TxXferCount = 0U;
00011e  86e0              STRH     r0,[r4,#0x36]
;;;2140   
;;;2141     /* Check error during Abort procedure */
;;;2142     if (hspi->ErrorCode == HAL_SPI_ERROR_ABORT)
000120  6d60              LDR      r0,[r4,#0x54]
000122  2840              CMP      r0,#0x40
000124  d101              BNE      |L1.298|
;;;2143     {
;;;2144       /* return HAL_Error in case of error during Abort procedure */
;;;2145       errorcode = HAL_ERROR;
000126  2501              MOVS     r5,#1
000128  e001              B        |L1.302|
                  |L1.298|
;;;2146     }
;;;2147     else
;;;2148     {
;;;2149       /* Reset errorCode */
;;;2150       hspi->ErrorCode = HAL_SPI_ERROR_NONE;
00012a  2000              MOVS     r0,#0
00012c  6560              STR      r0,[r4,#0x54]
                  |L1.302|
;;;2151     }
;;;2152   
;;;2153     /* Clear the Error flags in the SR register */
;;;2154     __HAL_SPI_CLEAR_OVRFLAG(hspi);
00012e  bf00              NOP      
000130  2000              MOVS     r0,#0
000132  9000              STR      r0,[sp,#0]
000134  6820              LDR      r0,[r4,#0]
000136  68c0              LDR      r0,[r0,#0xc]
000138  9000              STR      r0,[sp,#0]
00013a  6820              LDR      r0,[r4,#0]
00013c  6880              LDR      r0,[r0,#8]
00013e  9000              STR      r0,[sp,#0]
000140  bf00              NOP      
000142  bf00              NOP      
;;;2155   
;;;2156     /* Restore hspi->state to ready */
;;;2157     hspi->State = HAL_SPI_STATE_READY;
000144  2001              MOVS     r0,#1
000146  f8840051          STRB     r0,[r4,#0x51]
;;;2158   
;;;2159     return errorcode;
00014a  4628              MOV      r0,r5
;;;2160   }
00014c  bd3e              POP      {r1-r5,pc}
;;;2161   
                          ENDP

00014e  0000              DCW      0x0000
                  |L1.336|
                          DCD      SystemCoreClock
                  |L1.340|
                          DCD      SPI_AbortTx_ISR
                  |L1.344|
                          DCD      SPI_AbortRx_ISR

                          AREA ||i.HAL_SPI_AbortCpltCallback||, CODE, READONLY, ALIGN=1

                  HAL_SPI_AbortCpltCallback PROC
;;;2632     */
;;;2633   __weak void HAL_SPI_AbortCpltCallback(SPI_HandleTypeDef *hspi)
000000  4770              BX       lr
;;;2634   {
;;;2635     /* Prevent unused argument(s) compilation warning */
;;;2636     UNUSED(hspi);
;;;2637   
;;;2638     /* NOTE : This function should not be modified, when the callback is needed,
;;;2639               the HAL_SPI_AbortCpltCallback can be implemented in the user file.
;;;2640      */
;;;2641   }
;;;2642   
                          ENDP


                          AREA ||i.HAL_SPI_Abort_IT||, CODE, READONLY, ALIGN=2

                  HAL_SPI_Abort_IT PROC
;;;2176     */
;;;2177   HAL_StatusTypeDef HAL_SPI_Abort_IT(SPI_HandleTypeDef *hspi)
000000  b5fe              PUSH     {r1-r7,lr}
;;;2178   {
000002  4604              MOV      r4,r0
;;;2179     HAL_StatusTypeDef errorcode;
;;;2180     uint32_t abortcplt ;
;;;2181     __IO uint32_t count;
;;;2182     __IO uint32_t resetcount;
;;;2183   
;;;2184     /* Initialized local variable  */
;;;2185     errorcode = HAL_OK;
000004  2500              MOVS     r5,#0
;;;2186     abortcplt = 1U;
000006  2601              MOVS     r6,#1
;;;2187     resetcount = SPI_DEFAULT_TIMEOUT * (SystemCoreClock / 24U / 1000U);
000008  4852              LDR      r0,|L3.340|
00000a  6800              LDR      r0,[r0,#0]  ; SystemCoreClock
00000c  2118              MOVS     r1,#0x18
00000e  fbb0f0f1          UDIV     r0,r0,r1
000012  f44f717a          MOV      r1,#0x3e8
000016  fbb0f0f1          UDIV     r0,r0,r1
00001a  2164              MOVS     r1,#0x64
00001c  4348              MULS     r0,r1,r0
00001e  9001              STR      r0,[sp,#4]
;;;2188     count = resetcount;
000020  9801              LDR      r0,[sp,#4]
000022  9002              STR      r0,[sp,#8]
;;;2189   
;;;2190     /* Clear ERRIE interrupt to avoid error interrupts generation during Abort procedure */
;;;2191     CLEAR_BIT(hspi->Instance->CR2, SPI_CR2_ERRIE);
000024  6820              LDR      r0,[r4,#0]
000026  6840              LDR      r0,[r0,#4]
000028  f0200020          BIC      r0,r0,#0x20
00002c  6821              LDR      r1,[r4,#0]
00002e  6048              STR      r0,[r1,#4]
;;;2192   
;;;2193     /* Change Rx and Tx Irq Handler to Disable TXEIE, RXNEIE and ERRIE interrupts */
;;;2194     if (HAL_IS_BIT_SET(hspi->Instance->CR2, SPI_CR2_TXEIE))
000030  6820              LDR      r0,[r4,#0]
000032  6840              LDR      r0,[r0,#4]
000034  f0000080          AND      r0,r0,#0x80
000038  b198              CBZ      r0,|L3.98|
;;;2195     {
;;;2196       hspi->TxISR = SPI_AbortTx_ISR;
00003a  4847              LDR      r0,|L3.344|
00003c  6460              STR      r0,[r4,#0x44]
;;;2197       /* Wait HAL_SPI_STATE_ABORT state */
;;;2198       do
00003e  bf00              NOP      
                  |L3.64|
;;;2199       {
;;;2200         if (count == 0U)
000040  9802              LDR      r0,[sp,#8]
000042  b920              CBNZ     r0,|L3.78|
;;;2201         {
;;;2202           SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_ABORT);
000044  6d60              LDR      r0,[r4,#0x54]
000046  f0400040          ORR      r0,r0,#0x40
00004a  6560              STR      r0,[r4,#0x54]
;;;2203           break;
00004c  e006              B        |L3.92|
                  |L3.78|
;;;2204         }
;;;2205         count--;
00004e  9802              LDR      r0,[sp,#8]
000050  1e40              SUBS     r0,r0,#1
000052  9002              STR      r0,[sp,#8]
;;;2206       } while (hspi->State != HAL_SPI_STATE_ABORT);
000054  f8940051          LDRB     r0,[r4,#0x51]
000058  2807              CMP      r0,#7
00005a  d1f1              BNE      |L3.64|
                  |L3.92|
00005c  bf00              NOP                            ;2203
;;;2207       /* Reset Timeout Counter */
;;;2208       count = resetcount;
00005e  9801              LDR      r0,[sp,#4]
000060  9002              STR      r0,[sp,#8]
                  |L3.98|
;;;2209     }
;;;2210   
;;;2211     if (HAL_IS_BIT_SET(hspi->Instance->CR2, SPI_CR2_RXNEIE))
000062  6820              LDR      r0,[r4,#0]
000064  6840              LDR      r0,[r0,#4]
000066  f0000040          AND      r0,r0,#0x40
00006a  b198              CBZ      r0,|L3.148|
;;;2212     {
;;;2213       hspi->RxISR = SPI_AbortRx_ISR;
00006c  483b              LDR      r0,|L3.348|
00006e  6420              STR      r0,[r4,#0x40]
;;;2214       /* Wait HAL_SPI_STATE_ABORT state */
;;;2215       do
000070  bf00              NOP      
                  |L3.114|
;;;2216       {
;;;2217         if (count == 0U)
000072  9802              LDR      r0,[sp,#8]
000074  b920              CBNZ     r0,|L3.128|
;;;2218         {
;;;2219           SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_ABORT);
000076  6d60              LDR      r0,[r4,#0x54]
000078  f0400040          ORR      r0,r0,#0x40
00007c  6560              STR      r0,[r4,#0x54]
;;;2220           break;
00007e  e006              B        |L3.142|
                  |L3.128|
;;;2221         }
;;;2222         count--;
000080  9802              LDR      r0,[sp,#8]
000082  1e40              SUBS     r0,r0,#1
000084  9002              STR      r0,[sp,#8]
;;;2223       } while (hspi->State != HAL_SPI_STATE_ABORT);
000086  f8940051          LDRB     r0,[r4,#0x51]
00008a  2807              CMP      r0,#7
00008c  d1f1              BNE      |L3.114|
                  |L3.142|
00008e  bf00              NOP                            ;2220
;;;2224       /* Reset Timeout Counter */
;;;2225       count = resetcount;
000090  9801              LDR      r0,[sp,#4]
000092  9002              STR      r0,[sp,#8]
                  |L3.148|
;;;2226     }
;;;2227   
;;;2228     /* If DMA Tx and/or DMA Rx Handles are associated to SPI Handle, DMA Abort complete callbacks should be initialised
;;;2229        before any call to DMA Abort functions */
;;;2230     /* DMA Tx Handle is valid */
;;;2231     if (hspi->hdmatx != NULL)
000094  6ca0              LDR      r0,[r4,#0x48]
000096  b158              CBZ      r0,|L3.176|
;;;2232     {
;;;2233       /* Set DMA Abort Complete callback if UART DMA Tx request if enabled.
;;;2234          Otherwise, set it to NULL */
;;;2235       if (HAL_IS_BIT_SET(hspi->Instance->CR2, SPI_CR2_TXDMAEN))
000098  6820              LDR      r0,[r4,#0]
00009a  6840              LDR      r0,[r0,#4]
00009c  f0000002          AND      r0,r0,#2
0000a0  b118              CBZ      r0,|L3.170|
;;;2236       {
;;;2237         hspi->hdmatx->XferAbortCallback = SPI_DMATxAbortCallback;
0000a2  482f              LDR      r0,|L3.352|
0000a4  6ca1              LDR      r1,[r4,#0x48]
0000a6  6348              STR      r0,[r1,#0x34]
0000a8  e002              B        |L3.176|
                  |L3.170|
;;;2238       }
;;;2239       else
;;;2240       {
;;;2241         hspi->hdmatx->XferAbortCallback = NULL;
0000aa  2000              MOVS     r0,#0
0000ac  6ca1              LDR      r1,[r4,#0x48]
0000ae  6348              STR      r0,[r1,#0x34]
                  |L3.176|
;;;2242       }
;;;2243     }
;;;2244     /* DMA Rx Handle is valid */
;;;2245     if (hspi->hdmarx != NULL)
0000b0  6ce0              LDR      r0,[r4,#0x4c]
0000b2  b158              CBZ      r0,|L3.204|
;;;2246     {
;;;2247       /* Set DMA Abort Complete callback if UART DMA Rx request if enabled.
;;;2248          Otherwise, set it to NULL */
;;;2249       if (HAL_IS_BIT_SET(hspi->Instance->CR2, SPI_CR2_RXDMAEN))
0000b4  6820              LDR      r0,[r4,#0]
0000b6  6840              LDR      r0,[r0,#4]
0000b8  f0000001          AND      r0,r0,#1
0000bc  b118              CBZ      r0,|L3.198|
;;;2250       {
;;;2251         hspi->hdmarx->XferAbortCallback = SPI_DMARxAbortCallback;
0000be  4829              LDR      r0,|L3.356|
0000c0  6ce1              LDR      r1,[r4,#0x4c]
0000c2  6348              STR      r0,[r1,#0x34]
0000c4  e002              B        |L3.204|
                  |L3.198|
;;;2252       }
;;;2253       else
;;;2254       {
;;;2255         hspi->hdmarx->XferAbortCallback = NULL;
0000c6  2000              MOVS     r0,#0
0000c8  6ce1              LDR      r1,[r4,#0x4c]
0000ca  6348              STR      r0,[r1,#0x34]
                  |L3.204|
;;;2256       }
;;;2257     }
;;;2258   
;;;2259     /* Disable the SPI DMA Tx request if enabled */
;;;2260     if (HAL_IS_BIT_SET(hspi->Instance->CR2, SPI_CR2_TXDMAEN))
0000cc  6820              LDR      r0,[r4,#0]
0000ce  6840              LDR      r0,[r0,#4]
0000d0  f0000002          AND      r0,r0,#2
0000d4  b160              CBZ      r0,|L3.240|
;;;2261     {
;;;2262       /* Abort the SPI DMA Tx Stream/Channel */
;;;2263       if (hspi->hdmatx != NULL)
0000d6  6ca0              LDR      r0,[r4,#0x48]
0000d8  b150              CBZ      r0,|L3.240|
;;;2264       {
;;;2265         /* Abort DMA Tx Handle linked to SPI Peripheral */
;;;2266         if (HAL_DMA_Abort_IT(hspi->hdmatx) != HAL_OK)
0000da  6ca0              LDR      r0,[r4,#0x48]
0000dc  f7fffffe          BL       HAL_DMA_Abort_IT
0000e0  b128              CBZ      r0,|L3.238|
;;;2267         {
;;;2268           hspi->hdmatx->XferAbortCallback = NULL;
0000e2  2000              MOVS     r0,#0
0000e4  6ca1              LDR      r1,[r4,#0x48]
0000e6  6348              STR      r0,[r1,#0x34]
;;;2269           hspi->ErrorCode = HAL_SPI_ERROR_ABORT;
0000e8  2040              MOVS     r0,#0x40
0000ea  6560              STR      r0,[r4,#0x54]
0000ec  e000              B        |L3.240|
                  |L3.238|
;;;2270         }
;;;2271         else
;;;2272         {
;;;2273           abortcplt = 0U;
0000ee  2600              MOVS     r6,#0
                  |L3.240|
;;;2274         }
;;;2275       }
;;;2276     }
;;;2277     /* Disable the SPI DMA Rx request if enabled */
;;;2278     if (HAL_IS_BIT_SET(hspi->Instance->CR2, SPI_CR2_RXDMAEN))
0000f0  6820              LDR      r0,[r4,#0]
0000f2  6840              LDR      r0,[r0,#4]
0000f4  f0000001          AND      r0,r0,#1
0000f8  b160              CBZ      r0,|L3.276|
;;;2279     {
;;;2280       /* Abort the SPI DMA Rx Stream/Channel */
;;;2281       if (hspi->hdmarx != NULL)
0000fa  6ce0              LDR      r0,[r4,#0x4c]
0000fc  b150              CBZ      r0,|L3.276|
;;;2282       {
;;;2283         /* Abort DMA Rx Handle linked to SPI Peripheral */
;;;2284         if (HAL_DMA_Abort_IT(hspi->hdmarx) !=  HAL_OK)
0000fe  6ce0              LDR      r0,[r4,#0x4c]
000100  f7fffffe          BL       HAL_DMA_Abort_IT
000104  b128              CBZ      r0,|L3.274|
;;;2285         {
;;;2286           hspi->hdmarx->XferAbortCallback = NULL;
000106  2000              MOVS     r0,#0
000108  6ce1              LDR      r1,[r4,#0x4c]
00010a  6348              STR      r0,[r1,#0x34]
;;;2287           hspi->ErrorCode = HAL_SPI_ERROR_ABORT;
00010c  2040              MOVS     r0,#0x40
00010e  6560              STR      r0,[r4,#0x54]
000110  e000              B        |L3.276|
                  |L3.274|
;;;2288         }
;;;2289         else
;;;2290         {
;;;2291           abortcplt = 0U;
000112  2600              MOVS     r6,#0
                  |L3.276|
;;;2292         }
;;;2293       }
;;;2294     }
;;;2295   
;;;2296     if (abortcplt == 1U)
000114  2e01              CMP      r6,#1
000116  d11a              BNE      |L3.334|
;;;2297     {
;;;2298       /* Reset Tx and Rx transfer counters */
;;;2299       hspi->RxXferCount = 0U;
000118  2000              MOVS     r0,#0
00011a  87e0              STRH     r0,[r4,#0x3e]
;;;2300       hspi->TxXferCount = 0U;
00011c  86e0              STRH     r0,[r4,#0x36]
;;;2301   
;;;2302       /* Check error during Abort procedure */
;;;2303       if (hspi->ErrorCode == HAL_SPI_ERROR_ABORT)
00011e  6d60              LDR      r0,[r4,#0x54]
000120  2840              CMP      r0,#0x40
000122  d101              BNE      |L3.296|
;;;2304       {
;;;2305         /* return HAL_Error in case of error during Abort procedure */
;;;2306         errorcode = HAL_ERROR;
000124  2501              MOVS     r5,#1
000126  e001              B        |L3.300|
                  |L3.296|
;;;2307       }
;;;2308       else
;;;2309       {
;;;2310         /* Reset errorCode */
;;;2311         hspi->ErrorCode = HAL_SPI_ERROR_NONE;
000128  2000              MOVS     r0,#0
00012a  6560              STR      r0,[r4,#0x54]
                  |L3.300|
;;;2312       }
;;;2313   
;;;2314       /* Clear the Error flags in the SR register */
;;;2315       __HAL_SPI_CLEAR_OVRFLAG(hspi);
00012c  bf00              NOP      
00012e  2000              MOVS     r0,#0
000130  9000              STR      r0,[sp,#0]
000132  6820              LDR      r0,[r4,#0]
000134  68c0              LDR      r0,[r0,#0xc]
000136  9000              STR      r0,[sp,#0]
000138  6820              LDR      r0,[r4,#0]
00013a  6880              LDR      r0,[r0,#8]
00013c  9000              STR      r0,[sp,#0]
00013e  bf00              NOP      
000140  bf00              NOP      
;;;2316   
;;;2317       /* Restore hspi->State to Ready */
;;;2318       hspi->State = HAL_SPI_STATE_READY;
000142  2001              MOVS     r0,#1
000144  f8840051          STRB     r0,[r4,#0x51]
;;;2319   
;;;2320       /* As no DMA to be aborted, call directly user Abort complete callback */
;;;2321   #if (USE_HAL_SPI_REGISTER_CALLBACKS == 1U)
;;;2322       hspi->AbortCpltCallback(hspi);
;;;2323   #else
;;;2324       HAL_SPI_AbortCpltCallback(hspi);
000148  4620              MOV      r0,r4
00014a  f7fffffe          BL       HAL_SPI_AbortCpltCallback
                  |L3.334|
;;;2325   #endif /* USE_HAL_SPI_REGISTER_CALLBACKS */
;;;2326     }
;;;2327   
;;;2328     return errorcode;
00014e  4628              MOV      r0,r5
;;;2329   }
000150  bdfe              POP      {r1-r7,pc}
;;;2330   
                          ENDP

000152  0000              DCW      0x0000
                  |L3.340|
                          DCD      SystemCoreClock
                  |L3.344|
                          DCD      SPI_AbortTx_ISR
                  |L3.348|
                          DCD      SPI_AbortRx_ISR
                  |L3.352|
                          DCD      SPI_DMATxAbortCallback
                  |L3.356|
                          DCD      SPI_DMARxAbortCallback

                          AREA ||i.HAL_SPI_DMAPause||, CODE, READONLY, ALIGN=1

                  HAL_SPI_DMAPause PROC
;;;2336     */
;;;2337   HAL_StatusTypeDef HAL_SPI_DMAPause(SPI_HandleTypeDef *hspi)
000000  4601              MOV      r1,r0
;;;2338   {
;;;2339     /* Process Locked */
;;;2340     __HAL_LOCK(hspi);
000002  bf00              NOP      
000004  f8910050          LDRB     r0,[r1,#0x50]
000008  2801              CMP      r0,#1
00000a  d101              BNE      |L4.16|
00000c  2002              MOVS     r0,#2
                  |L4.14|
;;;2341   
;;;2342     /* Disable the SPI DMA Tx & Rx requests */
;;;2343     CLEAR_BIT(hspi->Instance->CR2, SPI_CR2_TXDMAEN | SPI_CR2_RXDMAEN);
;;;2344   
;;;2345     /* Process Unlocked */
;;;2346     __HAL_UNLOCK(hspi);
;;;2347   
;;;2348     return HAL_OK;
;;;2349   }
00000e  4770              BX       lr
                  |L4.16|
000010  2001              MOVS     r0,#1                 ;2340
000012  f8810050          STRB     r0,[r1,#0x50]         ;2340
000016  bf00              NOP                            ;2340
000018  6808              LDR      r0,[r1,#0]            ;2343
00001a  6840              LDR      r0,[r0,#4]            ;2343
00001c  f0200003          BIC      r0,r0,#3              ;2343
000020  680a              LDR      r2,[r1,#0]            ;2343
000022  6050              STR      r0,[r2,#4]            ;2343
000024  bf00              NOP                            ;2346
000026  2000              MOVS     r0,#0                 ;2346
000028  f8810050          STRB     r0,[r1,#0x50]         ;2346
00002c  bf00              NOP                            ;2346
00002e  bf00              NOP                            ;2348
000030  e7ed              B        |L4.14|
;;;2350   
                          ENDP


                          AREA ||i.HAL_SPI_DMAResume||, CODE, READONLY, ALIGN=1

                  HAL_SPI_DMAResume PROC
;;;2356     */
;;;2357   HAL_StatusTypeDef HAL_SPI_DMAResume(SPI_HandleTypeDef *hspi)
000000  4601              MOV      r1,r0
;;;2358   {
;;;2359     /* Process Locked */
;;;2360     __HAL_LOCK(hspi);
000002  bf00              NOP      
000004  f8910050          LDRB     r0,[r1,#0x50]
000008  2801              CMP      r0,#1
00000a  d101              BNE      |L5.16|
00000c  2002              MOVS     r0,#2
                  |L5.14|
;;;2361   
;;;2362     /* Enable the SPI DMA Tx & Rx requests */
;;;2363     SET_BIT(hspi->Instance->CR2, SPI_CR2_TXDMAEN | SPI_CR2_RXDMAEN);
;;;2364   
;;;2365     /* Process Unlocked */
;;;2366     __HAL_UNLOCK(hspi);
;;;2367   
;;;2368     return HAL_OK;
;;;2369   }
00000e  4770              BX       lr
                  |L5.16|
000010  2001              MOVS     r0,#1                 ;2360
000012  f8810050          STRB     r0,[r1,#0x50]         ;2360
000016  bf00              NOP                            ;2360
000018  6808              LDR      r0,[r1,#0]            ;2363
00001a  6840              LDR      r0,[r0,#4]            ;2363
00001c  f0400003          ORR      r0,r0,#3              ;2363
000020  680a              LDR      r2,[r1,#0]            ;2363
000022  6050              STR      r0,[r2,#4]            ;2363
000024  bf00              NOP                            ;2366
000026  2000              MOVS     r0,#0                 ;2366
000028  f8810050          STRB     r0,[r1,#0x50]         ;2366
00002c  bf00              NOP                            ;2366
00002e  bf00              NOP                            ;2368
000030  e7ed              B        |L5.14|
;;;2370   
                          ENDP


                          AREA ||i.HAL_SPI_DMAStop||, CODE, READONLY, ALIGN=1

                  HAL_SPI_DMAStop PROC
;;;2376     */
;;;2377   HAL_StatusTypeDef HAL_SPI_DMAStop(SPI_HandleTypeDef *hspi)
000000  b570              PUSH     {r4-r6,lr}
;;;2378   {
000002  4604              MOV      r4,r0
;;;2379     HAL_StatusTypeDef errorcode = HAL_OK;
000004  2500              MOVS     r5,#0
;;;2380     /* The Lock is not implemented on this API to allow the user application
;;;2381        to call the HAL SPI API under callbacks HAL_SPI_TxCpltCallback() or HAL_SPI_RxCpltCallback() or HAL_SPI_TxRxCpltCallback():
;;;2382        when calling HAL_DMA_Abort() API the DMA TX/RX Transfer complete interrupt is generated
;;;2383        and the correspond call back is executed HAL_SPI_TxCpltCallback() or HAL_SPI_RxCpltCallback() or HAL_SPI_TxRxCpltCallback()
;;;2384        */
;;;2385   
;;;2386     /* Abort the SPI DMA tx Stream/Channel  */
;;;2387     if (hspi->hdmatx != NULL)
000006  6ca0              LDR      r0,[r4,#0x48]
000008  b140              CBZ      r0,|L6.28|
;;;2388     {
;;;2389       if (HAL_OK != HAL_DMA_Abort(hspi->hdmatx))
00000a  6ca0              LDR      r0,[r4,#0x48]
00000c  f7fffffe          BL       HAL_DMA_Abort
000010  b120              CBZ      r0,|L6.28|
;;;2390       {
;;;2391         SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_DMA);
000012  6d60              LDR      r0,[r4,#0x54]
000014  f0400010          ORR      r0,r0,#0x10
000018  6560              STR      r0,[r4,#0x54]
;;;2392         errorcode = HAL_ERROR;
00001a  2501              MOVS     r5,#1
                  |L6.28|
;;;2393       }
;;;2394     }
;;;2395     /* Abort the SPI DMA rx Stream/Channel  */
;;;2396     if (hspi->hdmarx != NULL)
00001c  6ce0              LDR      r0,[r4,#0x4c]
00001e  b140              CBZ      r0,|L6.50|
;;;2397     {
;;;2398       if (HAL_OK != HAL_DMA_Abort(hspi->hdmarx))
000020  6ce0              LDR      r0,[r4,#0x4c]
000022  f7fffffe          BL       HAL_DMA_Abort
000026  b120              CBZ      r0,|L6.50|
;;;2399       {
;;;2400         SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_DMA);
000028  6d60              LDR      r0,[r4,#0x54]
00002a  f0400010          ORR      r0,r0,#0x10
00002e  6560              STR      r0,[r4,#0x54]
;;;2401         errorcode = HAL_ERROR;
000030  2501              MOVS     r5,#1
                  |L6.50|
;;;2402       }
;;;2403     }
;;;2404   
;;;2405     /* Disable the SPI DMA Tx & Rx requests */
;;;2406     CLEAR_BIT(hspi->Instance->CR2, SPI_CR2_TXDMAEN | SPI_CR2_RXDMAEN);
000032  6820              LDR      r0,[r4,#0]
000034  6840              LDR      r0,[r0,#4]
000036  f0200003          BIC      r0,r0,#3
00003a  6821              LDR      r1,[r4,#0]
00003c  6048              STR      r0,[r1,#4]
;;;2407     hspi->State = HAL_SPI_STATE_READY;
00003e  2001              MOVS     r0,#1
000040  f8840051          STRB     r0,[r4,#0x51]
;;;2408     return errorcode;
000044  4628              MOV      r0,r5
;;;2409   }
000046  bd70              POP      {r4-r6,pc}
;;;2410   
                          ENDP


                          AREA ||i.HAL_SPI_DeInit||, CODE, READONLY, ALIGN=2

                  HAL_SPI_DeInit PROC
;;;462      */
;;;463    HAL_StatusTypeDef HAL_SPI_DeInit(SPI_HandleTypeDef *hspi)
000000  b510              PUSH     {r4,lr}
;;;464    {
000002  4604              MOV      r4,r0
;;;465      /* Check the SPI handle allocation */
;;;466      if (hspi == NULL)
000004  b90c              CBNZ     r4,|L7.10|
;;;467      {
;;;468        return HAL_ERROR;
000006  2001              MOVS     r0,#1
                  |L7.8|
;;;469      }
;;;470    
;;;471      /* Check SPI Instance parameter */
;;;472      assert_param(IS_SPI_ALL_INSTANCE(hspi->Instance));
;;;473    
;;;474      hspi->State = HAL_SPI_STATE_BUSY;
;;;475    
;;;476      /* Disable the SPI Peripheral Clock */
;;;477      __HAL_SPI_DISABLE(hspi);
;;;478    
;;;479    #if (USE_HAL_SPI_REGISTER_CALLBACKS == 1U)
;;;480      if (hspi->MspDeInitCallback == NULL)
;;;481      {
;;;482        hspi->MspDeInitCallback = HAL_SPI_MspDeInit; /* Legacy weak MspDeInit  */
;;;483      }
;;;484    
;;;485      /* DeInit the low level hardware: GPIO, CLOCK, NVIC... */
;;;486      hspi->MspDeInitCallback(hspi);
;;;487    #else
;;;488      /* DeInit the low level hardware: GPIO, CLOCK, NVIC... */
;;;489      HAL_SPI_MspDeInit(hspi);
;;;490    #endif /* USE_HAL_SPI_REGISTER_CALLBACKS */
;;;491    
;;;492      hspi->ErrorCode = HAL_SPI_ERROR_NONE;
;;;493      hspi->State = HAL_SPI_STATE_RESET;
;;;494    
;;;495      /* Release Lock */
;;;496      __HAL_UNLOCK(hspi);
;;;497    
;;;498      return HAL_OK;
;;;499    }
000008  bd10              POP      {r4,pc}
                  |L7.10|
00000a  4912              LDR      r1,|L7.84|
00000c  6820              LDR      r0,[r4,#0]            ;472
00000e  4288              CMP      r0,r1                 ;472
000010  d003              BEQ      |L7.26|
000012  4911              LDR      r1,|L7.88|
000014  6820              LDR      r0,[r4,#0]            ;472
000016  4288              CMP      r0,r1                 ;472
000018  d100              BNE      |L7.28|
                  |L7.26|
00001a  e004              B        |L7.38|
                  |L7.28|
00001c  f44f71ec          MOV      r1,#0x1d8             ;472
000020  a00e              ADR      r0,|L7.92|
000022  f7fffffe          BL       assert_failed
                  |L7.38|
000026  2002              MOVS     r0,#2                 ;474
000028  f8840051          STRB     r0,[r4,#0x51]         ;474
00002c  6820              LDR      r0,[r4,#0]            ;477
00002e  6800              LDR      r0,[r0,#0]            ;477
000030  f0200040          BIC      r0,r0,#0x40           ;477
000034  6821              LDR      r1,[r4,#0]            ;477
000036  6008              STR      r0,[r1,#0]            ;477
000038  4620              MOV      r0,r4                 ;489
00003a  f7fffffe          BL       HAL_SPI_MspDeInit
00003e  2000              MOVS     r0,#0                 ;492
000040  6560              STR      r0,[r4,#0x54]         ;492
000042  f8840051          STRB     r0,[r4,#0x51]         ;493
000046  bf00              NOP                            ;496
000048  f8840050          STRB     r0,[r4,#0x50]         ;496
00004c  bf00              NOP                            ;496
00004e  bf00              NOP                            ;498
000050  e7da              B        |L7.8|
;;;500    
                          ENDP

000052  0000              DCW      0x0000
                  |L7.84|
                          DCD      0x40013000
                  |L7.88|
                          DCD      0x40003800
                  |L7.92|
00005c  2e2e2f44          DCB      "../Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_spi.c"
000060  72697665
000064  72732f53
000068  544d3332
00006c  46317878
000070  5f48414c
000074  5f447269
000078  7665722f
00007c  5372632f
000080  73746d33
000084  32663178
000088  785f6861
00008c  6c5f7370
000090  692e63  
000093  00                DCB      0

                          AREA ||i.HAL_SPI_ErrorCallback||, CODE, READONLY, ALIGN=1

                  HAL_SPI_ErrorCallback PROC
;;;2614     */
;;;2615   __weak void HAL_SPI_ErrorCallback(SPI_HandleTypeDef *hspi)
000000  4770              BX       lr
;;;2616   {
;;;2617     /* Prevent unused argument(s) compilation warning */
;;;2618     UNUSED(hspi);
;;;2619   
;;;2620     /* NOTE : This function should not be modified, when the callback is needed,
;;;2621               the HAL_SPI_ErrorCallback should be implemented in the user file
;;;2622      */
;;;2623     /* NOTE : The ErrorCode parameter in the hspi handle is updated by the SPI processes
;;;2624               and user can use HAL_SPI_GetError() API to check the latest error occurred
;;;2625      */
;;;2626   }
;;;2627   
                          ENDP


                          AREA ||i.HAL_SPI_GetError||, CODE, READONLY, ALIGN=1

                  HAL_SPI_GetError PROC
;;;2679     */
;;;2680   uint32_t HAL_SPI_GetError(SPI_HandleTypeDef *hspi)
000000  4601              MOV      r1,r0
;;;2681   {
;;;2682     /* Return SPI ErrorCode */
;;;2683     return hspi->ErrorCode;
000002  6d48              LDR      r0,[r1,#0x54]
;;;2684   }
000004  4770              BX       lr
;;;2685   
                          ENDP


                          AREA ||i.HAL_SPI_GetState||, CODE, READONLY, ALIGN=1

                  HAL_SPI_GetState PROC
;;;2667     */
;;;2668   HAL_SPI_StateTypeDef HAL_SPI_GetState(SPI_HandleTypeDef *hspi)
000000  4601              MOV      r1,r0
;;;2669   {
;;;2670     /* Return SPI handle state */
;;;2671     return hspi->State;
000002  f8910051          LDRB     r0,[r1,#0x51]
;;;2672   }
000006  4770              BX       lr
;;;2673   
                          ENDP


                          AREA ||i.HAL_SPI_IRQHandler||, CODE, READONLY, ALIGN=2

                  HAL_SPI_IRQHandler PROC
;;;2416     */
;;;2417   void HAL_SPI_IRQHandler(SPI_HandleTypeDef *hspi)
000000  b5f8              PUSH     {r3-r7,lr}
;;;2418   {
000002  4604              MOV      r4,r0
;;;2419     uint32_t itsource = hspi->Instance->CR2;
000004  6820              LDR      r0,[r4,#0]
000006  6846              LDR      r6,[r0,#4]
;;;2420     uint32_t itflag   = hspi->Instance->SR;
000008  6820              LDR      r0,[r4,#0]
00000a  6885              LDR      r5,[r0,#8]
;;;2421   
;;;2422     /* SPI in mode Receiver ----------------------------------------------------*/
;;;2423     if ((SPI_CHECK_FLAG(itflag, SPI_FLAG_OVR) == RESET) &&
00000c  f3c51080          UBFX     r0,r5,#6,#1
000010  b948              CBNZ     r0,|L11.38|
;;;2424         (SPI_CHECK_FLAG(itflag, SPI_FLAG_RXNE) != RESET) && (SPI_CHECK_IT_SOURCE(itsource, SPI_IT_RXNE) != RESET))
000012  f0050001          AND      r0,r5,#1
000016  b130              CBZ      r0,|L11.38|
000018  f3c61080          UBFX     r0,r6,#6,#1
00001c  b118              CBZ      r0,|L11.38|
;;;2425     {
;;;2426       hspi->RxISR(hspi);
00001e  4620              MOV      r0,r4
000020  6c21              LDR      r1,[r4,#0x40]
000022  4788              BLX      r1
                  |L11.36|
;;;2427       return;
;;;2428     }
;;;2429   
;;;2430     /* SPI in mode Transmitter -------------------------------------------------*/
;;;2431     if ((SPI_CHECK_FLAG(itflag, SPI_FLAG_TXE) != RESET) && (SPI_CHECK_IT_SOURCE(itsource, SPI_IT_TXE) != RESET))
;;;2432     {
;;;2433       hspi->TxISR(hspi);
;;;2434       return;
;;;2435     }
;;;2436   
;;;2437     /* SPI in Error Treatment --------------------------------------------------*/
;;;2438     if (((SPI_CHECK_FLAG(itflag, SPI_FLAG_MODF) != RESET) || (SPI_CHECK_FLAG(itflag, SPI_FLAG_OVR) != RESET))
;;;2439         && (SPI_CHECK_IT_SOURCE(itsource, SPI_IT_ERR) != RESET))
;;;2440     {
;;;2441       /* SPI Overrun error interrupt occurred ----------------------------------*/
;;;2442       if (SPI_CHECK_FLAG(itflag, SPI_FLAG_OVR) != RESET)
;;;2443       {
;;;2444         if (hspi->State != HAL_SPI_STATE_BUSY_TX)
;;;2445         {
;;;2446           SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_OVR);
;;;2447           __HAL_SPI_CLEAR_OVRFLAG(hspi);
;;;2448         }
;;;2449         else
;;;2450         {
;;;2451           __HAL_SPI_CLEAR_OVRFLAG(hspi);
;;;2452           return;
;;;2453         }
;;;2454       }
;;;2455   
;;;2456       /* SPI Mode Fault error interrupt occurred -------------------------------*/
;;;2457       if (SPI_CHECK_FLAG(itflag, SPI_FLAG_MODF) != RESET)
;;;2458       {
;;;2459         SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_MODF);
;;;2460         __HAL_SPI_CLEAR_MODFFLAG(hspi);
;;;2461       }
;;;2462   
;;;2463       /* SPI Frame error interrupt occurred ------------------------------------*/
;;;2464   
;;;2465       if (hspi->ErrorCode != HAL_SPI_ERROR_NONE)
;;;2466       {
;;;2467         /* Disable all interrupts */
;;;2468         __HAL_SPI_DISABLE_IT(hspi, SPI_IT_RXNE | SPI_IT_TXE | SPI_IT_ERR);
;;;2469   
;;;2470         hspi->State = HAL_SPI_STATE_READY;
;;;2471         /* Disable the SPI DMA requests if enabled */
;;;2472         if ((HAL_IS_BIT_SET(itsource, SPI_CR2_TXDMAEN)) || (HAL_IS_BIT_SET(itsource, SPI_CR2_RXDMAEN)))
;;;2473         {
;;;2474           CLEAR_BIT(hspi->Instance->CR2, (SPI_CR2_TXDMAEN | SPI_CR2_RXDMAEN));
;;;2475   
;;;2476           /* Abort the SPI DMA Rx channel */
;;;2477           if (hspi->hdmarx != NULL)
;;;2478           {
;;;2479             /* Set the SPI DMA Abort callback :
;;;2480             will lead to call HAL_SPI_ErrorCallback() at end of DMA abort procedure */
;;;2481             hspi->hdmarx->XferAbortCallback = SPI_DMAAbortOnError;
;;;2482             if (HAL_OK != HAL_DMA_Abort_IT(hspi->hdmarx))
;;;2483             {
;;;2484               SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_ABORT);
;;;2485             }
;;;2486           }
;;;2487           /* Abort the SPI DMA Tx channel */
;;;2488           if (hspi->hdmatx != NULL)
;;;2489           {
;;;2490             /* Set the SPI DMA Abort callback :
;;;2491             will lead to call HAL_SPI_ErrorCallback() at end of DMA abort procedure */
;;;2492             hspi->hdmatx->XferAbortCallback = SPI_DMAAbortOnError;
;;;2493             if (HAL_OK != HAL_DMA_Abort_IT(hspi->hdmatx))
;;;2494             {
;;;2495               SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_ABORT);
;;;2496             }
;;;2497           }
;;;2498         }
;;;2499         else
;;;2500         {
;;;2501           /* Call user error callback */
;;;2502   #if (USE_HAL_SPI_REGISTER_CALLBACKS == 1U)
;;;2503           hspi->ErrorCallback(hspi);
;;;2504   #else
;;;2505           HAL_SPI_ErrorCallback(hspi);
;;;2506   #endif /* USE_HAL_SPI_REGISTER_CALLBACKS */
;;;2507         }
;;;2508       }
;;;2509       return;
;;;2510     }
;;;2511   }
000024  bdf8              POP      {r3-r7,pc}
                  |L11.38|
000026  f3c50040          UBFX     r0,r5,#1,#1           ;2431
00002a  b130              CBZ      r0,|L11.58|
00002c  f3c610c0          UBFX     r0,r6,#7,#1           ;2431
000030  b118              CBZ      r0,|L11.58|
000032  4620              MOV      r0,r4                 ;2433
000034  6c61              LDR      r1,[r4,#0x44]         ;2433
000036  4788              BLX      r1                    ;2433
000038  e7f4              B        |L11.36|
                  |L11.58|
00003a  f3c51040          UBFX     r0,r5,#5,#1           ;2438
00003e  b918              CBNZ     r0,|L11.72|
000040  f3c51080          UBFX     r0,r5,#6,#1           ;2438
000044  2800              CMP      r0,#0                 ;2438
000046  d071              BEQ      |L11.300|
                  |L11.72|
000048  f3c61040          UBFX     r0,r6,#5,#1           ;2439
00004c  2800              CMP      r0,#0                 ;2439
00004e  d06d              BEQ      |L11.300|
000050  f3c51080          UBFX     r0,r5,#6,#1           ;2442
000054  b1f0              CBZ      r0,|L11.148|
000056  f8940051          LDRB     r0,[r4,#0x51]         ;2444
00005a  2803              CMP      r0,#3                 ;2444
00005c  d00e              BEQ      |L11.124|
00005e  6d60              LDR      r0,[r4,#0x54]         ;2446
000060  f0400004          ORR      r0,r0,#4              ;2446
000064  6560              STR      r0,[r4,#0x54]         ;2446
000066  bf00              NOP                            ;2447
000068  2000              MOVS     r0,#0                 ;2447
00006a  9000              STR      r0,[sp,#0]            ;2447
00006c  6820              LDR      r0,[r4,#0]            ;2447
00006e  68c0              LDR      r0,[r0,#0xc]          ;2447
000070  9000              STR      r0,[sp,#0]            ;2447
000072  6820              LDR      r0,[r4,#0]            ;2447
000074  6880              LDR      r0,[r0,#8]            ;2447
000076  9000              STR      r0,[sp,#0]            ;2447
000078  bf00              NOP                            ;2447
00007a  e00b              B        |L11.148|
                  |L11.124|
00007c  bf00              NOP                            ;2451
00007e  2000              MOVS     r0,#0                 ;2451
000080  9000              STR      r0,[sp,#0]            ;2451
000082  6820              LDR      r0,[r4,#0]            ;2451
000084  68c0              LDR      r0,[r0,#0xc]          ;2451
000086  9000              STR      r0,[sp,#0]            ;2451
000088  6820              LDR      r0,[r4,#0]            ;2451
00008a  6880              LDR      r0,[r0,#8]            ;2451
00008c  9000              STR      r0,[sp,#0]            ;2451
00008e  bf00              NOP                            ;2451
000090  bf00              NOP                            ;2451
000092  e7c7              B        |L11.36|
                  |L11.148|
000094  f3c51040          UBFX     r0,r5,#5,#1           ;2457
000098  b188              CBZ      r0,|L11.190|
00009a  6d60              LDR      r0,[r4,#0x54]         ;2459
00009c  f0400001          ORR      r0,r0,#1              ;2459
0000a0  6560              STR      r0,[r4,#0x54]         ;2459
0000a2  bf00              NOP                            ;2460
0000a4  2000              MOVS     r0,#0                 ;2460
0000a6  9000              STR      r0,[sp,#0]            ;2460
0000a8  6820              LDR      r0,[r4,#0]            ;2460
0000aa  6880              LDR      r0,[r0,#8]            ;2460
0000ac  9000              STR      r0,[sp,#0]            ;2460
0000ae  6820              LDR      r0,[r4,#0]            ;2460
0000b0  6800              LDR      r0,[r0,#0]            ;2460
0000b2  f0200040          BIC      r0,r0,#0x40           ;2460
0000b6  6821              LDR      r1,[r4,#0]            ;2460
0000b8  6008              STR      r0,[r1,#0]            ;2460
0000ba  bf00              NOP                            ;2460
0000bc  bf00              NOP                            ;2460
                  |L11.190|
0000be  6d60              LDR      r0,[r4,#0x54]         ;2465
0000c0  b370              CBZ      r0,|L11.288|
0000c2  6820              LDR      r0,[r4,#0]            ;2468
0000c4  6840              LDR      r0,[r0,#4]            ;2468
0000c6  f02000e0          BIC      r0,r0,#0xe0           ;2468
0000ca  6821              LDR      r1,[r4,#0]            ;2468
0000cc  6048              STR      r0,[r1,#4]            ;2468
0000ce  2001              MOVS     r0,#1                 ;2470
0000d0  f8840051          STRB     r0,[r4,#0x51]         ;2470
0000d4  f0060002          AND      r0,r6,#2              ;2472
0000d8  b910              CBNZ     r0,|L11.224|
0000da  f0060001          AND      r0,r6,#1              ;2472
0000de  b300              CBZ      r0,|L11.290|
                  |L11.224|
0000e0  6820              LDR      r0,[r4,#0]            ;2474
0000e2  6840              LDR      r0,[r0,#4]            ;2474
0000e4  f0200003          BIC      r0,r0,#3              ;2474
0000e8  6821              LDR      r1,[r4,#0]            ;2474
0000ea  6048              STR      r0,[r1,#4]            ;2474
0000ec  6ce0              LDR      r0,[r4,#0x4c]         ;2477
0000ee  b150              CBZ      r0,|L11.262|
0000f0  480f              LDR      r0,|L11.304|
0000f2  6ce1              LDR      r1,[r4,#0x4c]         ;2481
0000f4  6348              STR      r0,[r1,#0x34]         ;2481
0000f6  6ce0              LDR      r0,[r4,#0x4c]         ;2482
0000f8  f7fffffe          BL       HAL_DMA_Abort_IT
0000fc  b118              CBZ      r0,|L11.262|
0000fe  6d60              LDR      r0,[r4,#0x54]         ;2484
000100  f0400040          ORR      r0,r0,#0x40           ;2484
000104  6560              STR      r0,[r4,#0x54]         ;2484
                  |L11.262|
000106  6ca0              LDR      r0,[r4,#0x48]         ;2488
000108  b150              CBZ      r0,|L11.288|
00010a  4809              LDR      r0,|L11.304|
00010c  6ca1              LDR      r1,[r4,#0x48]         ;2492
00010e  6348              STR      r0,[r1,#0x34]         ;2492
000110  6ca0              LDR      r0,[r4,#0x48]         ;2493
000112  f7fffffe          BL       HAL_DMA_Abort_IT
000116  b118              CBZ      r0,|L11.288|
000118  6d60              LDR      r0,[r4,#0x54]         ;2495
00011a  f0400040          ORR      r0,r0,#0x40           ;2495
00011e  6560              STR      r0,[r4,#0x54]         ;2495
                  |L11.288|
000120  e002              B        |L11.296|
                  |L11.290|
000122  4620              MOV      r0,r4                 ;2505
000124  f7fffffe          BL       HAL_SPI_ErrorCallback
                  |L11.296|
000128  e77c              B        |L11.36|
00012a  e7ff              B        |L11.300|
                  |L11.300|
00012c  bf00              NOP      
00012e  e779              B        |L11.36|
;;;2512   
                          ENDP

                  |L11.304|
                          DCD      SPI_DMAAbortOnError

                          AREA ||i.HAL_SPI_Init||, CODE, READONLY, ALIGN=2

                  HAL_SPI_Init PROC
;;;334      */
;;;335    HAL_StatusTypeDef HAL_SPI_Init(SPI_HandleTypeDef *hspi)
000000  b510              PUSH     {r4,lr}
;;;336    {
000002  4604              MOV      r4,r0
;;;337      /* Check the SPI handle allocation */
;;;338      if (hspi == NULL)
000004  b90c              CBNZ     r4,|L12.10|
;;;339      {
;;;340        return HAL_ERROR;
000006  2001              MOVS     r0,#1
                  |L12.8|
;;;341      }
;;;342    
;;;343      /* Check the parameters */
;;;344      assert_param(IS_SPI_ALL_INSTANCE(hspi->Instance));
;;;345      assert_param(IS_SPI_MODE(hspi->Init.Mode));
;;;346      assert_param(IS_SPI_DIRECTION(hspi->Init.Direction));
;;;347      assert_param(IS_SPI_DATASIZE(hspi->Init.DataSize));
;;;348      assert_param(IS_SPI_NSS(hspi->Init.NSS));
;;;349      assert_param(IS_SPI_BAUDRATE_PRESCALER(hspi->Init.BaudRatePrescaler));
;;;350      assert_param(IS_SPI_FIRST_BIT(hspi->Init.FirstBit));
;;;351      /* TI mode is not supported on this device.
;;;352         TIMode parameter is mandatory equal to SPI_TIMODE_DISABLE */
;;;353      assert_param(IS_SPI_TIMODE(hspi->Init.TIMode));
;;;354      if (hspi->Init.TIMode == SPI_TIMODE_DISABLE)
;;;355      {
;;;356        assert_param(IS_SPI_CPOL(hspi->Init.CLKPolarity));
;;;357        assert_param(IS_SPI_CPHA(hspi->Init.CLKPhase));
;;;358    
;;;359        if (hspi->Init.Mode == SPI_MODE_MASTER)
;;;360        {
;;;361          assert_param(IS_SPI_BAUDRATE_PRESCALER(hspi->Init.BaudRatePrescaler));
;;;362        }
;;;363        else
;;;364        {
;;;365          /* Baudrate prescaler not use in Motoraola Slave mode. force to default value */
;;;366          hspi->Init.BaudRatePrescaler = SPI_BAUDRATEPRESCALER_2;
;;;367        }
;;;368      }
;;;369      else
;;;370      {
;;;371        assert_param(IS_SPI_BAUDRATE_PRESCALER(hspi->Init.BaudRatePrescaler));
;;;372    
;;;373        /* Force polarity and phase to TI protocaol requirements */
;;;374        hspi->Init.CLKPolarity = SPI_POLARITY_LOW;
;;;375        hspi->Init.CLKPhase    = SPI_PHASE_1EDGE;
;;;376      }
;;;377    #if (USE_SPI_CRC != 0U)
;;;378      assert_param(IS_SPI_CRC_CALCULATION(hspi->Init.CRCCalculation));
;;;379      if (hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
;;;380      {
;;;381        assert_param(IS_SPI_CRC_POLYNOMIAL(hspi->Init.CRCPolynomial));
;;;382      }
;;;383    #else
;;;384      hspi->Init.CRCCalculation = SPI_CRCCALCULATION_DISABLE;
;;;385    #endif /* USE_SPI_CRC */
;;;386    
;;;387      if (hspi->State == HAL_SPI_STATE_RESET)
;;;388      {
;;;389        /* Allocate lock resource and initialize it */
;;;390        hspi->Lock = HAL_UNLOCKED;
;;;391    
;;;392    #if (USE_HAL_SPI_REGISTER_CALLBACKS == 1U)
;;;393        /* Init the SPI Callback settings */
;;;394        hspi->TxCpltCallback       = HAL_SPI_TxCpltCallback;       /* Legacy weak TxCpltCallback       */
;;;395        hspi->RxCpltCallback       = HAL_SPI_RxCpltCallback;       /* Legacy weak RxCpltCallback       */
;;;396        hspi->TxRxCpltCallback     = HAL_SPI_TxRxCpltCallback;     /* Legacy weak TxRxCpltCallback     */
;;;397        hspi->TxHalfCpltCallback   = HAL_SPI_TxHalfCpltCallback;   /* Legacy weak TxHalfCpltCallback   */
;;;398        hspi->RxHalfCpltCallback   = HAL_SPI_RxHalfCpltCallback;   /* Legacy weak RxHalfCpltCallback   */
;;;399        hspi->TxRxHalfCpltCallback = HAL_SPI_TxRxHalfCpltCallback; /* Legacy weak TxRxHalfCpltCallback */
;;;400        hspi->ErrorCallback        = HAL_SPI_ErrorCallback;        /* Legacy weak ErrorCallback        */
;;;401        hspi->AbortCpltCallback    = HAL_SPI_AbortCpltCallback;    /* Legacy weak AbortCpltCallback    */
;;;402    
;;;403        if (hspi->MspInitCallback == NULL)
;;;404        {
;;;405          hspi->MspInitCallback = HAL_SPI_MspInit; /* Legacy weak MspInit  */
;;;406        }
;;;407    
;;;408        /* Init the low level hardware : GPIO, CLOCK, NVIC... */
;;;409        hspi->MspInitCallback(hspi);
;;;410    #else
;;;411        /* Init the low level hardware : GPIO, CLOCK, NVIC... */
;;;412        HAL_SPI_MspInit(hspi);
;;;413    #endif /* USE_HAL_SPI_REGISTER_CALLBACKS */
;;;414      }
;;;415    
;;;416      hspi->State = HAL_SPI_STATE_BUSY;
;;;417    
;;;418      /* Disable the selected SPI peripheral */
;;;419      __HAL_SPI_DISABLE(hspi);
;;;420    
;;;421      /*----------------------- SPIx CR1 & CR2 Configuration ---------------------*/
;;;422      /* Configure : SPI Mode, Communication Mode, Data size, Clock polarity and phase, NSS management,
;;;423      Communication speed, First bit and CRC calculation state */
;;;424      WRITE_REG(hspi->Instance->CR1, ((hspi->Init.Mode & (SPI_CR1_MSTR | SPI_CR1_SSI)) |
;;;425                                      (hspi->Init.Direction & (SPI_CR1_RXONLY | SPI_CR1_BIDIMODE)) |
;;;426                                      (hspi->Init.DataSize & SPI_CR1_DFF) |
;;;427                                      (hspi->Init.CLKPolarity & SPI_CR1_CPOL) |
;;;428                                      (hspi->Init.CLKPhase & SPI_CR1_CPHA) |
;;;429                                      (hspi->Init.NSS & SPI_CR1_SSM) |
;;;430                                      (hspi->Init.BaudRatePrescaler & SPI_CR1_BR_Msk) |
;;;431                                      (hspi->Init.FirstBit  & SPI_CR1_LSBFIRST) |
;;;432                                      (hspi->Init.CRCCalculation & SPI_CR1_CRCEN)));
;;;433    
;;;434      /* Configure : NSS management */
;;;435      WRITE_REG(hspi->Instance->CR2, ((hspi->Init.NSS >> 16U) & SPI_CR2_SSOE));
;;;436    
;;;437    #if (USE_SPI_CRC != 0U)
;;;438      /*---------------------------- SPIx CRCPOLY Configuration ------------------*/
;;;439      /* Configure : CRC Polynomial */
;;;440      if (hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
;;;441      {
;;;442        WRITE_REG(hspi->Instance->CRCPR, (hspi->Init.CRCPolynomial & SPI_CRCPR_CRCPOLY_Msk));
;;;443      }
;;;444    #endif /* USE_SPI_CRC */
;;;445    
;;;446    #if defined(SPI_I2SCFGR_I2SMOD)
;;;447      /* Activate the SPI mode (Make sure that I2SMOD bit in I2SCFGR register is reset) */
;;;448      CLEAR_BIT(hspi->Instance->I2SCFGR, SPI_I2SCFGR_I2SMOD);
;;;449    #endif /* SPI_I2SCFGR_I2SMOD */
;;;450    
;;;451      hspi->ErrorCode = HAL_SPI_ERROR_NONE;
;;;452      hspi->State     = HAL_SPI_STATE_READY;
;;;453    
;;;454      return HAL_OK;
;;;455    }
000008  bd10              POP      {r4,pc}
                  |L12.10|
00000a  4990              LDR      r1,|L12.588|
00000c  6820              LDR      r0,[r4,#0]            ;344
00000e  4288              CMP      r0,r1                 ;344
000010  d003              BEQ      |L12.26|
000012  498f              LDR      r1,|L12.592|
000014  6820              LDR      r0,[r4,#0]            ;344
000016  4288              CMP      r0,r1                 ;344
000018  d100              BNE      |L12.28|
                  |L12.26|
00001a  e004              B        |L12.38|
                  |L12.28|
00001c  f44f71ac          MOV      r1,#0x158             ;344
000020  a08c              ADR      r0,|L12.596|
000022  f7fffffe          BL       assert_failed
                  |L12.38|
000026  6860              LDR      r0,[r4,#4]            ;345
000028  b118              CBZ      r0,|L12.50|
00002a  6860              LDR      r0,[r4,#4]            ;345
00002c  f5b07f82          CMP      r0,#0x104             ;345
000030  d100              BNE      |L12.52|
                  |L12.50|
000032  e004              B        |L12.62|
                  |L12.52|
000034  f2401159          MOV      r1,#0x159             ;345
000038  a086              ADR      r0,|L12.596|
00003a  f7fffffe          BL       assert_failed
                  |L12.62|
00003e  68a0              LDR      r0,[r4,#8]            ;346
000040  b138              CBZ      r0,|L12.82|
000042  68a0              LDR      r0,[r4,#8]            ;346
000044  f5b06f80          CMP      r0,#0x400             ;346
000048  d003              BEQ      |L12.82|
00004a  68a0              LDR      r0,[r4,#8]            ;346
00004c  f5b04f00          CMP      r0,#0x8000            ;346
000050  d100              BNE      |L12.84|
                  |L12.82|
000052  e004              B        |L12.94|
                  |L12.84|
000054  f44f71ad          MOV      r1,#0x15a             ;346
000058  a07e              ADR      r0,|L12.596|
00005a  f7fffffe          BL       assert_failed
                  |L12.94|
00005e  68e0              LDR      r0,[r4,#0xc]          ;347
000060  f5b06f00          CMP      r0,#0x800             ;347
000064  d001              BEQ      |L12.106|
000066  68e0              LDR      r0,[r4,#0xc]          ;347
000068  b900              CBNZ     r0,|L12.108|
                  |L12.106|
00006a  e004              B        |L12.118|
                  |L12.108|
00006c  f240115b          MOV      r1,#0x15b             ;347
000070  a078              ADR      r0,|L12.596|
000072  f7fffffe          BL       assert_failed
                  |L12.118|
000076  69a0              LDR      r0,[r4,#0x18]         ;348
000078  f5b07f00          CMP      r0,#0x200             ;348
00007c  d005              BEQ      |L12.138|
00007e  69a0              LDR      r0,[r4,#0x18]         ;348
000080  b118              CBZ      r0,|L12.138|
000082  69a0              LDR      r0,[r4,#0x18]         ;348
000084  f5b02f80          CMP      r0,#0x40000           ;348
000088  d100              BNE      |L12.140|
                  |L12.138|
00008a  e004              B        |L12.150|
                  |L12.140|
00008c  f44f71ae          MOV      r1,#0x15c             ;348
000090  a070              ADR      r0,|L12.596|
000092  f7fffffe          BL       assert_failed
                  |L12.150|
000096  69e0              LDR      r0,[r4,#0x1c]         ;349
000098  b1a0              CBZ      r0,|L12.196|
00009a  69e0              LDR      r0,[r4,#0x1c]         ;349
00009c  2808              CMP      r0,#8                 ;349
00009e  d011              BEQ      |L12.196|
0000a0  69e0              LDR      r0,[r4,#0x1c]         ;349
0000a2  2810              CMP      r0,#0x10              ;349
0000a4  d00e              BEQ      |L12.196|
0000a6  69e0              LDR      r0,[r4,#0x1c]         ;349
0000a8  2818              CMP      r0,#0x18              ;349
0000aa  d00b              BEQ      |L12.196|
0000ac  69e0              LDR      r0,[r4,#0x1c]         ;349
0000ae  2820              CMP      r0,#0x20              ;349
0000b0  d008              BEQ      |L12.196|
0000b2  69e0              LDR      r0,[r4,#0x1c]         ;349
0000b4  2828              CMP      r0,#0x28              ;349
0000b6  d005              BEQ      |L12.196|
0000b8  69e0              LDR      r0,[r4,#0x1c]         ;349
0000ba  2830              CMP      r0,#0x30              ;349
0000bc  d002              BEQ      |L12.196|
0000be  69e0              LDR      r0,[r4,#0x1c]         ;349
0000c0  2838              CMP      r0,#0x38              ;349
0000c2  d100              BNE      |L12.198|
                  |L12.196|
0000c4  e004              B        |L12.208|
                  |L12.198|
0000c6  f240115d          MOV      r1,#0x15d             ;349
0000ca  a062              ADR      r0,|L12.596|
0000cc  f7fffffe          BL       assert_failed
                  |L12.208|
0000d0  6a20              LDR      r0,[r4,#0x20]         ;350
0000d2  b110              CBZ      r0,|L12.218|
0000d4  6a20              LDR      r0,[r4,#0x20]         ;350
0000d6  2880              CMP      r0,#0x80              ;350
0000d8  d100              BNE      |L12.220|
                  |L12.218|
0000da  e004              B        |L12.230|
                  |L12.220|
0000dc  f44f71af          MOV      r1,#0x15e             ;350
0000e0  a05c              ADR      r0,|L12.596|
0000e2  f7fffffe          BL       assert_failed
                  |L12.230|
0000e6  6a60              LDR      r0,[r4,#0x24]         ;353
0000e8  b900              CBNZ     r0,|L12.236|
0000ea  e004              B        |L12.246|
                  |L12.236|
0000ec  f2401161          MOV      r1,#0x161             ;353
0000f0  a058              ADR      r0,|L12.596|
0000f2  f7fffffe          BL       assert_failed
                  |L12.246|
0000f6  6a60              LDR      r0,[r4,#0x24]         ;354
0000f8  2800              CMP      r0,#0                 ;354
0000fa  d13a              BNE      |L12.370|
0000fc  6920              LDR      r0,[r4,#0x10]         ;356
0000fe  b110              CBZ      r0,|L12.262|
000100  6920              LDR      r0,[r4,#0x10]         ;356
000102  2802              CMP      r0,#2                 ;356
000104  d100              BNE      |L12.264|
                  |L12.262|
000106  e004              B        |L12.274|
                  |L12.264|
000108  f44f71b2          MOV      r1,#0x164             ;356
00010c  a051              ADR      r0,|L12.596|
00010e  f7fffffe          BL       assert_failed
                  |L12.274|
000112  6960              LDR      r0,[r4,#0x14]         ;357
000114  b110              CBZ      r0,|L12.284|
000116  6960              LDR      r0,[r4,#0x14]         ;357
000118  2801              CMP      r0,#1                 ;357
00011a  d100              BNE      |L12.286|
                  |L12.284|
00011c  e004              B        |L12.296|
                  |L12.286|
00011e  f2401165          MOV      r1,#0x165             ;357
000122  a04c              ADR      r0,|L12.596|
000124  f7fffffe          BL       assert_failed
                  |L12.296|
000128  6860              LDR      r0,[r4,#4]            ;359
00012a  f5b07f82          CMP      r0,#0x104             ;359
00012e  d11d              BNE      |L12.364|
000130  69e0              LDR      r0,[r4,#0x1c]         ;361
000132  b1a0              CBZ      r0,|L12.350|
000134  69e0              LDR      r0,[r4,#0x1c]         ;361
000136  2808              CMP      r0,#8                 ;361
000138  d011              BEQ      |L12.350|
00013a  69e0              LDR      r0,[r4,#0x1c]         ;361
00013c  2810              CMP      r0,#0x10              ;361
00013e  d00e              BEQ      |L12.350|
000140  69e0              LDR      r0,[r4,#0x1c]         ;361
000142  2818              CMP      r0,#0x18              ;361
000144  d00b              BEQ      |L12.350|
000146  69e0              LDR      r0,[r4,#0x1c]         ;361
000148  2820              CMP      r0,#0x20              ;361
00014a  d008              BEQ      |L12.350|
00014c  69e0              LDR      r0,[r4,#0x1c]         ;361
00014e  2828              CMP      r0,#0x28              ;361
000150  d005              BEQ      |L12.350|
000152  69e0              LDR      r0,[r4,#0x1c]         ;361
000154  2830              CMP      r0,#0x30              ;361
000156  d002              BEQ      |L12.350|
000158  69e0              LDR      r0,[r4,#0x1c]         ;361
00015a  2838              CMP      r0,#0x38              ;361
00015c  d100              BNE      |L12.352|
                  |L12.350|
00015e  e028              B        |L12.434|
                  |L12.352|
000160  f2401169          MOV      r1,#0x169             ;361
000164  a03b              ADR      r0,|L12.596|
000166  f7fffffe          BL       assert_failed
00016a  e022              B        |L12.434|
                  |L12.364|
00016c  2100              MOVS     r1,#0                 ;366
00016e  61e1              STR      r1,[r4,#0x1c]         ;366
000170  e01f              B        |L12.434|
                  |L12.370|
000172  69e0              LDR      r0,[r4,#0x1c]         ;371
000174  b1a0              CBZ      r0,|L12.416|
000176  69e0              LDR      r0,[r4,#0x1c]         ;371
000178  2808              CMP      r0,#8                 ;371
00017a  d011              BEQ      |L12.416|
00017c  69e0              LDR      r0,[r4,#0x1c]         ;371
00017e  2810              CMP      r0,#0x10              ;371
000180  d00e              BEQ      |L12.416|
000182  69e0              LDR      r0,[r4,#0x1c]         ;371
000184  2818              CMP      r0,#0x18              ;371
000186  d00b              BEQ      |L12.416|
000188  69e0              LDR      r0,[r4,#0x1c]         ;371
00018a  2820              CMP      r0,#0x20              ;371
00018c  d008              BEQ      |L12.416|
00018e  69e0              LDR      r0,[r4,#0x1c]         ;371
000190  2828              CMP      r0,#0x28              ;371
000192  d005              BEQ      |L12.416|
000194  69e0              LDR      r0,[r4,#0x1c]         ;371
000196  2830              CMP      r0,#0x30              ;371
000198  d002              BEQ      |L12.416|
00019a  69e0              LDR      r0,[r4,#0x1c]         ;371
00019c  2838              CMP      r0,#0x38              ;371
00019e  d100              BNE      |L12.418|
                  |L12.416|
0001a0  e004              B        |L12.428|
                  |L12.418|
0001a2  f2401173          MOV      r1,#0x173             ;371
0001a6  a02b              ADR      r0,|L12.596|
0001a8  f7fffffe          BL       assert_failed
                  |L12.428|
0001ac  2100              MOVS     r1,#0                 ;374
0001ae  6121              STR      r1,[r4,#0x10]         ;374
0001b0  6161              STR      r1,[r4,#0x14]         ;375
                  |L12.434|
0001b2  2100              MOVS     r1,#0                 ;384
0001b4  62a1              STR      r1,[r4,#0x28]         ;384
0001b6  f8940051          LDRB     r0,[r4,#0x51]         ;387
0001ba  b928              CBNZ     r0,|L12.456|
0001bc  2000              MOVS     r0,#0                 ;390
0001be  f8840050          STRB     r0,[r4,#0x50]         ;390
0001c2  4620              MOV      r0,r4                 ;412
0001c4  f7fffffe          BL       HAL_SPI_MspInit
                  |L12.456|
0001c8  2002              MOVS     r0,#2                 ;416
0001ca  f8840051          STRB     r0,[r4,#0x51]         ;416
0001ce  6820              LDR      r0,[r4,#0]            ;419
0001d0  6800              LDR      r0,[r0,#0]            ;419
0001d2  f0200040          BIC      r0,r0,#0x40           ;419
0001d6  6821              LDR      r1,[r4,#0]            ;419
0001d8  6008              STR      r0,[r1,#0]            ;419
0001da  88a0              LDRH     r0,[r4,#4]            ;424
0001dc  f4007082          AND      r0,r0,#0x104          ;424
0001e0  8921              LDRH     r1,[r4,#8]            ;424
0001e2  f4014104          AND      r1,r1,#0x8400         ;424
0001e6  4308              ORRS     r0,r0,r1              ;424
0001e8  89a1              LDRH     r1,[r4,#0xc]          ;424
0001ea  f4016100          AND      r1,r1,#0x800          ;424
0001ee  4308              ORRS     r0,r0,r1              ;424
0001f0  7c21              LDRB     r1,[r4,#0x10]         ;424
0001f2  f0010102          AND      r1,r1,#2              ;424
0001f6  4308              ORRS     r0,r0,r1              ;424
0001f8  7d21              LDRB     r1,[r4,#0x14]         ;424
0001fa  f0010101          AND      r1,r1,#1              ;424
0001fe  4308              ORRS     r0,r0,r1              ;424
000200  8b21              LDRH     r1,[r4,#0x18]         ;424
000202  f4017100          AND      r1,r1,#0x200          ;424
000206  4308              ORRS     r0,r0,r1              ;424
000208  7f21              LDRB     r1,[r4,#0x1c]         ;424
00020a  f0010138          AND      r1,r1,#0x38           ;424
00020e  4308              ORRS     r0,r0,r1              ;424
000210  2120              MOVS     r1,#0x20              ;424
000212  5d09              LDRB     r1,[r1,r4]            ;424
000214  f0010180          AND      r1,r1,#0x80           ;424
000218  4308              ORRS     r0,r0,r1              ;424
00021a  8d21              LDRH     r1,[r4,#0x28]         ;424
00021c  f4015100          AND      r1,r1,#0x2000         ;424
000220  4308              ORRS     r0,r0,r1              ;424
000222  6821              LDR      r1,[r4,#0]            ;424
000224  6008              STR      r0,[r1,#0]            ;424
000226  2104              MOVS     r1,#4                 ;435
000228  69a0              LDR      r0,[r4,#0x18]         ;435
00022a  ea014010          AND      r0,r1,r0,LSR #16      ;435
00022e  6821              LDR      r1,[r4,#0]            ;435
000230  6048              STR      r0,[r1,#4]            ;435
000232  6820              LDR      r0,[r4,#0]            ;448
000234  69c0              LDR      r0,[r0,#0x1c]         ;448
000236  f4206000          BIC      r0,r0,#0x800          ;448
00023a  6821              LDR      r1,[r4,#0]            ;448
00023c  61c8              STR      r0,[r1,#0x1c]         ;448
00023e  2000              MOVS     r0,#0                 ;451
000240  6560              STR      r0,[r4,#0x54]         ;451
000242  2001              MOVS     r0,#1                 ;452
000244  f8840051          STRB     r0,[r4,#0x51]         ;452
000248  2000              MOVS     r0,#0                 ;454
00024a  e6dd              B        |L12.8|
;;;456    
                          ENDP

                  |L12.588|
                          DCD      0x40013000
                  |L12.592|
                          DCD      0x40003800
                  |L12.596|
000254  2e2e2f44          DCB      "../Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_spi.c"
000258  72697665
00025c  72732f53
000260  544d3332
000264  46317878
000268  5f48414c
00026c  5f447269
000270  7665722f
000274  5372632f
000278  73746d33
00027c  32663178
000280  785f6861
000284  6c5f7370
000288  692e63  
00028b  00                DCB      0

                          AREA ||i.HAL_SPI_MspDeInit||, CODE, READONLY, ALIGN=1

                  HAL_SPI_MspDeInit PROC
;;;522      */
;;;523    __weak void HAL_SPI_MspDeInit(SPI_HandleTypeDef *hspi)
000000  4770              BX       lr
;;;524    {
;;;525      /* Prevent unused argument(s) compilation warning */
;;;526      UNUSED(hspi);
;;;527    
;;;528      /* NOTE : This function should not be modified, when the callback is needed,
;;;529                the HAL_SPI_MspDeInit should be implemented in the user file
;;;530       */
;;;531    }
;;;532    
                          ENDP


                          AREA ||i.HAL_SPI_MspInit||, CODE, READONLY, ALIGN=1

                  HAL_SPI_MspInit PROC
;;;506      */
;;;507    __weak void HAL_SPI_MspInit(SPI_HandleTypeDef *hspi)
000000  4770              BX       lr
;;;508    {
;;;509      /* Prevent unused argument(s) compilation warning */
;;;510      UNUSED(hspi);
;;;511    
;;;512      /* NOTE : This function should not be modified, when the callback is needed,
;;;513                the HAL_SPI_MspInit should be implemented in the user file
;;;514       */
;;;515    }
;;;516    
                          ENDP


                          AREA ||i.HAL_SPI_Receive||, CODE, READONLY, ALIGN=1

                  HAL_SPI_Receive PROC
;;;959      */
;;;960    HAL_StatusTypeDef HAL_SPI_Receive(SPI_HandleTypeDef *hspi, uint8_t *pData, uint16_t Size, uint32_t Timeout)
000000  e92d43f8          PUSH     {r3-r9,lr}
;;;961    {
000004  4604              MOV      r4,r0
000006  4688              MOV      r8,r1
000008  4616              MOV      r6,r2
00000a  461d              MOV      r5,r3
;;;962      uint32_t tickstart;
;;;963      HAL_StatusTypeDef errorcode = HAL_OK;
00000c  f04f0900          MOV      r9,#0
;;;964    
;;;965      if ((hspi->Init.Mode == SPI_MODE_MASTER) && (hspi->Init.Direction == SPI_DIRECTION_2LINES))
000010  6860              LDR      r0,[r4,#4]
000012  f5b07f82          CMP      r0,#0x104
000016  d10d              BNE      |L15.52|
000018  68a0              LDR      r0,[r4,#8]
00001a  b958              CBNZ     r0,|L15.52|
;;;966      {
;;;967        hspi->State = HAL_SPI_STATE_BUSY_RX;
00001c  2004              MOVS     r0,#4
00001e  f8840051          STRB     r0,[r4,#0x51]
;;;968        /* Call transmit-receive function to send Dummy data on Tx line and generate clock on CLK line */
;;;969        return HAL_SPI_TransmitReceive(hspi, pData, pData, Size, Timeout);
000022  4633              MOV      r3,r6
000024  4642              MOV      r2,r8
000026  4641              MOV      r1,r8
000028  4620              MOV      r0,r4
00002a  9500              STR      r5,[sp,#0]
00002c  f7fffffe          BL       HAL_SPI_TransmitReceive
                  |L15.48|
;;;970      }
;;;971    
;;;972      /* Process Locked */
;;;973      __HAL_LOCK(hspi);
;;;974    
;;;975      /* Init tickstart for timeout management*/
;;;976      tickstart = HAL_GetTick();
;;;977    
;;;978      if (hspi->State != HAL_SPI_STATE_READY)
;;;979      {
;;;980        errorcode = HAL_BUSY;
;;;981        goto error;
;;;982      }
;;;983    
;;;984      if ((pData == NULL) || (Size == 0U))
;;;985      {
;;;986        errorcode = HAL_ERROR;
;;;987        goto error;
;;;988      }
;;;989    
;;;990      /* Set the transaction information */
;;;991      hspi->State       = HAL_SPI_STATE_BUSY_RX;
;;;992      hspi->ErrorCode   = HAL_SPI_ERROR_NONE;
;;;993      hspi->pRxBuffPtr  = (uint8_t *)pData;
;;;994      hspi->RxXferSize  = Size;
;;;995      hspi->RxXferCount = Size;
;;;996    
;;;997      /*Init field not used in handle to zero */
;;;998      hspi->pTxBuffPtr  = (uint8_t *)NULL;
;;;999      hspi->TxXferSize  = 0U;
;;;1000     hspi->TxXferCount = 0U;
;;;1001     hspi->RxISR       = NULL;
;;;1002     hspi->TxISR       = NULL;
;;;1003   
;;;1004   #if (USE_SPI_CRC != 0U)
;;;1005     /* Reset CRC Calculation */
;;;1006     if (hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
;;;1007     {
;;;1008       SPI_RESET_CRC(hspi);
;;;1009       /* this is done to handle the CRCNEXT before the latest data */
;;;1010       hspi->RxXferCount--;
;;;1011     }
;;;1012   #endif /* USE_SPI_CRC */
;;;1013   
;;;1014     /* Configure communication direction: 1Line */
;;;1015     if (hspi->Init.Direction == SPI_DIRECTION_1LINE)
;;;1016     {
;;;1017       /* Disable SPI Peripheral before set 1Line direction (BIDIOE bit) */
;;;1018       __HAL_SPI_DISABLE(hspi);
;;;1019       SPI_1LINE_RX(hspi);
;;;1020     }
;;;1021   
;;;1022     /* Check if the SPI is already enabled */
;;;1023     if ((hspi->Instance->CR1 & SPI_CR1_SPE) != SPI_CR1_SPE)
;;;1024     {
;;;1025       /* Enable SPI peripheral */
;;;1026       __HAL_SPI_ENABLE(hspi);
;;;1027     }
;;;1028   
;;;1029     /* Receive data in 8 Bit mode */
;;;1030     if (hspi->Init.DataSize == SPI_DATASIZE_8BIT)
;;;1031     {
;;;1032       /* Transfer loop */
;;;1033       while (hspi->RxXferCount > 0U)
;;;1034       {
;;;1035         /* Check the RXNE flag */
;;;1036         if (__HAL_SPI_GET_FLAG(hspi, SPI_FLAG_RXNE))
;;;1037         {
;;;1038           /* read the received data */
;;;1039           (* (uint8_t *)hspi->pRxBuffPtr) = *(__IO uint8_t *)&hspi->Instance->DR;
;;;1040           hspi->pRxBuffPtr += sizeof(uint8_t);
;;;1041           hspi->RxXferCount--;
;;;1042         }
;;;1043         else
;;;1044         {
;;;1045           /* Timeout management */
;;;1046           if ((((HAL_GetTick() - tickstart) >=  Timeout) && (Timeout != HAL_MAX_DELAY)) || (Timeout == 0U))
;;;1047           {
;;;1048             errorcode = HAL_TIMEOUT;
;;;1049             goto error;
;;;1050           }
;;;1051         }
;;;1052       }
;;;1053     }
;;;1054     else
;;;1055     {
;;;1056       /* Transfer loop */
;;;1057       while (hspi->RxXferCount > 0U)
;;;1058       {
;;;1059         /* Check the RXNE flag */
;;;1060         if (__HAL_SPI_GET_FLAG(hspi, SPI_FLAG_RXNE))
;;;1061         {
;;;1062           *((uint16_t *)hspi->pRxBuffPtr) = (uint16_t)hspi->Instance->DR;
;;;1063           hspi->pRxBuffPtr += sizeof(uint16_t);
;;;1064           hspi->RxXferCount--;
;;;1065         }
;;;1066         else
;;;1067         {
;;;1068           /* Timeout management */
;;;1069           if ((((HAL_GetTick() - tickstart) >=  Timeout) && (Timeout != HAL_MAX_DELAY)) || (Timeout == 0U))
;;;1070           {
;;;1071             errorcode = HAL_TIMEOUT;
;;;1072             goto error;
;;;1073           }
;;;1074         }
;;;1075       }
;;;1076     }
;;;1077   
;;;1078   #if (USE_SPI_CRC != 0U)
;;;1079     /* Handle the CRC Transmission */
;;;1080     if (hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
;;;1081     {
;;;1082       /* freeze the CRC before the latest data */
;;;1083       SET_BIT(hspi->Instance->CR1, SPI_CR1_CRCNEXT);
;;;1084   
;;;1085       /* Check if CRCNEXT is well reseted by hardware */
;;;1086       if (READ_BIT(hspi->Instance->CR1, SPI_CR1_CRCNEXT))
;;;1087       {
;;;1088         /* Workaround to force CRCNEXT bit to zero in case of CRCNEXT is not reset automatically by hardware */
;;;1089         CLEAR_BIT(hspi->Instance->CR1, SPI_CR1_CRCNEXT);
;;;1090       }
;;;1091       /* Read the latest data */
;;;1092       if (SPI_WaitFlagStateUntilTimeout(hspi, SPI_FLAG_RXNE, SET, Timeout, tickstart) != HAL_OK)
;;;1093       {
;;;1094         /* the latest data has not been received */
;;;1095         errorcode = HAL_TIMEOUT;
;;;1096         goto error;
;;;1097       }
;;;1098   
;;;1099       /* Receive last data in 16 Bit mode */
;;;1100       if (hspi->Init.DataSize == SPI_DATASIZE_16BIT)
;;;1101       {
;;;1102         *((uint16_t *)hspi->pRxBuffPtr) = (uint16_t)hspi->Instance->DR;
;;;1103       }
;;;1104       /* Receive last data in 8 Bit mode */
;;;1105       else
;;;1106       {
;;;1107         (*(uint8_t *)hspi->pRxBuffPtr) = *(__IO uint8_t *)&hspi->Instance->DR;
;;;1108       }
;;;1109   
;;;1110       /* Wait the CRC data */
;;;1111       if (SPI_WaitFlagStateUntilTimeout(hspi, SPI_FLAG_RXNE, SET, Timeout, tickstart) != HAL_OK)
;;;1112       {
;;;1113         SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_CRC);
;;;1114         errorcode = HAL_TIMEOUT;
;;;1115         goto error;
;;;1116       }
;;;1117   
;;;1118       /* Read CRC to Flush DR and RXNE flag */
;;;1119       READ_REG(hspi->Instance->DR);
;;;1120     }
;;;1121   #endif /* USE_SPI_CRC */
;;;1122   
;;;1123     /* Check the end of the transaction */
;;;1124     if (SPI_EndRxTransaction(hspi, Timeout, tickstart) != HAL_OK)
;;;1125     {
;;;1126       hspi->ErrorCode = HAL_SPI_ERROR_FLAG;
;;;1127     }
;;;1128   
;;;1129   #if (USE_SPI_CRC != 0U)
;;;1130     /* Check if CRC error occurred */
;;;1131     if (__HAL_SPI_GET_FLAG(hspi, SPI_FLAG_CRCERR) != RESET)
;;;1132     {
;;;1133       /* Check if CRC error is valid or not (workaround to be applied or not) */
;;;1134       if (SPI_ISCRCErrorValid(hspi) == SPI_VALID_CRC_ERROR)
;;;1135       {
;;;1136         SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_CRC);
;;;1137   
;;;1138         /* Reset CRC Calculation */
;;;1139         SPI_RESET_CRC(hspi);
;;;1140       }
;;;1141       else
;;;1142       {
;;;1143         __HAL_SPI_CLEAR_CRCERRFLAG(hspi);
;;;1144       }
;;;1145     }
;;;1146   #endif /* USE_SPI_CRC */
;;;1147   
;;;1148     if (hspi->ErrorCode != HAL_SPI_ERROR_NONE)
;;;1149     {
;;;1150       errorcode = HAL_ERROR;
;;;1151     }
;;;1152   
;;;1153   error :
;;;1154     hspi->State = HAL_SPI_STATE_READY;
;;;1155     __HAL_UNLOCK(hspi);
;;;1156     return errorcode;
;;;1157   }
000030  e8bd83f8          POP      {r3-r9,pc}
                  |L15.52|
000034  bf00              NOP                            ;973
000036  f8940050          LDRB     r0,[r4,#0x50]         ;973
00003a  2801              CMP      r0,#1                 ;973
00003c  d101              BNE      |L15.66|
00003e  2002              MOVS     r0,#2                 ;973
000040  e7f6              B        |L15.48|
                  |L15.66|
000042  2001              MOVS     r0,#1                 ;973
000044  f8840050          STRB     r0,[r4,#0x50]         ;973
000048  bf00              NOP                            ;973
00004a  f7fffffe          BL       HAL_GetTick
00004e  4607              MOV      r7,r0                 ;976
000050  f8940051          LDRB     r0,[r4,#0x51]         ;978
000054  2801              CMP      r0,#1                 ;978
000056  d002              BEQ      |L15.94|
000058  f04f0902          MOV      r9,#2                 ;980
00005c  e07e              B        |L15.348|
                  |L15.94|
00005e  f1b80f00          CMP      r8,#0                 ;984
000062  d000              BEQ      |L15.102|
000064  b916              CBNZ     r6,|L15.108|
                  |L15.102|
000066  f04f0901          MOV      r9,#1                 ;986
00006a  e077              B        |L15.348|
                  |L15.108|
00006c  2004              MOVS     r0,#4                 ;991
00006e  f8840051          STRB     r0,[r4,#0x51]         ;991
000072  2000              MOVS     r0,#0                 ;992
000074  6560              STR      r0,[r4,#0x54]         ;992
000076  f8c48038          STR      r8,[r4,#0x38]         ;993
00007a  87a6              STRH     r6,[r4,#0x3c]         ;994
00007c  87e6              STRH     r6,[r4,#0x3e]         ;995
00007e  6320              STR      r0,[r4,#0x30]         ;998
000080  86a0              STRH     r0,[r4,#0x34]         ;999
000082  86e0              STRH     r0,[r4,#0x36]         ;1000
000084  6420              STR      r0,[r4,#0x40]         ;1001
000086  6460              STR      r0,[r4,#0x44]         ;1002
000088  68a0              LDR      r0,[r4,#8]            ;1015
00008a  f5b04f00          CMP      r0,#0x8000            ;1015
00008e  d10b              BNE      |L15.168|
000090  6820              LDR      r0,[r4,#0]            ;1018
000092  6800              LDR      r0,[r0,#0]            ;1018
000094  f0200040          BIC      r0,r0,#0x40           ;1018
000098  6821              LDR      r1,[r4,#0]            ;1018
00009a  6008              STR      r0,[r1,#0]            ;1018
00009c  6820              LDR      r0,[r4,#0]            ;1019
00009e  6800              LDR      r0,[r0,#0]            ;1019
0000a0  f4204080          BIC      r0,r0,#0x4000         ;1019
0000a4  6821              LDR      r1,[r4,#0]            ;1019
0000a6  6008              STR      r0,[r1,#0]            ;1019
                  |L15.168|
0000a8  6820              LDR      r0,[r4,#0]            ;1023
0000aa  6800              LDR      r0,[r0,#0]            ;1023
0000ac  f0000040          AND      r0,r0,#0x40           ;1023
0000b0  2840              CMP      r0,#0x40              ;1023
0000b2  d005              BEQ      |L15.192|
0000b4  6820              LDR      r0,[r4,#0]            ;1026
0000b6  6800              LDR      r0,[r0,#0]            ;1026
0000b8  f0400040          ORR      r0,r0,#0x40           ;1026
0000bc  6821              LDR      r1,[r4,#0]            ;1026
0000be  6008              STR      r0,[r1,#0]            ;1026
                  |L15.192|
0000c0  68e0              LDR      r0,[r4,#0xc]          ;1030
0000c2  b9f8              CBNZ     r0,|L15.260|
0000c4  e01a              B        |L15.252|
                  |L15.198|
0000c6  6820              LDR      r0,[r4,#0]            ;1036
0000c8  6880              LDR      r0,[r0,#8]            ;1036
0000ca  f0000001          AND      r0,r0,#1              ;1036
0000ce  b150              CBZ      r0,|L15.230|
0000d0  6820              LDR      r0,[r4,#0]            ;1039
0000d2  7b00              LDRB     r0,[r0,#0xc]          ;1039
0000d4  6ba1              LDR      r1,[r4,#0x38]         ;1039
0000d6  7008              STRB     r0,[r1,#0]            ;1039
0000d8  6ba0              LDR      r0,[r4,#0x38]         ;1040
0000da  1c40              ADDS     r0,r0,#1              ;1040
0000dc  63a0              STR      r0,[r4,#0x38]         ;1040
0000de  8fe0              LDRH     r0,[r4,#0x3e]         ;1041
0000e0  1e40              SUBS     r0,r0,#1              ;1041
0000e2  87e0              STRH     r0,[r4,#0x3e]         ;1041
0000e4  e00a              B        |L15.252|
                  |L15.230|
0000e6  f7fffffe          BL       HAL_GetTick
0000ea  1bc0              SUBS     r0,r0,r7              ;1046
0000ec  42a8              CMP      r0,r5                 ;1046
0000ee  d301              BCC      |L15.244|
0000f0  1c68              ADDS     r0,r5,#1              ;1046
0000f2  b900              CBNZ     r0,|L15.246|
                  |L15.244|
0000f4  b915              CBNZ     r5,|L15.252|
                  |L15.246|
0000f6  f04f0903          MOV      r9,#3                 ;1048
0000fa  e02f              B        |L15.348|
                  |L15.252|
0000fc  8fe0              LDRH     r0,[r4,#0x3e]         ;1033
0000fe  2800              CMP      r0,#0                 ;1033
000100  d1e1              BNE      |L15.198|
000102  e01e              B        |L15.322|
                  |L15.260|
000104  e01a              B        |L15.316|
                  |L15.262|
000106  6820              LDR      r0,[r4,#0]            ;1060
000108  6880              LDR      r0,[r0,#8]            ;1060
00010a  f0000001          AND      r0,r0,#1              ;1060
00010e  b150              CBZ      r0,|L15.294|
000110  6820              LDR      r0,[r4,#0]            ;1062
000112  68c0              LDR      r0,[r0,#0xc]          ;1062
000114  6ba1              LDR      r1,[r4,#0x38]         ;1062
000116  8008              STRH     r0,[r1,#0]            ;1062
000118  6ba0              LDR      r0,[r4,#0x38]         ;1063
00011a  1c80              ADDS     r0,r0,#2              ;1063
00011c  63a0              STR      r0,[r4,#0x38]         ;1063
00011e  8fe0              LDRH     r0,[r4,#0x3e]         ;1064
000120  1e40              SUBS     r0,r0,#1              ;1064
000122  87e0              STRH     r0,[r4,#0x3e]         ;1064
000124  e00a              B        |L15.316|
                  |L15.294|
000126  f7fffffe          BL       HAL_GetTick
00012a  1bc0              SUBS     r0,r0,r7              ;1069
00012c  42a8              CMP      r0,r5                 ;1069
00012e  d301              BCC      |L15.308|
000130  1c68              ADDS     r0,r5,#1              ;1069
000132  b900              CBNZ     r0,|L15.310|
                  |L15.308|
000134  b915              CBNZ     r5,|L15.316|
                  |L15.310|
000136  f04f0903          MOV      r9,#3                 ;1071
00013a  e00f              B        |L15.348|
                  |L15.316|
00013c  8fe0              LDRH     r0,[r4,#0x3e]         ;1057
00013e  2800              CMP      r0,#0                 ;1057
000140  d1e1              BNE      |L15.262|
                  |L15.322|
000142  463a              MOV      r2,r7                 ;1124
000144  4629              MOV      r1,r5                 ;1124
000146  4620              MOV      r0,r4                 ;1124
000148  f7fffffe          BL       SPI_EndRxTransaction
00014c  b108              CBZ      r0,|L15.338|
00014e  2020              MOVS     r0,#0x20              ;1126
000150  6560              STR      r0,[r4,#0x54]         ;1126
                  |L15.338|
000152  6d60              LDR      r0,[r4,#0x54]         ;1148
000154  b108              CBZ      r0,|L15.346|
000156  f04f0901          MOV      r9,#1                 ;1150
                  |L15.346|
00015a  bf00              NOP                            ;1153
                  |L15.348|
00015c  2001              MOVS     r0,#1                 ;1154
00015e  f8840051          STRB     r0,[r4,#0x51]         ;1154
000162  bf00              NOP                            ;1155
000164  2000              MOVS     r0,#0                 ;1155
000166  f8840050          STRB     r0,[r4,#0x50]         ;1155
00016a  bf00              NOP                            ;1155
00016c  4648              MOV      r0,r9                 ;1156
00016e  e75f              B        |L15.48|
;;;1158   
                          ENDP


                          AREA ||i.HAL_SPI_Receive_DMA||, CODE, READONLY, ALIGN=2

                  HAL_SPI_Receive_DMA PROC
;;;1771     */
;;;1772   HAL_StatusTypeDef HAL_SPI_Receive_DMA(SPI_HandleTypeDef *hspi, uint8_t *pData, uint16_t Size)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;1773   {
000004  4604              MOV      r4,r0
000006  460e              MOV      r6,r1
000008  4615              MOV      r5,r2
;;;1774     HAL_StatusTypeDef errorcode = HAL_OK;
00000a  2700              MOVS     r7,#0
;;;1775   
;;;1776     /* Check rx dma handle */
;;;1777     assert_param(IS_SPI_DMA_HANDLE(hspi->hdmarx));
00000c  6ce0              LDR      r0,[r4,#0x4c]
00000e  b100              CBZ      r0,|L16.18|
000010  e004              B        |L16.28|
                  |L16.18|
000012  f24061f1          MOV      r1,#0x6f1
000016  a046              ADR      r0,|L16.304|
000018  f7fffffe          BL       assert_failed
                  |L16.28|
;;;1778   
;;;1779     if ((hspi->Init.Direction == SPI_DIRECTION_2LINES) && (hspi->Init.Mode == SPI_MODE_MASTER))
00001c  68a0              LDR      r0,[r4,#8]
00001e  b9b0              CBNZ     r0,|L16.78|
000020  6860              LDR      r0,[r4,#4]
000022  f5b07f82          CMP      r0,#0x104
000026  d112              BNE      |L16.78|
;;;1780     {
;;;1781       hspi->State = HAL_SPI_STATE_BUSY_RX;
000028  2004              MOVS     r0,#4
00002a  f8840051          STRB     r0,[r4,#0x51]
;;;1782   
;;;1783       /* Check tx dma handle */
;;;1784       assert_param(IS_SPI_DMA_HANDLE(hspi->hdmatx));
00002e  6ca0              LDR      r0,[r4,#0x48]
000030  b100              CBZ      r0,|L16.52|
000032  e004              B        |L16.62|
                  |L16.52|
000034  f44f61df          MOV      r1,#0x6f8
000038  a03d              ADR      r0,|L16.304|
00003a  f7fffffe          BL       assert_failed
                  |L16.62|
;;;1785   
;;;1786       /* Call transmit-receive function to send Dummy data on Tx line and generate clock on CLK line */
;;;1787       return HAL_SPI_TransmitReceive_DMA(hspi, pData, pData, Size);
00003e  462b              MOV      r3,r5
000040  4632              MOV      r2,r6
000042  4631              MOV      r1,r6
000044  4620              MOV      r0,r4
000046  f7fffffe          BL       HAL_SPI_TransmitReceive_DMA
                  |L16.74|
;;;1788     }
;;;1789   
;;;1790     /* Process Locked */
;;;1791     __HAL_LOCK(hspi);
;;;1792   
;;;1793     if (hspi->State != HAL_SPI_STATE_READY)
;;;1794     {
;;;1795       errorcode = HAL_BUSY;
;;;1796       goto error;
;;;1797     }
;;;1798   
;;;1799     if ((pData == NULL) || (Size == 0U))
;;;1800     {
;;;1801       errorcode = HAL_ERROR;
;;;1802       goto error;
;;;1803     }
;;;1804   
;;;1805     /* Set the transaction information */
;;;1806     hspi->State       = HAL_SPI_STATE_BUSY_RX;
;;;1807     hspi->ErrorCode   = HAL_SPI_ERROR_NONE;
;;;1808     hspi->pRxBuffPtr  = (uint8_t *)pData;
;;;1809     hspi->RxXferSize  = Size;
;;;1810     hspi->RxXferCount = Size;
;;;1811   
;;;1812     /*Init field not used in handle to zero */
;;;1813     hspi->RxISR       = NULL;
;;;1814     hspi->TxISR       = NULL;
;;;1815     hspi->TxXferSize  = 0U;
;;;1816     hspi->TxXferCount = 0U;
;;;1817   
;;;1818     /* Configure communication direction : 1Line */
;;;1819     if (hspi->Init.Direction == SPI_DIRECTION_1LINE)
;;;1820     {
;;;1821       /* Disable SPI Peripheral before set 1Line direction (BIDIOE bit) */
;;;1822       __HAL_SPI_DISABLE(hspi);
;;;1823       SPI_1LINE_RX(hspi);
;;;1824     }
;;;1825   
;;;1826   #if (USE_SPI_CRC != 0U)
;;;1827     /* Reset CRC Calculation */
;;;1828     if (hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
;;;1829     {
;;;1830       SPI_RESET_CRC(hspi);
;;;1831     }
;;;1832   #endif /* USE_SPI_CRC */
;;;1833   
;;;1834     /* Set the SPI RxDMA Half transfer complete callback */
;;;1835     hspi->hdmarx->XferHalfCpltCallback = SPI_DMAHalfReceiveCplt;
;;;1836   
;;;1837     /* Set the SPI Rx DMA transfer complete callback */
;;;1838     hspi->hdmarx->XferCpltCallback = SPI_DMAReceiveCplt;
;;;1839   
;;;1840     /* Set the DMA error callback */
;;;1841     hspi->hdmarx->XferErrorCallback = SPI_DMAError;
;;;1842   
;;;1843     /* Set the DMA AbortCpltCallback */
;;;1844     hspi->hdmarx->XferAbortCallback = NULL;
;;;1845   
;;;1846     /* Enable the Rx DMA Stream/Channel  */
;;;1847     if (HAL_OK != HAL_DMA_Start_IT(hspi->hdmarx, (uint32_t)&hspi->Instance->DR, (uint32_t)hspi->pRxBuffPtr,
;;;1848                                    hspi->RxXferCount))
;;;1849     {
;;;1850       /* Update SPI error code */
;;;1851       SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_DMA);
;;;1852       errorcode = HAL_ERROR;
;;;1853   
;;;1854       hspi->State = HAL_SPI_STATE_READY;
;;;1855       goto error;
;;;1856     }
;;;1857   
;;;1858     /* Check if the SPI is already enabled */
;;;1859     if ((hspi->Instance->CR1 & SPI_CR1_SPE) != SPI_CR1_SPE)
;;;1860     {
;;;1861       /* Enable SPI peripheral */
;;;1862       __HAL_SPI_ENABLE(hspi);
;;;1863     }
;;;1864   
;;;1865     /* Enable the SPI Error Interrupt Bit */
;;;1866     __HAL_SPI_ENABLE_IT(hspi, (SPI_IT_ERR));
;;;1867   
;;;1868     /* Enable Rx DMA Request */
;;;1869     SET_BIT(hspi->Instance->CR2, SPI_CR2_RXDMAEN);
;;;1870   
;;;1871   error:
;;;1872     /* Process Unlocked */
;;;1873     __HAL_UNLOCK(hspi);
;;;1874     return errorcode;
;;;1875   }
00004a  e8bd81f0          POP      {r4-r8,pc}
                  |L16.78|
00004e  bf00              NOP                            ;1791
000050  f8940050          LDRB     r0,[r4,#0x50]         ;1791
000054  2801              CMP      r0,#1                 ;1791
000056  d101              BNE      |L16.92|
000058  2002              MOVS     r0,#2                 ;1791
00005a  e7f6              B        |L16.74|
                  |L16.92|
00005c  2001              MOVS     r0,#1                 ;1791
00005e  f8840050          STRB     r0,[r4,#0x50]         ;1791
000062  bf00              NOP                            ;1791
000064  f8940051          LDRB     r0,[r4,#0x51]         ;1793
000068  2801              CMP      r0,#1                 ;1793
00006a  d001              BEQ      |L16.112|
00006c  2702              MOVS     r7,#2                 ;1795
00006e  e057              B        |L16.288|
                  |L16.112|
000070  b106              CBZ      r6,|L16.116|
000072  b90d              CBNZ     r5,|L16.120|
                  |L16.116|
000074  2701              MOVS     r7,#1                 ;1801
000076  e053              B        |L16.288|
                  |L16.120|
000078  2004              MOVS     r0,#4                 ;1806
00007a  f8840051          STRB     r0,[r4,#0x51]         ;1806
00007e  2000              MOVS     r0,#0                 ;1807
000080  6560              STR      r0,[r4,#0x54]         ;1807
000082  63a6              STR      r6,[r4,#0x38]         ;1808
000084  87a5              STRH     r5,[r4,#0x3c]         ;1809
000086  87e5              STRH     r5,[r4,#0x3e]         ;1810
000088  6420              STR      r0,[r4,#0x40]         ;1813
00008a  6460              STR      r0,[r4,#0x44]         ;1814
00008c  86a0              STRH     r0,[r4,#0x34]         ;1815
00008e  86e0              STRH     r0,[r4,#0x36]         ;1816
000090  68a0              LDR      r0,[r4,#8]            ;1819
000092  f5b04f00          CMP      r0,#0x8000            ;1819
000096  d10b              BNE      |L16.176|
000098  6820              LDR      r0,[r4,#0]            ;1822
00009a  6800              LDR      r0,[r0,#0]            ;1822
00009c  f0200040          BIC      r0,r0,#0x40           ;1822
0000a0  6821              LDR      r1,[r4,#0]            ;1822
0000a2  6008              STR      r0,[r1,#0]            ;1822
0000a4  6820              LDR      r0,[r4,#0]            ;1823
0000a6  6800              LDR      r0,[r0,#0]            ;1823
0000a8  f4204080          BIC      r0,r0,#0x4000         ;1823
0000ac  6821              LDR      r1,[r4,#0]            ;1823
0000ae  6008              STR      r0,[r1,#0]            ;1823
                  |L16.176|
0000b0  482d              LDR      r0,|L16.360|
0000b2  6ce1              LDR      r1,[r4,#0x4c]         ;1835
0000b4  62c8              STR      r0,[r1,#0x2c]         ;1835
0000b6  482d              LDR      r0,|L16.364|
0000b8  6ce1              LDR      r1,[r4,#0x4c]         ;1838
0000ba  6288              STR      r0,[r1,#0x28]         ;1838
0000bc  482c              LDR      r0,|L16.368|
0000be  6ce1              LDR      r1,[r4,#0x4c]         ;1841
0000c0  6308              STR      r0,[r1,#0x30]         ;1841
0000c2  2000              MOVS     r0,#0                 ;1844
0000c4  6ce1              LDR      r1,[r4,#0x4c]         ;1844
0000c6  6348              STR      r0,[r1,#0x34]         ;1844
0000c8  8fe3              LDRH     r3,[r4,#0x3e]         ;1847
0000ca  f8d4c000          LDR      r12,[r4,#0]           ;1847
0000ce  f10c010c          ADD      r1,r12,#0xc           ;1847
0000d2  6ba2              LDR      r2,[r4,#0x38]         ;1847
0000d4  6ce0              LDR      r0,[r4,#0x4c]         ;1847
0000d6  f7fffffe          BL       HAL_DMA_Start_IT
0000da  b140              CBZ      r0,|L16.238|
0000dc  6d60              LDR      r0,[r4,#0x54]         ;1851
0000de  f0400010          ORR      r0,r0,#0x10           ;1851
0000e2  6560              STR      r0,[r4,#0x54]         ;1851
0000e4  2701              MOVS     r7,#1                 ;1852
0000e6  2001              MOVS     r0,#1                 ;1854
0000e8  f8840051          STRB     r0,[r4,#0x51]         ;1854
0000ec  e018              B        |L16.288|
                  |L16.238|
0000ee  6820              LDR      r0,[r4,#0]            ;1859
0000f0  6800              LDR      r0,[r0,#0]            ;1859
0000f2  f0000040          AND      r0,r0,#0x40           ;1859
0000f6  2840              CMP      r0,#0x40              ;1859
0000f8  d005              BEQ      |L16.262|
0000fa  6820              LDR      r0,[r4,#0]            ;1862
0000fc  6800              LDR      r0,[r0,#0]            ;1862
0000fe  f0400040          ORR      r0,r0,#0x40           ;1862
000102  6821              LDR      r1,[r4,#0]            ;1862
000104  6008              STR      r0,[r1,#0]            ;1862
                  |L16.262|
000106  6820              LDR      r0,[r4,#0]            ;1866
000108  6840              LDR      r0,[r0,#4]            ;1866
00010a  f0400020          ORR      r0,r0,#0x20           ;1866
00010e  6821              LDR      r1,[r4,#0]            ;1866
000110  6048              STR      r0,[r1,#4]            ;1866
000112  6820              LDR      r0,[r4,#0]            ;1869
000114  6840              LDR      r0,[r0,#4]            ;1869
000116  f0400001          ORR      r0,r0,#1              ;1869
00011a  6821              LDR      r1,[r4,#0]            ;1869
00011c  6048              STR      r0,[r1,#4]            ;1869
00011e  bf00              NOP                            ;1871
                  |L16.288|
000120  bf00              NOP                            ;1873
000122  2000              MOVS     r0,#0                 ;1873
000124  f8840050          STRB     r0,[r4,#0x50]         ;1873
000128  bf00              NOP                            ;1873
00012a  4638              MOV      r0,r7                 ;1874
00012c  e78d              B        |L16.74|
;;;1876   
                          ENDP

00012e  0000              DCW      0x0000
                  |L16.304|
000130  2e2e2f44          DCB      "../Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_spi.c"
000134  72697665
000138  72732f53
00013c  544d3332
000140  46317878
000144  5f48414c
000148  5f447269
00014c  7665722f
000150  5372632f
000154  73746d33
000158  32663178
00015c  785f6861
000160  6c5f7370
000164  692e63  
000167  00                DCB      0
                  |L16.360|
                          DCD      SPI_DMAHalfReceiveCplt
                  |L16.364|
                          DCD      SPI_DMAReceiveCplt
                  |L16.368|
                          DCD      SPI_DMAError

                          AREA ||i.HAL_SPI_Receive_IT||, CODE, READONLY, ALIGN=2

                  HAL_SPI_Receive_IT PROC
;;;1481     */
;;;1482   HAL_StatusTypeDef HAL_SPI_Receive_IT(SPI_HandleTypeDef *hspi, uint8_t *pData, uint16_t Size)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;1483   {
000004  4604              MOV      r4,r0
000006  460e              MOV      r6,r1
000008  4615              MOV      r5,r2
;;;1484     HAL_StatusTypeDef errorcode = HAL_OK;
00000a  2700              MOVS     r7,#0
;;;1485   
;;;1486     if ((hspi->Init.Direction == SPI_DIRECTION_2LINES) && (hspi->Init.Mode == SPI_MODE_MASTER))
00000c  68a0              LDR      r0,[r4,#8]
00000e  b970              CBNZ     r0,|L17.46|
000010  6860              LDR      r0,[r4,#4]
000012  f5b07f82          CMP      r0,#0x104
000016  d10a              BNE      |L17.46|
;;;1487     {
;;;1488       hspi->State = HAL_SPI_STATE_BUSY_RX;
000018  2004              MOVS     r0,#4
00001a  f8840051          STRB     r0,[r4,#0x51]
;;;1489       /* Call transmit-receive function to send Dummy data on Tx line and generate clock on CLK line */
;;;1490       return HAL_SPI_TransmitReceive_IT(hspi, pData, pData, Size);
00001e  462b              MOV      r3,r5
000020  4632              MOV      r2,r6
000022  4631              MOV      r1,r6
000024  4620              MOV      r0,r4
000026  f7fffffe          BL       HAL_SPI_TransmitReceive_IT
                  |L17.42|
;;;1491     }
;;;1492   
;;;1493     /* Process Locked */
;;;1494     __HAL_LOCK(hspi);
;;;1495   
;;;1496     if (hspi->State != HAL_SPI_STATE_READY)
;;;1497     {
;;;1498       errorcode = HAL_BUSY;
;;;1499       goto error;
;;;1500     }
;;;1501   
;;;1502     if ((pData == NULL) || (Size == 0U))
;;;1503     {
;;;1504       errorcode = HAL_ERROR;
;;;1505       goto error;
;;;1506     }
;;;1507   
;;;1508     /* Set the transaction information */
;;;1509     hspi->State       = HAL_SPI_STATE_BUSY_RX;
;;;1510     hspi->ErrorCode   = HAL_SPI_ERROR_NONE;
;;;1511     hspi->pRxBuffPtr  = (uint8_t *)pData;
;;;1512     hspi->RxXferSize  = Size;
;;;1513     hspi->RxXferCount = Size;
;;;1514   
;;;1515     /* Init field not used in handle to zero */
;;;1516     hspi->pTxBuffPtr  = (uint8_t *)NULL;
;;;1517     hspi->TxXferSize  = 0U;
;;;1518     hspi->TxXferCount = 0U;
;;;1519     hspi->TxISR       = NULL;
;;;1520   
;;;1521     /* Set the function for IT treatment */
;;;1522     if (hspi->Init.DataSize > SPI_DATASIZE_8BIT)
;;;1523     {
;;;1524       hspi->RxISR = SPI_RxISR_16BIT;
;;;1525     }
;;;1526     else
;;;1527     {
;;;1528       hspi->RxISR = SPI_RxISR_8BIT;
;;;1529     }
;;;1530   
;;;1531     /* Configure communication direction : 1Line */
;;;1532     if (hspi->Init.Direction == SPI_DIRECTION_1LINE)
;;;1533     {
;;;1534       /* Disable SPI Peripheral before set 1Line direction (BIDIOE bit) */
;;;1535       __HAL_SPI_DISABLE(hspi);
;;;1536       SPI_1LINE_RX(hspi);
;;;1537     }
;;;1538   
;;;1539   #if (USE_SPI_CRC != 0U)
;;;1540     /* Reset CRC Calculation */
;;;1541     if (hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
;;;1542     {
;;;1543       SPI_RESET_CRC(hspi);
;;;1544     }
;;;1545   #endif /* USE_SPI_CRC */
;;;1546   
;;;1547     /* Enable TXE and ERR interrupt */
;;;1548     __HAL_SPI_ENABLE_IT(hspi, (SPI_IT_RXNE | SPI_IT_ERR));
;;;1549   
;;;1550     /* Note : The SPI must be enabled after unlocking current process
;;;1551               to avoid the risk of SPI interrupt handle execution before current
;;;1552               process unlock */
;;;1553   
;;;1554     /* Check if the SPI is already enabled */
;;;1555     if ((hspi->Instance->CR1 & SPI_CR1_SPE) != SPI_CR1_SPE)
;;;1556     {
;;;1557       /* Enable SPI peripheral */
;;;1558       __HAL_SPI_ENABLE(hspi);
;;;1559     }
;;;1560   
;;;1561   error :
;;;1562     /* Process Unlocked */
;;;1563     __HAL_UNLOCK(hspi);
;;;1564     return errorcode;
;;;1565   }
00002a  e8bd81f0          POP      {r4-r8,pc}
                  |L17.46|
00002e  bf00              NOP                            ;1494
000030  f8940050          LDRB     r0,[r4,#0x50]         ;1494
000034  2801              CMP      r0,#1                 ;1494
000036  d101              BNE      |L17.60|
000038  2002              MOVS     r0,#2                 ;1494
00003a  e7f6              B        |L17.42|
                  |L17.60|
00003c  2001              MOVS     r0,#1                 ;1494
00003e  f8840050          STRB     r0,[r4,#0x50]         ;1494
000042  bf00              NOP                            ;1494
000044  f8940051          LDRB     r0,[r4,#0x51]         ;1496
000048  2801              CMP      r0,#1                 ;1496
00004a  d001              BEQ      |L17.80|
00004c  2702              MOVS     r7,#2                 ;1498
00004e  e039              B        |L17.196|
                  |L17.80|
000050  b106              CBZ      r6,|L17.84|
000052  b90d              CBNZ     r5,|L17.88|
                  |L17.84|
000054  2701              MOVS     r7,#1                 ;1504
000056  e035              B        |L17.196|
                  |L17.88|
000058  2004              MOVS     r0,#4                 ;1509
00005a  f8840051          STRB     r0,[r4,#0x51]         ;1509
00005e  2000              MOVS     r0,#0                 ;1510
000060  6560              STR      r0,[r4,#0x54]         ;1510
000062  63a6              STR      r6,[r4,#0x38]         ;1511
000064  87a5              STRH     r5,[r4,#0x3c]         ;1512
000066  87e5              STRH     r5,[r4,#0x3e]         ;1513
000068  6320              STR      r0,[r4,#0x30]         ;1516
00006a  86a0              STRH     r0,[r4,#0x34]         ;1517
00006c  86e0              STRH     r0,[r4,#0x36]         ;1518
00006e  6460              STR      r0,[r4,#0x44]         ;1519
000070  68e0              LDR      r0,[r4,#0xc]          ;1522
000072  b110              CBZ      r0,|L17.122|
000074  4817              LDR      r0,|L17.212|
000076  6420              STR      r0,[r4,#0x40]         ;1524
000078  e001              B        |L17.126|
                  |L17.122|
00007a  4817              LDR      r0,|L17.216|
00007c  6420              STR      r0,[r4,#0x40]         ;1528
                  |L17.126|
00007e  68a0              LDR      r0,[r4,#8]            ;1532
000080  f5b04f00          CMP      r0,#0x8000            ;1532
000084  d10b              BNE      |L17.158|
000086  6820              LDR      r0,[r4,#0]            ;1535
000088  6800              LDR      r0,[r0,#0]            ;1535
00008a  f0200040          BIC      r0,r0,#0x40           ;1535
00008e  6821              LDR      r1,[r4,#0]            ;1535
000090  6008              STR      r0,[r1,#0]            ;1535
000092  6820              LDR      r0,[r4,#0]            ;1536
000094  6800              LDR      r0,[r0,#0]            ;1536
000096  f4204080          BIC      r0,r0,#0x4000         ;1536
00009a  6821              LDR      r1,[r4,#0]            ;1536
00009c  6008              STR      r0,[r1,#0]            ;1536
                  |L17.158|
00009e  6820              LDR      r0,[r4,#0]            ;1548
0000a0  6840              LDR      r0,[r0,#4]            ;1548
0000a2  f0400060          ORR      r0,r0,#0x60           ;1548
0000a6  6821              LDR      r1,[r4,#0]            ;1548
0000a8  6048              STR      r0,[r1,#4]            ;1548
0000aa  6820              LDR      r0,[r4,#0]            ;1555
0000ac  6800              LDR      r0,[r0,#0]            ;1555
0000ae  f0000040          AND      r0,r0,#0x40           ;1555
0000b2  2840              CMP      r0,#0x40              ;1555
0000b4  d005              BEQ      |L17.194|
0000b6  6820              LDR      r0,[r4,#0]            ;1558
0000b8  6800              LDR      r0,[r0,#0]            ;1558
0000ba  f0400040          ORR      r0,r0,#0x40           ;1558
0000be  6821              LDR      r1,[r4,#0]            ;1558
0000c0  6008              STR      r0,[r1,#0]            ;1558
                  |L17.194|
0000c2  bf00              NOP                            ;1561
                  |L17.196|
0000c4  bf00              NOP                            ;1563
0000c6  2000              MOVS     r0,#0                 ;1563
0000c8  f8840050          STRB     r0,[r4,#0x50]         ;1563
0000cc  bf00              NOP                            ;1563
0000ce  4638              MOV      r0,r7                 ;1564
0000d0  e7ab              B        |L17.42|
;;;1566   
                          ENDP

0000d2  0000              DCW      0x0000
                  |L17.212|
                          DCD      SPI_RxISR_16BIT
                  |L17.216|
                          DCD      SPI_RxISR_8BIT

                          AREA ||i.HAL_SPI_RxCpltCallback||, CODE, READONLY, ALIGN=1

                  HAL_SPI_RxCpltCallback PROC
;;;2534     */
;;;2535   __weak void HAL_SPI_RxCpltCallback(SPI_HandleTypeDef *hspi)
000000  4770              BX       lr
;;;2536   {
;;;2537     /* Prevent unused argument(s) compilation warning */
;;;2538     UNUSED(hspi);
;;;2539   
;;;2540     /* NOTE : This function should not be modified, when the callback is needed,
;;;2541               the HAL_SPI_RxCpltCallback should be implemented in the user file
;;;2542      */
;;;2543   }
;;;2544   
                          ENDP


                          AREA ||i.HAL_SPI_RxHalfCpltCallback||, CODE, READONLY, ALIGN=1

                  HAL_SPI_RxHalfCpltCallback PROC
;;;2582     */
;;;2583   __weak void HAL_SPI_RxHalfCpltCallback(SPI_HandleTypeDef *hspi)
000000  4770              BX       lr
;;;2584   {
;;;2585     /* Prevent unused argument(s) compilation warning */
;;;2586     UNUSED(hspi);
;;;2587   
;;;2588     /* NOTE : This function should not be modified, when the callback is needed,
;;;2589               the HAL_SPI_RxHalfCpltCallback() should be implemented in the user file
;;;2590      */
;;;2591   }
;;;2592   
                          ENDP


                          AREA ||i.HAL_SPI_Transmit||, CODE, READONLY, ALIGN=2

                  HAL_SPI_Transmit PROC
;;;794      */
;;;795    HAL_StatusTypeDef HAL_SPI_Transmit(SPI_HandleTypeDef *hspi, uint8_t *pData, uint16_t Size, uint32_t Timeout)
000000  e92d4ff8          PUSH     {r3-r11,lr}
;;;796    {
000004  4604              MOV      r4,r0
000006  4688              MOV      r8,r1
000008  4616              MOV      r6,r2
00000a  461d              MOV      r5,r3
;;;797      uint32_t tickstart;
;;;798      HAL_StatusTypeDef errorcode = HAL_OK;
00000c  f04f0a00          MOV      r10,#0
;;;799      uint16_t initial_TxXferCount;
;;;800    
;;;801      /* Check Direction parameter */
;;;802      assert_param(IS_SPI_DIRECTION_2LINES_OR_1LINE(hspi->Init.Direction));
000010  68a0              LDR      r0,[r4,#8]
000012  b118              CBZ      r0,|L20.28|
000014  68a0              LDR      r0,[r4,#8]
000016  f5b04f00          CMP      r0,#0x8000
00001a  d100              BNE      |L20.30|
                  |L20.28|
00001c  e004              B        |L20.40|
                  |L20.30|
00001e  f2403122          MOV      r1,#0x322
000022  a069              ADR      r0,|L20.456|
000024  f7fffffe          BL       assert_failed
                  |L20.40|
;;;803    
;;;804      /* Process Locked */
;;;805      __HAL_LOCK(hspi);
000028  bf00              NOP      
00002a  f8940050          LDRB     r0,[r4,#0x50]
00002e  2801              CMP      r0,#1
000030  d102              BNE      |L20.56|
000032  2002              MOVS     r0,#2
                  |L20.52|
;;;806    
;;;807      /* Init tickstart for timeout management*/
;;;808      tickstart = HAL_GetTick();
;;;809      initial_TxXferCount = Size;
;;;810    
;;;811      if (hspi->State != HAL_SPI_STATE_READY)
;;;812      {
;;;813        errorcode = HAL_BUSY;
;;;814        goto error;
;;;815      }
;;;816    
;;;817      if ((pData == NULL) || (Size == 0U))
;;;818      {
;;;819        errorcode = HAL_ERROR;
;;;820        goto error;
;;;821      }
;;;822    
;;;823      /* Set the transaction information */
;;;824      hspi->State       = HAL_SPI_STATE_BUSY_TX;
;;;825      hspi->ErrorCode   = HAL_SPI_ERROR_NONE;
;;;826      hspi->pTxBuffPtr  = (uint8_t *)pData;
;;;827      hspi->TxXferSize  = Size;
;;;828      hspi->TxXferCount = Size;
;;;829    
;;;830      /*Init field not used in handle to zero */
;;;831      hspi->pRxBuffPtr  = (uint8_t *)NULL;
;;;832      hspi->RxXferSize  = 0U;
;;;833      hspi->RxXferCount = 0U;
;;;834      hspi->TxISR       = NULL;
;;;835      hspi->RxISR       = NULL;
;;;836    
;;;837      /* Configure communication direction : 1Line */
;;;838      if (hspi->Init.Direction == SPI_DIRECTION_1LINE)
;;;839      {
;;;840        /* Disable SPI Peripheral before set 1Line direction (BIDIOE bit) */
;;;841        __HAL_SPI_DISABLE(hspi);
;;;842        SPI_1LINE_TX(hspi);
;;;843      }
;;;844    
;;;845    #if (USE_SPI_CRC != 0U)
;;;846      /* Reset CRC Calculation */
;;;847      if (hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
;;;848      {
;;;849        SPI_RESET_CRC(hspi);
;;;850      }
;;;851    #endif /* USE_SPI_CRC */
;;;852    
;;;853      /* Check if the SPI is already enabled */
;;;854      if ((hspi->Instance->CR1 & SPI_CR1_SPE) != SPI_CR1_SPE)
;;;855      {
;;;856        /* Enable SPI peripheral */
;;;857        __HAL_SPI_ENABLE(hspi);
;;;858      }
;;;859    
;;;860      /* Transmit data in 16 Bit mode */
;;;861      if (hspi->Init.DataSize == SPI_DATASIZE_16BIT)
;;;862      {
;;;863        if ((hspi->Init.Mode == SPI_MODE_SLAVE) || (initial_TxXferCount == 0x01U))
;;;864        {
;;;865          hspi->Instance->DR = *((uint16_t *)hspi->pTxBuffPtr);
;;;866          hspi->pTxBuffPtr += sizeof(uint16_t);
;;;867          hspi->TxXferCount--;
;;;868        }
;;;869        /* Transmit data in 16 Bit mode */
;;;870        while (hspi->TxXferCount > 0U)
;;;871        {
;;;872          /* Wait until TXE flag is set to send data */
;;;873          if (__HAL_SPI_GET_FLAG(hspi, SPI_FLAG_TXE))
;;;874          {
;;;875            hspi->Instance->DR = *((uint16_t *)hspi->pTxBuffPtr);
;;;876            hspi->pTxBuffPtr += sizeof(uint16_t);
;;;877            hspi->TxXferCount--;
;;;878          }
;;;879          else
;;;880          {
;;;881            /* Timeout management */
;;;882            if ((((HAL_GetTick() - tickstart) >=  Timeout) && (Timeout != HAL_MAX_DELAY)) || (Timeout == 0U))
;;;883            {
;;;884              errorcode = HAL_TIMEOUT;
;;;885              goto error;
;;;886            }
;;;887          }
;;;888        }
;;;889      }
;;;890      /* Transmit data in 8 Bit mode */
;;;891      else
;;;892      {
;;;893        if ((hspi->Init.Mode == SPI_MODE_SLAVE) || (initial_TxXferCount == 0x01U))
;;;894        {
;;;895          *((__IO uint8_t *)&hspi->Instance->DR) = (*hspi->pTxBuffPtr);
;;;896          hspi->pTxBuffPtr += sizeof(uint8_t);
;;;897          hspi->TxXferCount--;
;;;898        }
;;;899        while (hspi->TxXferCount > 0U)
;;;900        {
;;;901          /* Wait until TXE flag is set to send data */
;;;902          if (__HAL_SPI_GET_FLAG(hspi, SPI_FLAG_TXE))
;;;903          {
;;;904            *((__IO uint8_t *)&hspi->Instance->DR) = (*hspi->pTxBuffPtr);
;;;905            hspi->pTxBuffPtr += sizeof(uint8_t);
;;;906            hspi->TxXferCount--;
;;;907          }
;;;908          else
;;;909          {
;;;910            /* Timeout management */
;;;911            if ((((HAL_GetTick() - tickstart) >=  Timeout) && (Timeout != HAL_MAX_DELAY)) || (Timeout == 0U))
;;;912            {
;;;913              errorcode = HAL_TIMEOUT;
;;;914              goto error;
;;;915            }
;;;916          }
;;;917        }
;;;918      }
;;;919    #if (USE_SPI_CRC != 0U)
;;;920      /* Enable CRC Transmission */
;;;921      if (hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
;;;922      {
;;;923        SET_BIT(hspi->Instance->CR1, SPI_CR1_CRCNEXT);
;;;924      }
;;;925    #endif /* USE_SPI_CRC */
;;;926    
;;;927      /* Check the end of the transaction */
;;;928      if (SPI_EndRxTxTransaction(hspi, Timeout, tickstart) != HAL_OK)
;;;929      {
;;;930        hspi->ErrorCode = HAL_SPI_ERROR_FLAG;
;;;931      }
;;;932    
;;;933      /* Clear overrun flag in 2 Lines communication mode because received is not read */
;;;934      if (hspi->Init.Direction == SPI_DIRECTION_2LINES)
;;;935      {
;;;936        __HAL_SPI_CLEAR_OVRFLAG(hspi);
;;;937      }
;;;938    
;;;939      if (hspi->ErrorCode != HAL_SPI_ERROR_NONE)
;;;940      {
;;;941        errorcode = HAL_ERROR;
;;;942      }
;;;943    
;;;944    error:
;;;945      hspi->State = HAL_SPI_STATE_READY;
;;;946      /* Process Unlocked */
;;;947      __HAL_UNLOCK(hspi);
;;;948      return errorcode;
;;;949    }
000034  e8bd8ff8          POP      {r3-r11,pc}
                  |L20.56|
000038  2001              MOVS     r0,#1                 ;805
00003a  f8840050          STRB     r0,[r4,#0x50]         ;805
00003e  bf00              NOP                            ;805
000040  f7fffffe          BL       HAL_GetTick
000044  4607              MOV      r7,r0                 ;808
000046  46b1              MOV      r9,r6                 ;809
000048  f8940051          LDRB     r0,[r4,#0x51]         ;811
00004c  2801              CMP      r0,#1                 ;811
00004e  d002              BEQ      |L20.86|
000050  f04f0a02          MOV      r10,#2                ;813
000054  e0ad              B        |L20.434|
                  |L20.86|
000056  f1b80f00          CMP      r8,#0                 ;817
00005a  d000              BEQ      |L20.94|
00005c  b916              CBNZ     r6,|L20.100|
                  |L20.94|
00005e  f04f0a01          MOV      r10,#1                ;819
000062  e0a6              B        |L20.434|
                  |L20.100|
000064  2003              MOVS     r0,#3                 ;824
000066  f8840051          STRB     r0,[r4,#0x51]         ;824
00006a  2000              MOVS     r0,#0                 ;825
00006c  6560              STR      r0,[r4,#0x54]         ;825
00006e  f8c48030          STR      r8,[r4,#0x30]         ;826
000072  86a6              STRH     r6,[r4,#0x34]         ;827
000074  86e6              STRH     r6,[r4,#0x36]         ;828
000076  63a0              STR      r0,[r4,#0x38]         ;831
000078  87a0              STRH     r0,[r4,#0x3c]         ;832
00007a  87e0              STRH     r0,[r4,#0x3e]         ;833
00007c  6460              STR      r0,[r4,#0x44]         ;834
00007e  6420              STR      r0,[r4,#0x40]         ;835
000080  68a0              LDR      r0,[r4,#8]            ;838
000082  f5b04f00          CMP      r0,#0x8000            ;838
000086  d10b              BNE      |L20.160|
000088  6820              LDR      r0,[r4,#0]            ;841
00008a  6800              LDR      r0,[r0,#0]            ;841
00008c  f0200040          BIC      r0,r0,#0x40           ;841
000090  6821              LDR      r1,[r4,#0]            ;841
000092  6008              STR      r0,[r1,#0]            ;841
000094  6820              LDR      r0,[r4,#0]            ;842
000096  6800              LDR      r0,[r0,#0]            ;842
000098  f4404080          ORR      r0,r0,#0x4000         ;842
00009c  6821              LDR      r1,[r4,#0]            ;842
00009e  6008              STR      r0,[r1,#0]            ;842
                  |L20.160|
0000a0  6820              LDR      r0,[r4,#0]            ;854
0000a2  6800              LDR      r0,[r0,#0]            ;854
0000a4  f0000040          AND      r0,r0,#0x40           ;854
0000a8  2840              CMP      r0,#0x40              ;854
0000aa  d005              BEQ      |L20.184|
0000ac  6820              LDR      r0,[r4,#0]            ;857
0000ae  6800              LDR      r0,[r0,#0]            ;857
0000b0  f0400040          ORR      r0,r0,#0x40           ;857
0000b4  6821              LDR      r1,[r4,#0]            ;857
0000b6  6008              STR      r0,[r1,#0]            ;857
                  |L20.184|
0000b8  68e0              LDR      r0,[r4,#0xc]          ;861
0000ba  f5b06f00          CMP      r0,#0x800             ;861
0000be  d12f              BNE      |L20.288|
0000c0  6860              LDR      r0,[r4,#4]            ;863
0000c2  b110              CBZ      r0,|L20.202|
0000c4  f1b90f01          CMP      r9,#1                 ;863
0000c8  d109              BNE      |L20.222|
                  |L20.202|
0000ca  6b20              LDR      r0,[r4,#0x30]         ;865
0000cc  8800              LDRH     r0,[r0,#0]            ;865
0000ce  6821              LDR      r1,[r4,#0]            ;865
0000d0  60c8              STR      r0,[r1,#0xc]          ;865
0000d2  6b20              LDR      r0,[r4,#0x30]         ;866
0000d4  1c80              ADDS     r0,r0,#2              ;866
0000d6  6320              STR      r0,[r4,#0x30]         ;866
0000d8  8ee0              LDRH     r0,[r4,#0x36]         ;867
0000da  1e40              SUBS     r0,r0,#1              ;867
0000dc  86e0              STRH     r0,[r4,#0x36]         ;867
                  |L20.222|
0000de  e01b              B        |L20.280|
                  |L20.224|
0000e0  6820              LDR      r0,[r4,#0]            ;873
0000e2  6880              LDR      r0,[r0,#8]            ;873
0000e4  f0000002          AND      r0,r0,#2              ;873
0000e8  2802              CMP      r0,#2                 ;873
0000ea  d10a              BNE      |L20.258|
0000ec  6b20              LDR      r0,[r4,#0x30]         ;875
0000ee  8800              LDRH     r0,[r0,#0]            ;875
0000f0  6821              LDR      r1,[r4,#0]            ;875
0000f2  60c8              STR      r0,[r1,#0xc]          ;875
0000f4  6b20              LDR      r0,[r4,#0x30]         ;876
0000f6  1c80              ADDS     r0,r0,#2              ;876
0000f8  6320              STR      r0,[r4,#0x30]         ;876
0000fa  8ee0              LDRH     r0,[r4,#0x36]         ;877
0000fc  1e40              SUBS     r0,r0,#1              ;877
0000fe  86e0              STRH     r0,[r4,#0x36]         ;877
000100  e00a              B        |L20.280|
                  |L20.258|
000102  f7fffffe          BL       HAL_GetTick
000106  1bc0              SUBS     r0,r0,r7              ;882
000108  42a8              CMP      r0,r5                 ;882
00010a  d301              BCC      |L20.272|
00010c  1c68              ADDS     r0,r5,#1              ;882
00010e  b900              CBNZ     r0,|L20.274|
                  |L20.272|
000110  b915              CBNZ     r5,|L20.280|
                  |L20.274|
000112  f04f0a03          MOV      r10,#3                ;884
000116  e04c              B        |L20.434|
                  |L20.280|
000118  8ee0              LDRH     r0,[r4,#0x36]         ;870
00011a  2800              CMP      r0,#0                 ;870
00011c  d1e0              BNE      |L20.224|
00011e  e02e              B        |L20.382|
                  |L20.288|
000120  6860              LDR      r0,[r4,#4]            ;893
000122  b110              CBZ      r0,|L20.298|
000124  f1b90f01          CMP      r9,#1                 ;893
000128  d109              BNE      |L20.318|
                  |L20.298|
00012a  6b20              LDR      r0,[r4,#0x30]         ;895
00012c  7800              LDRB     r0,[r0,#0]            ;895
00012e  6821              LDR      r1,[r4,#0]            ;895
000130  7308              STRB     r0,[r1,#0xc]          ;895
000132  6b20              LDR      r0,[r4,#0x30]         ;896
000134  1c40              ADDS     r0,r0,#1              ;896
000136  6320              STR      r0,[r4,#0x30]         ;896
000138  8ee0              LDRH     r0,[r4,#0x36]         ;897
00013a  1e40              SUBS     r0,r0,#1              ;897
00013c  86e0              STRH     r0,[r4,#0x36]         ;897
                  |L20.318|
00013e  e01b              B        |L20.376|
                  |L20.320|
000140  6820              LDR      r0,[r4,#0]            ;902
000142  6880              LDR      r0,[r0,#8]            ;902
000144  f0000002          AND      r0,r0,#2              ;902
000148  2802              CMP      r0,#2                 ;902
00014a  d10a              BNE      |L20.354|
00014c  6b20              LDR      r0,[r4,#0x30]         ;904
00014e  7800              LDRB     r0,[r0,#0]            ;904
000150  6821              LDR      r1,[r4,#0]            ;904
000152  7308              STRB     r0,[r1,#0xc]          ;904
000154  6b20              LDR      r0,[r4,#0x30]         ;905
000156  1c40              ADDS     r0,r0,#1              ;905
000158  6320              STR      r0,[r4,#0x30]         ;905
00015a  8ee0              LDRH     r0,[r4,#0x36]         ;906
00015c  1e40              SUBS     r0,r0,#1              ;906
00015e  86e0              STRH     r0,[r4,#0x36]         ;906
000160  e00a              B        |L20.376|
                  |L20.354|
000162  f7fffffe          BL       HAL_GetTick
000166  1bc0              SUBS     r0,r0,r7              ;911
000168  42a8              CMP      r0,r5                 ;911
00016a  d301              BCC      |L20.368|
00016c  1c68              ADDS     r0,r5,#1              ;911
00016e  b900              CBNZ     r0,|L20.370|
                  |L20.368|
000170  b915              CBNZ     r5,|L20.376|
                  |L20.370|
000172  f04f0a03          MOV      r10,#3                ;913
000176  e01c              B        |L20.434|
                  |L20.376|
000178  8ee0              LDRH     r0,[r4,#0x36]         ;899
00017a  2800              CMP      r0,#0                 ;899
00017c  d1e0              BNE      |L20.320|
                  |L20.382|
00017e  463a              MOV      r2,r7                 ;928
000180  4629              MOV      r1,r5                 ;928
000182  4620              MOV      r0,r4                 ;928
000184  f7fffffe          BL       SPI_EndRxTxTransaction
000188  b108              CBZ      r0,|L20.398|
00018a  2020              MOVS     r0,#0x20              ;930
00018c  6560              STR      r0,[r4,#0x54]         ;930
                  |L20.398|
00018e  68a0              LDR      r0,[r4,#8]            ;934
000190  b950              CBNZ     r0,|L20.424|
000192  bf00              NOP                            ;936
000194  2000              MOVS     r0,#0                 ;936
000196  9000              STR      r0,[sp,#0]            ;936
000198  6820              LDR      r0,[r4,#0]            ;936
00019a  68c0              LDR      r0,[r0,#0xc]          ;936
00019c  9000              STR      r0,[sp,#0]            ;936
00019e  6820              LDR      r0,[r4,#0]            ;936
0001a0  6880              LDR      r0,[r0,#8]            ;936
0001a2  9000              STR      r0,[sp,#0]            ;936
0001a4  bf00              NOP                            ;936
0001a6  bf00              NOP                            ;936
                  |L20.424|
0001a8  6d60              LDR      r0,[r4,#0x54]         ;939
0001aa  b108              CBZ      r0,|L20.432|
0001ac  f04f0a01          MOV      r10,#1                ;941
                  |L20.432|
0001b0  bf00              NOP                            ;944
                  |L20.434|
0001b2  2001              MOVS     r0,#1                 ;945
0001b4  f8840051          STRB     r0,[r4,#0x51]         ;945
0001b8  bf00              NOP                            ;947
0001ba  2000              MOVS     r0,#0                 ;947
0001bc  f8840050          STRB     r0,[r4,#0x50]         ;947
0001c0  bf00              NOP                            ;947
0001c2  4650              MOV      r0,r10                ;948
0001c4  e736              B        |L20.52|
;;;950    
                          ENDP

0001c6  0000              DCW      0x0000
                  |L20.456|
0001c8  2e2e2f44          DCB      "../Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_spi.c"
0001cc  72697665
0001d0  72732f53
0001d4  544d3332
0001d8  46317878
0001dc  5f48414c
0001e0  5f447269
0001e4  7665722f
0001e8  5372632f
0001ec  73746d33
0001f0  32663178
0001f4  785f6861
0001f8  6c5f7370
0001fc  692e63  
0001ff  00                DCB      0

                          AREA ||i.HAL_SPI_TransmitReceive||, CODE, READONLY, ALIGN=2

                  HAL_SPI_TransmitReceive PROC
;;;1168     */
;;;1169   HAL_StatusTypeDef HAL_SPI_TransmitReceive(SPI_HandleTypeDef *hspi, uint8_t *pTxData, uint8_t *pRxData, uint16_t Size,
000000  e92d5fff          PUSH     {r0-r12,lr}
;;;1170                                             uint32_t Timeout)
;;;1171   {
000004  4604              MOV      r4,r0
000006  4688              MOV      r8,r1
000008  4691              MOV      r9,r2
00000a  461d              MOV      r5,r3
00000c  9e0e              LDR      r6,[sp,#0x38]
;;;1172     uint16_t             initial_TxXferCount;
;;;1173     uint32_t             tmp_mode;
;;;1174     HAL_SPI_StateTypeDef tmp_state;
;;;1175     uint32_t             tickstart;
;;;1176   
;;;1177     /* Variable used to alternate Rx and Tx during transfer */
;;;1178     uint32_t             txallowed = 1U;
00000e  2001              MOVS     r0,#1
000010  9002              STR      r0,[sp,#8]
;;;1179     HAL_StatusTypeDef    errorcode = HAL_OK;
000012  2000              MOVS     r0,#0
000014  9001              STR      r0,[sp,#4]
;;;1180   
;;;1181     /* Check Direction parameter */
;;;1182     assert_param(IS_SPI_DIRECTION_2LINES(hspi->Init.Direction));
000016  68a0              LDR      r0,[r4,#8]
000018  b900              CBNZ     r0,|L21.28|
00001a  e004              B        |L21.38|
                  |L21.28|
00001c  f240419e          MOV      r1,#0x49e
000020  a086              ADR      r0,|L21.572|
000022  f7fffffe          BL       assert_failed
                  |L21.38|
;;;1183   
;;;1184     /* Process Locked */
;;;1185     __HAL_LOCK(hspi);
000026  bf00              NOP      
000028  f8940050          LDRB     r0,[r4,#0x50]
00002c  2801              CMP      r0,#1
00002e  d103              BNE      |L21.56|
000030  2002              MOVS     r0,#2
                  |L21.50|
;;;1186   
;;;1187     /* Init tickstart for timeout management*/
;;;1188     tickstart = HAL_GetTick();
;;;1189   
;;;1190     /* Init temporary variables */
;;;1191     tmp_state           = hspi->State;
;;;1192     tmp_mode            = hspi->Init.Mode;
;;;1193     initial_TxXferCount = Size;
;;;1194   
;;;1195     if (!((tmp_state == HAL_SPI_STATE_READY) || \
;;;1196           ((tmp_mode == SPI_MODE_MASTER) && (hspi->Init.Direction == SPI_DIRECTION_2LINES) && (tmp_state == HAL_SPI_STATE_BUSY_RX))))
;;;1197     {
;;;1198       errorcode = HAL_BUSY;
;;;1199       goto error;
;;;1200     }
;;;1201   
;;;1202     if ((pTxData == NULL) || (pRxData == NULL) || (Size == 0U))
;;;1203     {
;;;1204       errorcode = HAL_ERROR;
;;;1205       goto error;
;;;1206     }
;;;1207   
;;;1208     /* Don't overwrite in case of HAL_SPI_STATE_BUSY_RX */
;;;1209     if (hspi->State != HAL_SPI_STATE_BUSY_RX)
;;;1210     {
;;;1211       hspi->State = HAL_SPI_STATE_BUSY_TX_RX;
;;;1212     }
;;;1213   
;;;1214     /* Set the transaction information */
;;;1215     hspi->ErrorCode   = HAL_SPI_ERROR_NONE;
;;;1216     hspi->pRxBuffPtr  = (uint8_t *)pRxData;
;;;1217     hspi->RxXferCount = Size;
;;;1218     hspi->RxXferSize  = Size;
;;;1219     hspi->pTxBuffPtr  = (uint8_t *)pTxData;
;;;1220     hspi->TxXferCount = Size;
;;;1221     hspi->TxXferSize  = Size;
;;;1222   
;;;1223     /*Init field not used in handle to zero */
;;;1224     hspi->RxISR       = NULL;
;;;1225     hspi->TxISR       = NULL;
;;;1226   
;;;1227   #if (USE_SPI_CRC != 0U)
;;;1228     /* Reset CRC Calculation */
;;;1229     if (hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
;;;1230     {
;;;1231       SPI_RESET_CRC(hspi);
;;;1232     }
;;;1233   #endif /* USE_SPI_CRC */
;;;1234   
;;;1235     /* Check if the SPI is already enabled */
;;;1236     if ((hspi->Instance->CR1 & SPI_CR1_SPE) != SPI_CR1_SPE)
;;;1237     {
;;;1238       /* Enable SPI peripheral */
;;;1239       __HAL_SPI_ENABLE(hspi);
;;;1240     }
;;;1241   
;;;1242     /* Transmit and Receive data in 16 Bit mode */
;;;1243     if (hspi->Init.DataSize == SPI_DATASIZE_16BIT)
;;;1244     {
;;;1245       if ((hspi->Init.Mode == SPI_MODE_SLAVE) || (initial_TxXferCount == 0x01U))
;;;1246       {
;;;1247         hspi->Instance->DR = *((uint16_t *)hspi->pTxBuffPtr);
;;;1248         hspi->pTxBuffPtr += sizeof(uint16_t);
;;;1249         hspi->TxXferCount--;
;;;1250       }
;;;1251       while ((hspi->TxXferCount > 0U) || (hspi->RxXferCount > 0U))
;;;1252       {
;;;1253         /* Check TXE flag */
;;;1254         if ((__HAL_SPI_GET_FLAG(hspi, SPI_FLAG_TXE)) && (hspi->TxXferCount > 0U) && (txallowed == 1U))
;;;1255         {
;;;1256           hspi->Instance->DR = *((uint16_t *)hspi->pTxBuffPtr);
;;;1257           hspi->pTxBuffPtr += sizeof(uint16_t);
;;;1258           hspi->TxXferCount--;
;;;1259           /* Next Data is a reception (Rx). Tx not allowed */
;;;1260           txallowed = 0U;
;;;1261   
;;;1262   #if (USE_SPI_CRC != 0U)
;;;1263           /* Enable CRC Transmission */
;;;1264           if ((hspi->TxXferCount == 0U) && (hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE))
;;;1265           {
;;;1266             SET_BIT(hspi->Instance->CR1, SPI_CR1_CRCNEXT);
;;;1267           }
;;;1268   #endif /* USE_SPI_CRC */
;;;1269         }
;;;1270   
;;;1271         /* Check RXNE flag */
;;;1272         if ((__HAL_SPI_GET_FLAG(hspi, SPI_FLAG_RXNE)) && (hspi->RxXferCount > 0U))
;;;1273         {
;;;1274           *((uint16_t *)hspi->pRxBuffPtr) = (uint16_t)hspi->Instance->DR;
;;;1275           hspi->pRxBuffPtr += sizeof(uint16_t);
;;;1276           hspi->RxXferCount--;
;;;1277           /* Next Data is a Transmission (Tx). Tx is allowed */
;;;1278           txallowed = 1U;
;;;1279         }
;;;1280         if (((HAL_GetTick() - tickstart) >=  Timeout) && (Timeout != HAL_MAX_DELAY))
;;;1281         {
;;;1282           errorcode = HAL_TIMEOUT;
;;;1283           goto error;
;;;1284         }
;;;1285       }
;;;1286     }
;;;1287     /* Transmit and Receive data in 8 Bit mode */
;;;1288     else
;;;1289     {
;;;1290       if ((hspi->Init.Mode == SPI_MODE_SLAVE) || (initial_TxXferCount == 0x01U))
;;;1291       {
;;;1292         *((__IO uint8_t *)&hspi->Instance->DR) = (*hspi->pTxBuffPtr);
;;;1293         hspi->pTxBuffPtr += sizeof(uint8_t);
;;;1294         hspi->TxXferCount--;
;;;1295       }
;;;1296       while ((hspi->TxXferCount > 0U) || (hspi->RxXferCount > 0U))
;;;1297       {
;;;1298         /* Check TXE flag */
;;;1299         if ((__HAL_SPI_GET_FLAG(hspi, SPI_FLAG_TXE)) && (hspi->TxXferCount > 0U) && (txallowed == 1U))
;;;1300         {
;;;1301           *(__IO uint8_t *)&hspi->Instance->DR = (*hspi->pTxBuffPtr);
;;;1302           hspi->pTxBuffPtr++;
;;;1303           hspi->TxXferCount--;
;;;1304           /* Next Data is a reception (Rx). Tx not allowed */
;;;1305           txallowed = 0U;
;;;1306   
;;;1307   #if (USE_SPI_CRC != 0U)
;;;1308           /* Enable CRC Transmission */
;;;1309           if ((hspi->TxXferCount == 0U) && (hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE))
;;;1310           {
;;;1311             SET_BIT(hspi->Instance->CR1, SPI_CR1_CRCNEXT);
;;;1312           }
;;;1313   #endif /* USE_SPI_CRC */
;;;1314         }
;;;1315   
;;;1316         /* Wait until RXNE flag is reset */
;;;1317         if ((__HAL_SPI_GET_FLAG(hspi, SPI_FLAG_RXNE)) && (hspi->RxXferCount > 0U))
;;;1318         {
;;;1319           (*(uint8_t *)hspi->pRxBuffPtr) = hspi->Instance->DR;
;;;1320           hspi->pRxBuffPtr++;
;;;1321           hspi->RxXferCount--;
;;;1322           /* Next Data is a Transmission (Tx). Tx is allowed */
;;;1323           txallowed = 1U;
;;;1324         }
;;;1325         if ((((HAL_GetTick() - tickstart) >=  Timeout) && ((Timeout != HAL_MAX_DELAY))) || (Timeout == 0U))
;;;1326         {
;;;1327           errorcode = HAL_TIMEOUT;
;;;1328           goto error;
;;;1329         }
;;;1330       }
;;;1331     }
;;;1332   
;;;1333   #if (USE_SPI_CRC != 0U)
;;;1334     /* Read CRC from DR to close CRC calculation process */
;;;1335     if (hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
;;;1336     {
;;;1337       /* Wait until TXE flag */
;;;1338       if (SPI_WaitFlagStateUntilTimeout(hspi, SPI_FLAG_RXNE, SET, Timeout, tickstart) != HAL_OK)
;;;1339       {
;;;1340         /* Error on the CRC reception */
;;;1341         SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_CRC);
;;;1342         errorcode = HAL_TIMEOUT;
;;;1343         goto error;
;;;1344       }
;;;1345       /* Read CRC */
;;;1346       READ_REG(hspi->Instance->DR);
;;;1347     }
;;;1348   
;;;1349     /* Check if CRC error occurred */
;;;1350     if (__HAL_SPI_GET_FLAG(hspi, SPI_FLAG_CRCERR) != RESET)
;;;1351     {
;;;1352       /* Check if CRC error is valid or not (workaround to be applied or not) */
;;;1353       if (SPI_ISCRCErrorValid(hspi) == SPI_VALID_CRC_ERROR)
;;;1354       {
;;;1355         SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_CRC);
;;;1356   
;;;1357         /* Reset CRC Calculation */
;;;1358         SPI_RESET_CRC(hspi);
;;;1359   
;;;1360         errorcode = HAL_ERROR;
;;;1361       }
;;;1362       else
;;;1363       {
;;;1364         __HAL_SPI_CLEAR_CRCERRFLAG(hspi);
;;;1365       }
;;;1366     }
;;;1367   #endif /* USE_SPI_CRC */
;;;1368   
;;;1369     /* Check the end of the transaction */
;;;1370     if (SPI_EndRxTxTransaction(hspi, Timeout, tickstart) != HAL_OK)
;;;1371     {
;;;1372       errorcode = HAL_ERROR;
;;;1373       hspi->ErrorCode = HAL_SPI_ERROR_FLAG;
;;;1374       goto error;
;;;1375     }
;;;1376   
;;;1377     /* Clear overrun flag in 2 Lines communication mode because received is not read */
;;;1378     if (hspi->Init.Direction == SPI_DIRECTION_2LINES)
;;;1379     {
;;;1380       __HAL_SPI_CLEAR_OVRFLAG(hspi);
;;;1381     }
;;;1382   
;;;1383   error :
;;;1384     hspi->State = HAL_SPI_STATE_READY;
;;;1385     __HAL_UNLOCK(hspi);
;;;1386     return errorcode;
;;;1387   }
000032  b004              ADD      sp,sp,#0x10
000034  e8bd9ff0          POP      {r4-r12,pc}
                  |L21.56|
000038  2001              MOVS     r0,#1                 ;1185
00003a  f8840050          STRB     r0,[r4,#0x50]         ;1185
00003e  bf00              NOP                            ;1185
000040  f7fffffe          BL       HAL_GetTick
000044  4607              MOV      r7,r0                 ;1188
000046  f894b051          LDRB     r11,[r4,#0x51]        ;1191
00004a  6860              LDR      r0,[r4,#4]            ;1192
00004c  9003              STR      r0,[sp,#0xc]          ;1192
00004e  46aa              MOV      r10,r5                ;1193
000050  f1bb0f01          CMP      r11,#1                ;1195
000054  d00b              BEQ      |L21.110|
000056  9803              LDR      r0,[sp,#0xc]          ;1195
000058  f5b07f82          CMP      r0,#0x104             ;1195
00005c  d104              BNE      |L21.104|
00005e  68a0              LDR      r0,[r4,#8]            ;1195
000060  b910              CBNZ     r0,|L21.104|
000062  f1bb0f04          CMP      r11,#4                ;1195
000066  d002              BEQ      |L21.110|
                  |L21.104|
000068  2002              MOVS     r0,#2                 ;1198
00006a  9001              STR      r0,[sp,#4]            ;1198
00006c  e0db              B        |L21.550|
                  |L21.110|
00006e  f1b80f00          CMP      r8,#0                 ;1202
000072  d003              BEQ      |L21.124|
000074  f1b90f00          CMP      r9,#0                 ;1202
000078  d000              BEQ      |L21.124|
00007a  b915              CBNZ     r5,|L21.130|
                  |L21.124|
00007c  2001              MOVS     r0,#1                 ;1204
00007e  9001              STR      r0,[sp,#4]            ;1204
000080  e0d1              B        |L21.550|
                  |L21.130|
000082  f8940051          LDRB     r0,[r4,#0x51]         ;1209
000086  2804              CMP      r0,#4                 ;1209
000088  d002              BEQ      |L21.144|
00008a  2005              MOVS     r0,#5                 ;1211
00008c  f8840051          STRB     r0,[r4,#0x51]         ;1211
                  |L21.144|
000090  2000              MOVS     r0,#0                 ;1215
000092  6560              STR      r0,[r4,#0x54]         ;1215
000094  f8c49038          STR      r9,[r4,#0x38]         ;1216
000098  87e5              STRH     r5,[r4,#0x3e]         ;1217
00009a  87a5              STRH     r5,[r4,#0x3c]         ;1218
00009c  f8c48030          STR      r8,[r4,#0x30]         ;1219
0000a0  86e5              STRH     r5,[r4,#0x36]         ;1220
0000a2  86a5              STRH     r5,[r4,#0x34]         ;1221
0000a4  6420              STR      r0,[r4,#0x40]         ;1224
0000a6  6460              STR      r0,[r4,#0x44]         ;1225
0000a8  6820              LDR      r0,[r4,#0]            ;1236
0000aa  6800              LDR      r0,[r0,#0]            ;1236
0000ac  f0000040          AND      r0,r0,#0x40           ;1236
0000b0  2840              CMP      r0,#0x40              ;1236
0000b2  d005              BEQ      |L21.192|
0000b4  6820              LDR      r0,[r4,#0]            ;1239
0000b6  6800              LDR      r0,[r0,#0]            ;1239
0000b8  f0400040          ORR      r0,r0,#0x40           ;1239
0000bc  6821              LDR      r1,[r4,#0]            ;1239
0000be  6008              STR      r0,[r1,#0]            ;1239
                  |L21.192|
0000c0  68e0              LDR      r0,[r4,#0xc]          ;1243
0000c2  f5b06f00          CMP      r0,#0x800             ;1243
0000c6  d14a              BNE      |L21.350|
0000c8  6860              LDR      r0,[r4,#4]            ;1245
0000ca  b110              CBZ      r0,|L21.210|
0000cc  f1ba0f01          CMP      r10,#1                ;1245
0000d0  d109              BNE      |L21.230|
                  |L21.210|
0000d2  6b20              LDR      r0,[r4,#0x30]         ;1247
0000d4  8800              LDRH     r0,[r0,#0]            ;1247
0000d6  6821              LDR      r1,[r4,#0]            ;1247
0000d8  60c8              STR      r0,[r1,#0xc]          ;1247
0000da  6b20              LDR      r0,[r4,#0x30]         ;1248
0000dc  1c80              ADDS     r0,r0,#2              ;1248
0000de  6320              STR      r0,[r4,#0x30]         ;1248
0000e0  8ee0              LDRH     r0,[r4,#0x36]         ;1249
0000e2  1e40              SUBS     r0,r0,#1              ;1249
0000e4  86e0              STRH     r0,[r4,#0x36]         ;1249
                  |L21.230|
0000e6  e033              B        |L21.336|
                  |L21.232|
0000e8  6820              LDR      r0,[r4,#0]            ;1254
0000ea  6880              LDR      r0,[r0,#8]            ;1254
0000ec  f0000002          AND      r0,r0,#2              ;1254
0000f0  2802              CMP      r0,#2                 ;1254
0000f2  d110              BNE      |L21.278|
0000f4  8ee0              LDRH     r0,[r4,#0x36]         ;1254
0000f6  b170              CBZ      r0,|L21.278|
0000f8  9802              LDR      r0,[sp,#8]            ;1254
0000fa  2801              CMP      r0,#1                 ;1254
0000fc  d10b              BNE      |L21.278|
0000fe  6b20              LDR      r0,[r4,#0x30]         ;1256
000100  8800              LDRH     r0,[r0,#0]            ;1256
000102  6821              LDR      r1,[r4,#0]            ;1256
000104  60c8              STR      r0,[r1,#0xc]          ;1256
000106  6b20              LDR      r0,[r4,#0x30]         ;1257
000108  1c80              ADDS     r0,r0,#2              ;1257
00010a  6320              STR      r0,[r4,#0x30]         ;1257
00010c  8ee0              LDRH     r0,[r4,#0x36]         ;1258
00010e  1e40              SUBS     r0,r0,#1              ;1258
000110  86e0              STRH     r0,[r4,#0x36]         ;1258
000112  2000              MOVS     r0,#0                 ;1260
000114  9002              STR      r0,[sp,#8]            ;1260
                  |L21.278|
000116  6820              LDR      r0,[r4,#0]            ;1272
000118  6880              LDR      r0,[r0,#8]            ;1272
00011a  f0000001          AND      r0,r0,#1              ;1272
00011e  b168              CBZ      r0,|L21.316|
000120  8fe0              LDRH     r0,[r4,#0x3e]         ;1272
000122  b158              CBZ      r0,|L21.316|
000124  6820              LDR      r0,[r4,#0]            ;1274
000126  68c0              LDR      r0,[r0,#0xc]          ;1274
000128  6ba1              LDR      r1,[r4,#0x38]         ;1274
00012a  8008              STRH     r0,[r1,#0]            ;1274
00012c  6ba0              LDR      r0,[r4,#0x38]         ;1275
00012e  1c80              ADDS     r0,r0,#2              ;1275
000130  63a0              STR      r0,[r4,#0x38]         ;1275
000132  8fe0              LDRH     r0,[r4,#0x3e]         ;1276
000134  1e40              SUBS     r0,r0,#1              ;1276
000136  87e0              STRH     r0,[r4,#0x3e]         ;1276
000138  2001              MOVS     r0,#1                 ;1278
00013a  9002              STR      r0,[sp,#8]            ;1278
                  |L21.316|
00013c  f7fffffe          BL       HAL_GetTick
000140  1bc0              SUBS     r0,r0,r7              ;1280
000142  42b0              CMP      r0,r6                 ;1280
000144  d304              BCC      |L21.336|
000146  1c70              ADDS     r0,r6,#1              ;1280
000148  b110              CBZ      r0,|L21.336|
00014a  2003              MOVS     r0,#3                 ;1282
00014c  9001              STR      r0,[sp,#4]            ;1282
00014e  e06a              B        |L21.550|
                  |L21.336|
000150  8ee0              LDRH     r0,[r4,#0x36]         ;1251
000152  2800              CMP      r0,#0                 ;1251
000154  d1c8              BNE      |L21.232|
000156  8fe0              LDRH     r0,[r4,#0x3e]         ;1251
000158  2800              CMP      r0,#0                 ;1251
00015a  d1c5              BNE      |L21.232|
00015c  e04a              B        |L21.500|
                  |L21.350|
00015e  6860              LDR      r0,[r4,#4]            ;1290
000160  b110              CBZ      r0,|L21.360|
000162  f1ba0f01          CMP      r10,#1                ;1290
000166  d109              BNE      |L21.380|
                  |L21.360|
000168  6b20              LDR      r0,[r4,#0x30]         ;1292
00016a  7800              LDRB     r0,[r0,#0]            ;1292
00016c  6821              LDR      r1,[r4,#0]            ;1292
00016e  7308              STRB     r0,[r1,#0xc]          ;1292
000170  6b20              LDR      r0,[r4,#0x30]         ;1293
000172  1c40              ADDS     r0,r0,#1              ;1293
000174  6320              STR      r0,[r4,#0x30]         ;1293
000176  8ee0              LDRH     r0,[r4,#0x36]         ;1294
000178  1e40              SUBS     r0,r0,#1              ;1294
00017a  86e0              STRH     r0,[r4,#0x36]         ;1294
                  |L21.380|
00017c  e034              B        |L21.488|
                  |L21.382|
00017e  6820              LDR      r0,[r4,#0]            ;1299
000180  6880              LDR      r0,[r0,#8]            ;1299
000182  f0000002          AND      r0,r0,#2              ;1299
000186  2802              CMP      r0,#2                 ;1299
000188  d110              BNE      |L21.428|
00018a  8ee0              LDRH     r0,[r4,#0x36]         ;1299
00018c  b170              CBZ      r0,|L21.428|
00018e  9802              LDR      r0,[sp,#8]            ;1299
000190  2801              CMP      r0,#1                 ;1299
000192  d10b              BNE      |L21.428|
000194  6b20              LDR      r0,[r4,#0x30]         ;1301
000196  7800              LDRB     r0,[r0,#0]            ;1301
000198  6821              LDR      r1,[r4,#0]            ;1301
00019a  7308              STRB     r0,[r1,#0xc]          ;1301
00019c  6b20              LDR      r0,[r4,#0x30]         ;1302
00019e  1c40              ADDS     r0,r0,#1              ;1302
0001a0  6320              STR      r0,[r4,#0x30]         ;1302
0001a2  8ee0              LDRH     r0,[r4,#0x36]         ;1303
0001a4  1e40              SUBS     r0,r0,#1              ;1303
0001a6  86e0              STRH     r0,[r4,#0x36]         ;1303
0001a8  2000              MOVS     r0,#0                 ;1305
0001aa  9002              STR      r0,[sp,#8]            ;1305
                  |L21.428|
0001ac  6820              LDR      r0,[r4,#0]            ;1317
0001ae  6880              LDR      r0,[r0,#8]            ;1317
0001b0  f0000001          AND      r0,r0,#1              ;1317
0001b4  b168              CBZ      r0,|L21.466|
0001b6  8fe0              LDRH     r0,[r4,#0x3e]         ;1317
0001b8  b158              CBZ      r0,|L21.466|
0001ba  6820              LDR      r0,[r4,#0]            ;1319
0001bc  68c0              LDR      r0,[r0,#0xc]          ;1319
0001be  6ba1              LDR      r1,[r4,#0x38]         ;1319
0001c0  7008              STRB     r0,[r1,#0]            ;1319
0001c2  6ba0              LDR      r0,[r4,#0x38]         ;1320
0001c4  1c40              ADDS     r0,r0,#1              ;1320
0001c6  63a0              STR      r0,[r4,#0x38]         ;1320
0001c8  8fe0              LDRH     r0,[r4,#0x3e]         ;1321
0001ca  1e40              SUBS     r0,r0,#1              ;1321
0001cc  87e0              STRH     r0,[r4,#0x3e]         ;1321
0001ce  2001              MOVS     r0,#1                 ;1323
0001d0  9002              STR      r0,[sp,#8]            ;1323
                  |L21.466|
0001d2  f7fffffe          BL       HAL_GetTick
0001d6  1bc0              SUBS     r0,r0,r7              ;1325
0001d8  42b0              CMP      r0,r6                 ;1325
0001da  d301              BCC      |L21.480|
0001dc  1c70              ADDS     r0,r6,#1              ;1325
0001de  b900              CBNZ     r0,|L21.482|
                  |L21.480|
0001e0  b916              CBNZ     r6,|L21.488|
                  |L21.482|
0001e2  2003              MOVS     r0,#3                 ;1327
0001e4  9001              STR      r0,[sp,#4]            ;1327
0001e6  e01e              B        |L21.550|
                  |L21.488|
0001e8  8ee0              LDRH     r0,[r4,#0x36]         ;1296
0001ea  2800              CMP      r0,#0                 ;1296
0001ec  d1c7              BNE      |L21.382|
0001ee  8fe0              LDRH     r0,[r4,#0x3e]         ;1296
0001f0  2800              CMP      r0,#0                 ;1296
0001f2  d1c4              BNE      |L21.382|
                  |L21.500|
0001f4  463a              MOV      r2,r7                 ;1370
0001f6  4631              MOV      r1,r6                 ;1370
0001f8  4620              MOV      r0,r4                 ;1370
0001fa  f7fffffe          BL       SPI_EndRxTxTransaction
0001fe  b120              CBZ      r0,|L21.522|
000200  2001              MOVS     r0,#1                 ;1372
000202  9001              STR      r0,[sp,#4]            ;1372
000204  2020              MOVS     r0,#0x20              ;1373
000206  6560              STR      r0,[r4,#0x54]         ;1373
000208  e00d              B        |L21.550|
                  |L21.522|
00020a  68a0              LDR      r0,[r4,#8]            ;1378
00020c  b950              CBNZ     r0,|L21.548|
00020e  bf00              NOP                            ;1380
000210  2000              MOVS     r0,#0                 ;1380
000212  9000              STR      r0,[sp,#0]            ;1380
000214  6820              LDR      r0,[r4,#0]            ;1380
000216  68c0              LDR      r0,[r0,#0xc]          ;1380
000218  9000              STR      r0,[sp,#0]            ;1380
00021a  6820              LDR      r0,[r4,#0]            ;1380
00021c  6880              LDR      r0,[r0,#8]            ;1380
00021e  9000              STR      r0,[sp,#0]            ;1380
000220  bf00              NOP                            ;1380
000222  bf00              NOP                            ;1380
                  |L21.548|
000224  bf00              NOP                            ;1383
                  |L21.550|
000226  2001              MOVS     r0,#1                 ;1384
000228  f8840051          STRB     r0,[r4,#0x51]         ;1384
00022c  bf00              NOP                            ;1385
00022e  2000              MOVS     r0,#0                 ;1385
000230  f8840050          STRB     r0,[r4,#0x50]         ;1385
000234  bf00              NOP                            ;1385
000236  9801              LDR      r0,[sp,#4]            ;1386
000238  e6fb              B        |L21.50|
;;;1388   
                          ENDP

00023a  0000              DCW      0x0000
                  |L21.572|
00023c  2e2e2f44          DCB      "../Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_spi.c"
000240  72697665
000244  72732f53
000248  544d3332
00024c  46317878
000250  5f48414c
000254  5f447269
000258  7665722f
00025c  5372632f
000260  73746d33
000264  32663178
000268  785f6861
00026c  6c5f7370
000270  692e63  
000273  00                DCB      0

                          AREA ||i.HAL_SPI_TransmitReceive_DMA||, CODE, READONLY, ALIGN=2

                  HAL_SPI_TransmitReceive_DMA PROC
;;;1886     */
;;;1887   HAL_StatusTypeDef HAL_SPI_TransmitReceive_DMA(SPI_HandleTypeDef *hspi, uint8_t *pTxData, uint8_t *pRxData,
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;1888                                                 uint16_t Size)
;;;1889   {
000004  4604              MOV      r4,r0
000006  460e              MOV      r6,r1
000008  4617              MOV      r7,r2
00000a  461d              MOV      r5,r3
;;;1890     uint32_t             tmp_mode;
;;;1891     HAL_SPI_StateTypeDef tmp_state;
;;;1892     HAL_StatusTypeDef errorcode = HAL_OK;
00000c  f04f0a00          MOV      r10,#0
;;;1893   
;;;1894     /* Check rx & tx dma handles */
;;;1895     assert_param(IS_SPI_DMA_HANDLE(hspi->hdmarx));
000010  6ce0              LDR      r0,[r4,#0x4c]
000012  b100              CBZ      r0,|L22.22|
000014  e004              B        |L22.32|
                  |L22.22|
000016  f2407167          MOV      r1,#0x767
00001a  a05b              ADR      r0,|L22.392|
00001c  f7fffffe          BL       assert_failed
                  |L22.32|
;;;1896     assert_param(IS_SPI_DMA_HANDLE(hspi->hdmatx));
000020  6ca0              LDR      r0,[r4,#0x48]
000022  b100              CBZ      r0,|L22.38|
000024  e004              B        |L22.48|
                  |L22.38|
000026  f44f61ed          MOV      r1,#0x768
00002a  a057              ADR      r0,|L22.392|
00002c  f7fffffe          BL       assert_failed
                  |L22.48|
;;;1897   
;;;1898     /* Check Direction parameter */
;;;1899     assert_param(IS_SPI_DIRECTION_2LINES(hspi->Init.Direction));
000030  68a0              LDR      r0,[r4,#8]
000032  b900              CBNZ     r0,|L22.54|
000034  e004              B        |L22.64|
                  |L22.54|
000036  f240716b          MOV      r1,#0x76b
00003a  a053              ADR      r0,|L22.392|
00003c  f7fffffe          BL       assert_failed
                  |L22.64|
;;;1900   
;;;1901     /* Process locked */
;;;1902     __HAL_LOCK(hspi);
000040  bf00              NOP      
000042  f8940050          LDRB     r0,[r4,#0x50]
000046  2801              CMP      r0,#1
000048  d102              BNE      |L22.80|
00004a  2002              MOVS     r0,#2
                  |L22.76|
;;;1903   
;;;1904     /* Init temporary variables */
;;;1905     tmp_state           = hspi->State;
;;;1906     tmp_mode            = hspi->Init.Mode;
;;;1907   
;;;1908     if (!((tmp_state == HAL_SPI_STATE_READY) ||
;;;1909           ((tmp_mode == SPI_MODE_MASTER) && (hspi->Init.Direction == SPI_DIRECTION_2LINES) && (tmp_state == HAL_SPI_STATE_BUSY_RX))))
;;;1910     {
;;;1911       errorcode = HAL_BUSY;
;;;1912       goto error;
;;;1913     }
;;;1914   
;;;1915     if ((pTxData == NULL) || (pRxData == NULL) || (Size == 0U))
;;;1916     {
;;;1917       errorcode = HAL_ERROR;
;;;1918       goto error;
;;;1919     }
;;;1920   
;;;1921     /* Don't overwrite in case of HAL_SPI_STATE_BUSY_RX */
;;;1922     if (hspi->State != HAL_SPI_STATE_BUSY_RX)
;;;1923     {
;;;1924       hspi->State = HAL_SPI_STATE_BUSY_TX_RX;
;;;1925     }
;;;1926   
;;;1927     /* Set the transaction information */
;;;1928     hspi->ErrorCode   = HAL_SPI_ERROR_NONE;
;;;1929     hspi->pTxBuffPtr  = (uint8_t *)pTxData;
;;;1930     hspi->TxXferSize  = Size;
;;;1931     hspi->TxXferCount = Size;
;;;1932     hspi->pRxBuffPtr  = (uint8_t *)pRxData;
;;;1933     hspi->RxXferSize  = Size;
;;;1934     hspi->RxXferCount = Size;
;;;1935   
;;;1936     /* Init field not used in handle to zero */
;;;1937     hspi->RxISR       = NULL;
;;;1938     hspi->TxISR       = NULL;
;;;1939   
;;;1940   #if (USE_SPI_CRC != 0U)
;;;1941     /* Reset CRC Calculation */
;;;1942     if (hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
;;;1943     {
;;;1944       SPI_RESET_CRC(hspi);
;;;1945     }
;;;1946   #endif /* USE_SPI_CRC */
;;;1947   
;;;1948     /* Check if we are in Rx only or in Rx/Tx Mode and configure the DMA transfer complete callback */
;;;1949     if (hspi->State == HAL_SPI_STATE_BUSY_RX)
;;;1950     {
;;;1951       /* Set the SPI Rx DMA Half transfer complete callback */
;;;1952       hspi->hdmarx->XferHalfCpltCallback = SPI_DMAHalfReceiveCplt;
;;;1953       hspi->hdmarx->XferCpltCallback     = SPI_DMAReceiveCplt;
;;;1954     }
;;;1955     else
;;;1956     {
;;;1957       /* Set the SPI Tx/Rx DMA Half transfer complete callback */
;;;1958       hspi->hdmarx->XferHalfCpltCallback = SPI_DMAHalfTransmitReceiveCplt;
;;;1959       hspi->hdmarx->XferCpltCallback     = SPI_DMATransmitReceiveCplt;
;;;1960     }
;;;1961   
;;;1962     /* Set the DMA error callback */
;;;1963     hspi->hdmarx->XferErrorCallback = SPI_DMAError;
;;;1964   
;;;1965     /* Set the DMA AbortCpltCallback */
;;;1966     hspi->hdmarx->XferAbortCallback = NULL;
;;;1967   
;;;1968     /* Enable the Rx DMA Stream/Channel  */
;;;1969     if (HAL_OK != HAL_DMA_Start_IT(hspi->hdmarx, (uint32_t)&hspi->Instance->DR, (uint32_t)hspi->pRxBuffPtr,
;;;1970                                    hspi->RxXferCount))
;;;1971     {
;;;1972       /* Update SPI error code */
;;;1973       SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_DMA);
;;;1974       errorcode = HAL_ERROR;
;;;1975   
;;;1976       hspi->State = HAL_SPI_STATE_READY;
;;;1977       goto error;
;;;1978     }
;;;1979   
;;;1980     /* Enable Rx DMA Request */
;;;1981     SET_BIT(hspi->Instance->CR2, SPI_CR2_RXDMAEN);
;;;1982   
;;;1983     /* Set the SPI Tx DMA transfer complete callback as NULL because the communication closing
;;;1984     is performed in DMA reception complete callback  */
;;;1985     hspi->hdmatx->XferHalfCpltCallback = NULL;
;;;1986     hspi->hdmatx->XferCpltCallback     = NULL;
;;;1987     hspi->hdmatx->XferErrorCallback    = NULL;
;;;1988     hspi->hdmatx->XferAbortCallback    = NULL;
;;;1989   
;;;1990     /* Enable the Tx DMA Stream/Channel  */
;;;1991     if (HAL_OK != HAL_DMA_Start_IT(hspi->hdmatx, (uint32_t)hspi->pTxBuffPtr, (uint32_t)&hspi->Instance->DR,
;;;1992                                    hspi->TxXferCount))
;;;1993     {
;;;1994       /* Update SPI error code */
;;;1995       SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_DMA);
;;;1996       errorcode = HAL_ERROR;
;;;1997   
;;;1998       hspi->State = HAL_SPI_STATE_READY;
;;;1999       goto error;
;;;2000     }
;;;2001   
;;;2002     /* Check if the SPI is already enabled */
;;;2003     if ((hspi->Instance->CR1 & SPI_CR1_SPE) != SPI_CR1_SPE)
;;;2004     {
;;;2005       /* Enable SPI peripheral */
;;;2006       __HAL_SPI_ENABLE(hspi);
;;;2007     }
;;;2008     /* Enable the SPI Error Interrupt Bit */
;;;2009     __HAL_SPI_ENABLE_IT(hspi, (SPI_IT_ERR));
;;;2010   
;;;2011     /* Enable Tx DMA Request */
;;;2012     SET_BIT(hspi->Instance->CR2, SPI_CR2_TXDMAEN);
;;;2013   
;;;2014   error :
;;;2015     /* Process Unlocked */
;;;2016     __HAL_UNLOCK(hspi);
;;;2017     return errorcode;
;;;2018   }
00004c  e8bd87f0          POP      {r4-r10,pc}
                  |L22.80|
000050  2001              MOVS     r0,#1                 ;1902
000052  f8840050          STRB     r0,[r4,#0x50]         ;1902
000056  bf00              NOP                            ;1902
000058  f8948051          LDRB     r8,[r4,#0x51]         ;1905
00005c  f8d49004          LDR      r9,[r4,#4]            ;1906
000060  f1b80f01          CMP      r8,#1                 ;1908
000064  d00a              BEQ      |L22.124|
000066  f5b97f82          CMP      r9,#0x104             ;1908
00006a  d104              BNE      |L22.118|
00006c  68a0              LDR      r0,[r4,#8]            ;1908
00006e  b910              CBNZ     r0,|L22.118|
000070  f1b80f04          CMP      r8,#4                 ;1908
000074  d002              BEQ      |L22.124|
                  |L22.118|
000076  f04f0a02          MOV      r10,#2                ;1911
00007a  e07d              B        |L22.376|
                  |L22.124|
00007c  b10e              CBZ      r6,|L22.130|
00007e  b107              CBZ      r7,|L22.130|
000080  b915              CBNZ     r5,|L22.136|
                  |L22.130|
000082  f04f0a01          MOV      r10,#1                ;1917
000086  e077              B        |L22.376|
                  |L22.136|
000088  f8940051          LDRB     r0,[r4,#0x51]         ;1922
00008c  2804              CMP      r0,#4                 ;1922
00008e  d002              BEQ      |L22.150|
000090  2005              MOVS     r0,#5                 ;1924
000092  f8840051          STRB     r0,[r4,#0x51]         ;1924
                  |L22.150|
000096  2000              MOVS     r0,#0                 ;1928
000098  6560              STR      r0,[r4,#0x54]         ;1928
00009a  6326              STR      r6,[r4,#0x30]         ;1929
00009c  86a5              STRH     r5,[r4,#0x34]         ;1930
00009e  86e5              STRH     r5,[r4,#0x36]         ;1931
0000a0  63a7              STR      r7,[r4,#0x38]         ;1932
0000a2  87a5              STRH     r5,[r4,#0x3c]         ;1933
0000a4  87e5              STRH     r5,[r4,#0x3e]         ;1934
0000a6  6420              STR      r0,[r4,#0x40]         ;1937
0000a8  6460              STR      r0,[r4,#0x44]         ;1938
0000aa  f8940051          LDRB     r0,[r4,#0x51]         ;1949
0000ae  2804              CMP      r0,#4                 ;1949
0000b0  d106              BNE      |L22.192|
0000b2  4843              LDR      r0,|L22.448|
0000b4  6ce1              LDR      r1,[r4,#0x4c]         ;1952
0000b6  62c8              STR      r0,[r1,#0x2c]         ;1952
0000b8  4842              LDR      r0,|L22.452|
0000ba  6ce1              LDR      r1,[r4,#0x4c]         ;1953
0000bc  6288              STR      r0,[r1,#0x28]         ;1953
0000be  e005              B        |L22.204|
                  |L22.192|
0000c0  4841              LDR      r0,|L22.456|
0000c2  6ce1              LDR      r1,[r4,#0x4c]         ;1958
0000c4  62c8              STR      r0,[r1,#0x2c]         ;1958
0000c6  4841              LDR      r0,|L22.460|
0000c8  6ce1              LDR      r1,[r4,#0x4c]         ;1959
0000ca  6288              STR      r0,[r1,#0x28]         ;1959
                  |L22.204|
0000cc  4840              LDR      r0,|L22.464|
0000ce  6ce1              LDR      r1,[r4,#0x4c]         ;1963
0000d0  6308              STR      r0,[r1,#0x30]         ;1963
0000d2  2000              MOVS     r0,#0                 ;1966
0000d4  6ce1              LDR      r1,[r4,#0x4c]         ;1966
0000d6  6348              STR      r0,[r1,#0x34]         ;1966
0000d8  8fe3              LDRH     r3,[r4,#0x3e]         ;1969
0000da  f8d4c000          LDR      r12,[r4,#0]           ;1969
0000de  f10c010c          ADD      r1,r12,#0xc           ;1969
0000e2  6ba2              LDR      r2,[r4,#0x38]         ;1969
0000e4  6ce0              LDR      r0,[r4,#0x4c]         ;1969
0000e6  f7fffffe          BL       HAL_DMA_Start_IT
0000ea  b148              CBZ      r0,|L22.256|
0000ec  6d60              LDR      r0,[r4,#0x54]         ;1973
0000ee  f0400010          ORR      r0,r0,#0x10           ;1973
0000f2  6560              STR      r0,[r4,#0x54]         ;1973
0000f4  f04f0a01          MOV      r10,#1                ;1974
0000f8  2001              MOVS     r0,#1                 ;1976
0000fa  f8840051          STRB     r0,[r4,#0x51]         ;1976
0000fe  e03b              B        |L22.376|
                  |L22.256|
000100  6820              LDR      r0,[r4,#0]            ;1981
000102  6840              LDR      r0,[r0,#4]            ;1981
000104  f0400001          ORR      r0,r0,#1              ;1981
000108  6821              LDR      r1,[r4,#0]            ;1981
00010a  6048              STR      r0,[r1,#4]            ;1981
00010c  2000              MOVS     r0,#0                 ;1985
00010e  6ca1              LDR      r1,[r4,#0x48]         ;1985
000110  62c8              STR      r0,[r1,#0x2c]         ;1985
000112  6ca1              LDR      r1,[r4,#0x48]         ;1986
000114  6288              STR      r0,[r1,#0x28]         ;1986
000116  6ca1              LDR      r1,[r4,#0x48]         ;1987
000118  6308              STR      r0,[r1,#0x30]         ;1987
00011a  6ca1              LDR      r1,[r4,#0x48]         ;1988
00011c  6348              STR      r0,[r1,#0x34]         ;1988
00011e  8ee3              LDRH     r3,[r4,#0x36]         ;1991
000120  f8d4c000          LDR      r12,[r4,#0]           ;1991
000124  f10c020c          ADD      r2,r12,#0xc           ;1991
000128  6b21              LDR      r1,[r4,#0x30]         ;1991
00012a  6ca0              LDR      r0,[r4,#0x48]         ;1991
00012c  f7fffffe          BL       HAL_DMA_Start_IT
000130  b148              CBZ      r0,|L22.326|
000132  6d60              LDR      r0,[r4,#0x54]         ;1995
000134  f0400010          ORR      r0,r0,#0x10           ;1995
000138  6560              STR      r0,[r4,#0x54]         ;1995
00013a  f04f0a01          MOV      r10,#1                ;1996
00013e  2001              MOVS     r0,#1                 ;1998
000140  f8840051          STRB     r0,[r4,#0x51]         ;1998
000144  e018              B        |L22.376|
                  |L22.326|
000146  6820              LDR      r0,[r4,#0]            ;2003
000148  6800              LDR      r0,[r0,#0]            ;2003
00014a  f0000040          AND      r0,r0,#0x40           ;2003
00014e  2840              CMP      r0,#0x40              ;2003
000150  d005              BEQ      |L22.350|
000152  6820              LDR      r0,[r4,#0]            ;2006
000154  6800              LDR      r0,[r0,#0]            ;2006
000156  f0400040          ORR      r0,r0,#0x40           ;2006
00015a  6821              LDR      r1,[r4,#0]            ;2006
00015c  6008              STR      r0,[r1,#0]            ;2006
                  |L22.350|
00015e  6820              LDR      r0,[r4,#0]            ;2009
000160  6840              LDR      r0,[r0,#4]            ;2009
000162  f0400020          ORR      r0,r0,#0x20           ;2009
000166  6821              LDR      r1,[r4,#0]            ;2009
000168  6048              STR      r0,[r1,#4]            ;2009
00016a  6820              LDR      r0,[r4,#0]            ;2012
00016c  6840              LDR      r0,[r0,#4]            ;2012
00016e  f0400002          ORR      r0,r0,#2              ;2012
000172  6821              LDR      r1,[r4,#0]            ;2012
000174  6048              STR      r0,[r1,#4]            ;2012
000176  bf00              NOP                            ;2014
                  |L22.376|
000178  bf00              NOP                            ;2016
00017a  2000              MOVS     r0,#0                 ;2016
00017c  f8840050          STRB     r0,[r4,#0x50]         ;2016
000180  bf00              NOP                            ;2016
000182  4650              MOV      r0,r10                ;2017
000184  e762              B        |L22.76|
;;;2019   
                          ENDP

000186  0000              DCW      0x0000
                  |L22.392|
000188  2e2e2f44          DCB      "../Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_spi.c"
00018c  72697665
000190  72732f53
000194  544d3332
000198  46317878
00019c  5f48414c
0001a0  5f447269
0001a4  7665722f
0001a8  5372632f
0001ac  73746d33
0001b0  32663178
0001b4  785f6861
0001b8  6c5f7370
0001bc  692e63  
0001bf  00                DCB      0
                  |L22.448|
                          DCD      SPI_DMAHalfReceiveCplt
                  |L22.452|
                          DCD      SPI_DMAReceiveCplt
                  |L22.456|
                          DCD      SPI_DMAHalfTransmitReceiveCplt
                  |L22.460|
                          DCD      SPI_DMATransmitReceiveCplt
                  |L22.464|
                          DCD      SPI_DMAError

                          AREA ||i.HAL_SPI_TransmitReceive_IT||, CODE, READONLY, ALIGN=2

                  HAL_SPI_TransmitReceive_IT PROC
;;;1575     */
;;;1576   HAL_StatusTypeDef HAL_SPI_TransmitReceive_IT(SPI_HandleTypeDef *hspi, uint8_t *pTxData, uint8_t *pRxData, uint16_t Size)
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;1577   {
000004  4604              MOV      r4,r0
000006  460e              MOV      r6,r1
000008  4617              MOV      r7,r2
00000a  461d              MOV      r5,r3
;;;1578     uint32_t             tmp_mode;
;;;1579     HAL_SPI_StateTypeDef tmp_state;
;;;1580     HAL_StatusTypeDef    errorcode = HAL_OK;
00000c  f04f0a00          MOV      r10,#0
;;;1581   
;;;1582     /* Check Direction parameter */
;;;1583     assert_param(IS_SPI_DIRECTION_2LINES(hspi->Init.Direction));
000010  68a0              LDR      r0,[r4,#8]
000012  b900              CBNZ     r0,|L23.22|
000014  e004              B        |L23.32|
                  |L23.22|
000016  f240612f          MOV      r1,#0x62f
00001a  a02d              ADR      r0,|L23.208|
00001c  f7fffffe          BL       assert_failed
                  |L23.32|
;;;1584   
;;;1585     /* Process locked */
;;;1586     __HAL_LOCK(hspi);
000020  bf00              NOP      
000022  f8940050          LDRB     r0,[r4,#0x50]
000026  2801              CMP      r0,#1
000028  d102              BNE      |L23.48|
00002a  2002              MOVS     r0,#2
                  |L23.44|
;;;1587   
;;;1588     /* Init temporary variables */
;;;1589     tmp_state           = hspi->State;
;;;1590     tmp_mode            = hspi->Init.Mode;
;;;1591   
;;;1592     if (!((tmp_state == HAL_SPI_STATE_READY) || \
;;;1593           ((tmp_mode == SPI_MODE_MASTER) && (hspi->Init.Direction == SPI_DIRECTION_2LINES) && (tmp_state == HAL_SPI_STATE_BUSY_RX))))
;;;1594     {
;;;1595       errorcode = HAL_BUSY;
;;;1596       goto error;
;;;1597     }
;;;1598   
;;;1599     if ((pTxData == NULL) || (pRxData == NULL) || (Size == 0U))
;;;1600     {
;;;1601       errorcode = HAL_ERROR;
;;;1602       goto error;
;;;1603     }
;;;1604   
;;;1605     /* Don't overwrite in case of HAL_SPI_STATE_BUSY_RX */
;;;1606     if (hspi->State != HAL_SPI_STATE_BUSY_RX)
;;;1607     {
;;;1608       hspi->State = HAL_SPI_STATE_BUSY_TX_RX;
;;;1609     }
;;;1610   
;;;1611     /* Set the transaction information */
;;;1612     hspi->ErrorCode   = HAL_SPI_ERROR_NONE;
;;;1613     hspi->pTxBuffPtr  = (uint8_t *)pTxData;
;;;1614     hspi->TxXferSize  = Size;
;;;1615     hspi->TxXferCount = Size;
;;;1616     hspi->pRxBuffPtr  = (uint8_t *)pRxData;
;;;1617     hspi->RxXferSize  = Size;
;;;1618     hspi->RxXferCount = Size;
;;;1619   
;;;1620     /* Set the function for IT treatment */
;;;1621     if (hspi->Init.DataSize > SPI_DATASIZE_8BIT)
;;;1622     {
;;;1623       hspi->RxISR     = SPI_2linesRxISR_16BIT;
;;;1624       hspi->TxISR     = SPI_2linesTxISR_16BIT;
;;;1625     }
;;;1626     else
;;;1627     {
;;;1628       hspi->RxISR     = SPI_2linesRxISR_8BIT;
;;;1629       hspi->TxISR     = SPI_2linesTxISR_8BIT;
;;;1630     }
;;;1631   
;;;1632   #if (USE_SPI_CRC != 0U)
;;;1633     /* Reset CRC Calculation */
;;;1634     if (hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
;;;1635     {
;;;1636       SPI_RESET_CRC(hspi);
;;;1637     }
;;;1638   #endif /* USE_SPI_CRC */
;;;1639   
;;;1640     /* Enable TXE, RXNE and ERR interrupt */
;;;1641     __HAL_SPI_ENABLE_IT(hspi, (SPI_IT_TXE | SPI_IT_RXNE | SPI_IT_ERR));
;;;1642   
;;;1643     /* Check if the SPI is already enabled */
;;;1644     if ((hspi->Instance->CR1 & SPI_CR1_SPE) != SPI_CR1_SPE)
;;;1645     {
;;;1646       /* Enable SPI peripheral */
;;;1647       __HAL_SPI_ENABLE(hspi);
;;;1648     }
;;;1649   
;;;1650   error :
;;;1651     /* Process Unlocked */
;;;1652     __HAL_UNLOCK(hspi);
;;;1653     return errorcode;
;;;1654   }
00002c  e8bd87f0          POP      {r4-r10,pc}
                  |L23.48|
000030  2001              MOVS     r0,#1                 ;1586
000032  f8840050          STRB     r0,[r4,#0x50]         ;1586
000036  bf00              NOP                            ;1586
000038  f8948051          LDRB     r8,[r4,#0x51]         ;1589
00003c  f8d49004          LDR      r9,[r4,#4]            ;1590
000040  f1b80f01          CMP      r8,#1                 ;1592
000044  d00a              BEQ      |L23.92|
000046  f5b97f82          CMP      r9,#0x104             ;1592
00004a  d104              BNE      |L23.86|
00004c  68a0              LDR      r0,[r4,#8]            ;1592
00004e  b910              CBNZ     r0,|L23.86|
000050  f1b80f04          CMP      r8,#4                 ;1592
000054  d002              BEQ      |L23.92|
                  |L23.86|
000056  f04f0a02          MOV      r10,#2                ;1595
00005a  e032              B        |L23.194|
                  |L23.92|
00005c  b10e              CBZ      r6,|L23.98|
00005e  b107              CBZ      r7,|L23.98|
000060  b915              CBNZ     r5,|L23.104|
                  |L23.98|
000062  f04f0a01          MOV      r10,#1                ;1601
000066  e02c              B        |L23.194|
                  |L23.104|
000068  f8940051          LDRB     r0,[r4,#0x51]         ;1606
00006c  2804              CMP      r0,#4                 ;1606
00006e  d002              BEQ      |L23.118|
000070  2005              MOVS     r0,#5                 ;1608
000072  f8840051          STRB     r0,[r4,#0x51]         ;1608
                  |L23.118|
000076  2000              MOVS     r0,#0                 ;1612
000078  6560              STR      r0,[r4,#0x54]         ;1612
00007a  6326              STR      r6,[r4,#0x30]         ;1613
00007c  86a5              STRH     r5,[r4,#0x34]         ;1614
00007e  86e5              STRH     r5,[r4,#0x36]         ;1615
000080  63a7              STR      r7,[r4,#0x38]         ;1616
000082  87a5              STRH     r5,[r4,#0x3c]         ;1617
000084  87e5              STRH     r5,[r4,#0x3e]         ;1618
000086  68e0              LDR      r0,[r4,#0xc]          ;1621
000088  b120              CBZ      r0,|L23.148|
00008a  481f              LDR      r0,|L23.264|
00008c  6420              STR      r0,[r4,#0x40]         ;1623
00008e  481f              LDR      r0,|L23.268|
000090  6460              STR      r0,[r4,#0x44]         ;1624
000092  e003              B        |L23.156|
                  |L23.148|
000094  481e              LDR      r0,|L23.272|
000096  6420              STR      r0,[r4,#0x40]         ;1628
000098  481e              LDR      r0,|L23.276|
00009a  6460              STR      r0,[r4,#0x44]         ;1629
                  |L23.156|
00009c  6820              LDR      r0,[r4,#0]            ;1641
00009e  6840              LDR      r0,[r0,#4]            ;1641
0000a0  f04000e0          ORR      r0,r0,#0xe0           ;1641
0000a4  6821              LDR      r1,[r4,#0]            ;1641
0000a6  6048              STR      r0,[r1,#4]            ;1641
0000a8  6820              LDR      r0,[r4,#0]            ;1644
0000aa  6800              LDR      r0,[r0,#0]            ;1644
0000ac  f0000040          AND      r0,r0,#0x40           ;1644
0000b0  2840              CMP      r0,#0x40              ;1644
0000b2  d005              BEQ      |L23.192|
0000b4  6820              LDR      r0,[r4,#0]            ;1647
0000b6  6800              LDR      r0,[r0,#0]            ;1647
0000b8  f0400040          ORR      r0,r0,#0x40           ;1647
0000bc  6821              LDR      r1,[r4,#0]            ;1647
0000be  6008              STR      r0,[r1,#0]            ;1647
                  |L23.192|
0000c0  bf00              NOP                            ;1650
                  |L23.194|
0000c2  bf00              NOP                            ;1652
0000c4  2000              MOVS     r0,#0                 ;1652
0000c6  f8840050          STRB     r0,[r4,#0x50]         ;1652
0000ca  bf00              NOP                            ;1652
0000cc  4650              MOV      r0,r10                ;1653
0000ce  e7ad              B        |L23.44|
;;;1655   
                          ENDP

                  |L23.208|
0000d0  2e2e2f44          DCB      "../Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_spi.c"
0000d4  72697665
0000d8  72732f53
0000dc  544d3332
0000e0  46317878
0000e4  5f48414c
0000e8  5f447269
0000ec  7665722f
0000f0  5372632f
0000f4  73746d33
0000f8  32663178
0000fc  785f6861
000100  6c5f7370
000104  692e63  
000107  00                DCB      0
                  |L23.264|
                          DCD      SPI_2linesRxISR_16BIT
                  |L23.268|
                          DCD      SPI_2linesTxISR_16BIT
                  |L23.272|
                          DCD      SPI_2linesRxISR_8BIT
                  |L23.276|
                          DCD      SPI_2linesTxISR_8BIT

                          AREA ||i.HAL_SPI_Transmit_DMA||, CODE, READONLY, ALIGN=2

                  HAL_SPI_Transmit_DMA PROC
;;;1663     */
;;;1664   HAL_StatusTypeDef HAL_SPI_Transmit_DMA(SPI_HandleTypeDef *hspi, uint8_t *pData, uint16_t Size)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;1665   {
000004  4604              MOV      r4,r0
000006  460e              MOV      r6,r1
000008  4615              MOV      r5,r2
;;;1666     HAL_StatusTypeDef errorcode = HAL_OK;
00000a  2700              MOVS     r7,#0
;;;1667   
;;;1668     /* Check tx dma handle */
;;;1669     assert_param(IS_SPI_DMA_HANDLE(hspi->hdmatx));
00000c  6ca0              LDR      r0,[r4,#0x48]
00000e  b100              CBZ      r0,|L24.18|
000010  e004              B        |L24.28|
                  |L24.18|
000012  f2406185          MOV      r1,#0x685
000016  a040              ADR      r0,|L24.280|
000018  f7fffffe          BL       assert_failed
                  |L24.28|
;;;1670   
;;;1671     /* Check Direction parameter */
;;;1672     assert_param(IS_SPI_DIRECTION_2LINES_OR_1LINE(hspi->Init.Direction));
00001c  68a0              LDR      r0,[r4,#8]
00001e  b118              CBZ      r0,|L24.40|
000020  68a0              LDR      r0,[r4,#8]
000022  f5b04f00          CMP      r0,#0x8000
000026  d100              BNE      |L24.42|
                  |L24.40|
000028  e004              B        |L24.52|
                  |L24.42|
00002a  f44f61d1          MOV      r1,#0x688
00002e  a03a              ADR      r0,|L24.280|
000030  f7fffffe          BL       assert_failed
                  |L24.52|
;;;1673   
;;;1674     /* Process Locked */
;;;1675     __HAL_LOCK(hspi);
000034  bf00              NOP      
000036  f8940050          LDRB     r0,[r4,#0x50]
00003a  2801              CMP      r0,#1
00003c  d102              BNE      |L24.68|
00003e  2002              MOVS     r0,#2
                  |L24.64|
;;;1676   
;;;1677     if (hspi->State != HAL_SPI_STATE_READY)
;;;1678     {
;;;1679       errorcode = HAL_BUSY;
;;;1680       goto error;
;;;1681     }
;;;1682   
;;;1683     if ((pData == NULL) || (Size == 0U))
;;;1684     {
;;;1685       errorcode = HAL_ERROR;
;;;1686       goto error;
;;;1687     }
;;;1688   
;;;1689     /* Set the transaction information */
;;;1690     hspi->State       = HAL_SPI_STATE_BUSY_TX;
;;;1691     hspi->ErrorCode   = HAL_SPI_ERROR_NONE;
;;;1692     hspi->pTxBuffPtr  = (uint8_t *)pData;
;;;1693     hspi->TxXferSize  = Size;
;;;1694     hspi->TxXferCount = Size;
;;;1695   
;;;1696     /* Init field not used in handle to zero */
;;;1697     hspi->pRxBuffPtr  = (uint8_t *)NULL;
;;;1698     hspi->TxISR       = NULL;
;;;1699     hspi->RxISR       = NULL;
;;;1700     hspi->RxXferSize  = 0U;
;;;1701     hspi->RxXferCount = 0U;
;;;1702   
;;;1703     /* Configure communication direction : 1Line */
;;;1704     if (hspi->Init.Direction == SPI_DIRECTION_1LINE)
;;;1705     {
;;;1706       /* Disable SPI Peripheral before set 1Line direction (BIDIOE bit) */
;;;1707       __HAL_SPI_DISABLE(hspi);
;;;1708       SPI_1LINE_TX(hspi);
;;;1709     }
;;;1710   
;;;1711   #if (USE_SPI_CRC != 0U)
;;;1712     /* Reset CRC Calculation */
;;;1713     if (hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
;;;1714     {
;;;1715       SPI_RESET_CRC(hspi);
;;;1716     }
;;;1717   #endif /* USE_SPI_CRC */
;;;1718   
;;;1719     /* Set the SPI TxDMA Half transfer complete callback */
;;;1720     hspi->hdmatx->XferHalfCpltCallback = SPI_DMAHalfTransmitCplt;
;;;1721   
;;;1722     /* Set the SPI TxDMA transfer complete callback */
;;;1723     hspi->hdmatx->XferCpltCallback = SPI_DMATransmitCplt;
;;;1724   
;;;1725     /* Set the DMA error callback */
;;;1726     hspi->hdmatx->XferErrorCallback = SPI_DMAError;
;;;1727   
;;;1728     /* Set the DMA AbortCpltCallback */
;;;1729     hspi->hdmatx->XferAbortCallback = NULL;
;;;1730   
;;;1731     /* Enable the Tx DMA Stream/Channel */
;;;1732     if (HAL_OK != HAL_DMA_Start_IT(hspi->hdmatx, (uint32_t)hspi->pTxBuffPtr, (uint32_t)&hspi->Instance->DR,
;;;1733                                    hspi->TxXferCount))
;;;1734     {
;;;1735       /* Update SPI error code */
;;;1736       SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_DMA);
;;;1737       errorcode = HAL_ERROR;
;;;1738   
;;;1739       hspi->State = HAL_SPI_STATE_READY;
;;;1740       goto error;
;;;1741     }
;;;1742   
;;;1743     /* Check if the SPI is already enabled */
;;;1744     if ((hspi->Instance->CR1 & SPI_CR1_SPE) != SPI_CR1_SPE)
;;;1745     {
;;;1746       /* Enable SPI peripheral */
;;;1747       __HAL_SPI_ENABLE(hspi);
;;;1748     }
;;;1749   
;;;1750     /* Enable the SPI Error Interrupt Bit */
;;;1751     __HAL_SPI_ENABLE_IT(hspi, (SPI_IT_ERR));
;;;1752   
;;;1753     /* Enable Tx DMA Request */
;;;1754     SET_BIT(hspi->Instance->CR2, SPI_CR2_TXDMAEN);
;;;1755   
;;;1756   error :
;;;1757     /* Process Unlocked */
;;;1758     __HAL_UNLOCK(hspi);
;;;1759     return errorcode;
;;;1760   }
000040  e8bd81f0          POP      {r4-r8,pc}
                  |L24.68|
000044  2001              MOVS     r0,#1                 ;1675
000046  f8840050          STRB     r0,[r4,#0x50]         ;1675
00004a  bf00              NOP                            ;1675
00004c  f8940051          LDRB     r0,[r4,#0x51]         ;1677
000050  2801              CMP      r0,#1                 ;1677
000052  d001              BEQ      |L24.88|
000054  2702              MOVS     r7,#2                 ;1679
000056  e058              B        |L24.266|
                  |L24.88|
000058  b106              CBZ      r6,|L24.92|
00005a  b90d              CBNZ     r5,|L24.96|
                  |L24.92|
00005c  2701              MOVS     r7,#1                 ;1685
00005e  e054              B        |L24.266|
                  |L24.96|
000060  2003              MOVS     r0,#3                 ;1690
000062  f8840051          STRB     r0,[r4,#0x51]         ;1690
000066  2000              MOVS     r0,#0                 ;1691
000068  6560              STR      r0,[r4,#0x54]         ;1691
00006a  6326              STR      r6,[r4,#0x30]         ;1692
00006c  86a5              STRH     r5,[r4,#0x34]         ;1693
00006e  86e5              STRH     r5,[r4,#0x36]         ;1694
000070  63a0              STR      r0,[r4,#0x38]         ;1697
000072  6460              STR      r0,[r4,#0x44]         ;1698
000074  6420              STR      r0,[r4,#0x40]         ;1699
000076  87a0              STRH     r0,[r4,#0x3c]         ;1700
000078  87e0              STRH     r0,[r4,#0x3e]         ;1701
00007a  68a0              LDR      r0,[r4,#8]            ;1704
00007c  f5b04f00          CMP      r0,#0x8000            ;1704
000080  d10b              BNE      |L24.154|
000082  6820              LDR      r0,[r4,#0]            ;1707
000084  6800              LDR      r0,[r0,#0]            ;1707
000086  f0200040          BIC      r0,r0,#0x40           ;1707
00008a  6821              LDR      r1,[r4,#0]            ;1707
00008c  6008              STR      r0,[r1,#0]            ;1707
00008e  6820              LDR      r0,[r4,#0]            ;1708
000090  6800              LDR      r0,[r0,#0]            ;1708
000092  f4404080          ORR      r0,r0,#0x4000         ;1708
000096  6821              LDR      r1,[r4,#0]            ;1708
000098  6008              STR      r0,[r1,#0]            ;1708
                  |L24.154|
00009a  482d              LDR      r0,|L24.336|
00009c  6ca1              LDR      r1,[r4,#0x48]         ;1720
00009e  62c8              STR      r0,[r1,#0x2c]         ;1720
0000a0  482c              LDR      r0,|L24.340|
0000a2  6ca1              LDR      r1,[r4,#0x48]         ;1723
0000a4  6288              STR      r0,[r1,#0x28]         ;1723
0000a6  482c              LDR      r0,|L24.344|
0000a8  6ca1              LDR      r1,[r4,#0x48]         ;1726
0000aa  6308              STR      r0,[r1,#0x30]         ;1726
0000ac  2000              MOVS     r0,#0                 ;1729
0000ae  6ca1              LDR      r1,[r4,#0x48]         ;1729
0000b0  6348              STR      r0,[r1,#0x34]         ;1729
0000b2  8ee3              LDRH     r3,[r4,#0x36]         ;1732
0000b4  f8d4c000          LDR      r12,[r4,#0]           ;1732
0000b8  f10c020c          ADD      r2,r12,#0xc           ;1732
0000bc  6b21              LDR      r1,[r4,#0x30]         ;1732
0000be  6ca0              LDR      r0,[r4,#0x48]         ;1732
0000c0  f7fffffe          BL       HAL_DMA_Start_IT
0000c4  b140              CBZ      r0,|L24.216|
0000c6  6d60              LDR      r0,[r4,#0x54]         ;1736
0000c8  f0400010          ORR      r0,r0,#0x10           ;1736
0000cc  6560              STR      r0,[r4,#0x54]         ;1736
0000ce  2701              MOVS     r7,#1                 ;1737
0000d0  2001              MOVS     r0,#1                 ;1739
0000d2  f8840051          STRB     r0,[r4,#0x51]         ;1739
0000d6  e018              B        |L24.266|
                  |L24.216|
0000d8  6820              LDR      r0,[r4,#0]            ;1744
0000da  6800              LDR      r0,[r0,#0]            ;1744
0000dc  f0000040          AND      r0,r0,#0x40           ;1744
0000e0  2840              CMP      r0,#0x40              ;1744
0000e2  d005              BEQ      |L24.240|
0000e4  6820              LDR      r0,[r4,#0]            ;1747
0000e6  6800              LDR      r0,[r0,#0]            ;1747
0000e8  f0400040          ORR      r0,r0,#0x40           ;1747
0000ec  6821              LDR      r1,[r4,#0]            ;1747
0000ee  6008              STR      r0,[r1,#0]            ;1747
                  |L24.240|
0000f0  6820              LDR      r0,[r4,#0]            ;1751
0000f2  6840              LDR      r0,[r0,#4]            ;1751
0000f4  f0400020          ORR      r0,r0,#0x20           ;1751
0000f8  6821              LDR      r1,[r4,#0]            ;1751
0000fa  6048              STR      r0,[r1,#4]            ;1751
0000fc  6820              LDR      r0,[r4,#0]            ;1754
0000fe  6840              LDR      r0,[r0,#4]            ;1754
000100  f0400002          ORR      r0,r0,#2              ;1754
000104  6821              LDR      r1,[r4,#0]            ;1754
000106  6048              STR      r0,[r1,#4]            ;1754
000108  bf00              NOP                            ;1756
                  |L24.266|
00010a  bf00              NOP                            ;1758
00010c  2000              MOVS     r0,#0                 ;1758
00010e  f8840050          STRB     r0,[r4,#0x50]         ;1758
000112  bf00              NOP                            ;1758
000114  4638              MOV      r0,r7                 ;1759
000116  e793              B        |L24.64|
;;;1761   
                          ENDP

                  |L24.280|
000118  2e2e2f44          DCB      "../Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_spi.c"
00011c  72697665
000120  72732f53
000124  544d3332
000128  46317878
00012c  5f48414c
000130  5f447269
000134  7665722f
000138  5372632f
00013c  73746d33
000140  32663178
000144  785f6861
000148  6c5f7370
00014c  692e63  
00014f  00                DCB      0
                  |L24.336|
                          DCD      SPI_DMAHalfTransmitCplt
                  |L24.340|
                          DCD      SPI_DMATransmitCplt
                  |L24.344|
                          DCD      SPI_DMAError

                          AREA ||i.HAL_SPI_Transmit_IT||, CODE, READONLY, ALIGN=2

                  HAL_SPI_Transmit_IT PROC
;;;1396     */
;;;1397   HAL_StatusTypeDef HAL_SPI_Transmit_IT(SPI_HandleTypeDef *hspi, uint8_t *pData, uint16_t Size)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;1398   {
000004  4604              MOV      r4,r0
000006  460e              MOV      r6,r1
000008  4615              MOV      r5,r2
;;;1399     HAL_StatusTypeDef errorcode = HAL_OK;
00000a  2700              MOVS     r7,#0
;;;1400   
;;;1401     /* Check Direction parameter */
;;;1402     assert_param(IS_SPI_DIRECTION_2LINES_OR_1LINE(hspi->Init.Direction));
00000c  68a0              LDR      r0,[r4,#8]
00000e  b118              CBZ      r0,|L25.24|
000010  68a0              LDR      r0,[r4,#8]
000012  f5b04f00          CMP      r0,#0x8000
000016  d100              BNE      |L25.26|
                  |L25.24|
000018  e004              B        |L25.36|
                  |L25.26|
00001a  f240517a          MOV      r1,#0x57a
00001e  a02b              ADR      r0,|L25.204|
000020  f7fffffe          BL       assert_failed
                  |L25.36|
;;;1403   
;;;1404     /* Process Locked */
;;;1405     __HAL_LOCK(hspi);
000024  bf00              NOP      
000026  f8940050          LDRB     r0,[r4,#0x50]
00002a  2801              CMP      r0,#1
00002c  d102              BNE      |L25.52|
00002e  2002              MOVS     r0,#2
                  |L25.48|
;;;1406   
;;;1407     if ((pData == NULL) || (Size == 0U))
;;;1408     {
;;;1409       errorcode = HAL_ERROR;
;;;1410       goto error;
;;;1411     }
;;;1412   
;;;1413     if (hspi->State != HAL_SPI_STATE_READY)
;;;1414     {
;;;1415       errorcode = HAL_BUSY;
;;;1416       goto error;
;;;1417     }
;;;1418   
;;;1419     /* Set the transaction information */
;;;1420     hspi->State       = HAL_SPI_STATE_BUSY_TX;
;;;1421     hspi->ErrorCode   = HAL_SPI_ERROR_NONE;
;;;1422     hspi->pTxBuffPtr  = (uint8_t *)pData;
;;;1423     hspi->TxXferSize  = Size;
;;;1424     hspi->TxXferCount = Size;
;;;1425   
;;;1426     /* Init field not used in handle to zero */
;;;1427     hspi->pRxBuffPtr  = (uint8_t *)NULL;
;;;1428     hspi->RxXferSize  = 0U;
;;;1429     hspi->RxXferCount = 0U;
;;;1430     hspi->RxISR       = NULL;
;;;1431   
;;;1432     /* Set the function for IT treatment */
;;;1433     if (hspi->Init.DataSize > SPI_DATASIZE_8BIT)
;;;1434     {
;;;1435       hspi->TxISR = SPI_TxISR_16BIT;
;;;1436     }
;;;1437     else
;;;1438     {
;;;1439       hspi->TxISR = SPI_TxISR_8BIT;
;;;1440     }
;;;1441   
;;;1442     /* Configure communication direction : 1Line */
;;;1443     if (hspi->Init.Direction == SPI_DIRECTION_1LINE)
;;;1444     {
;;;1445       /* Disable SPI Peripheral before set 1Line direction (BIDIOE bit) */
;;;1446       __HAL_SPI_DISABLE(hspi);
;;;1447       SPI_1LINE_TX(hspi);
;;;1448     }
;;;1449   
;;;1450   #if (USE_SPI_CRC != 0U)
;;;1451     /* Reset CRC Calculation */
;;;1452     if (hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
;;;1453     {
;;;1454       SPI_RESET_CRC(hspi);
;;;1455     }
;;;1456   #endif /* USE_SPI_CRC */
;;;1457   
;;;1458     /* Enable TXE and ERR interrupt */
;;;1459     __HAL_SPI_ENABLE_IT(hspi, (SPI_IT_TXE | SPI_IT_ERR));
;;;1460   
;;;1461   
;;;1462     /* Check if the SPI is already enabled */
;;;1463     if ((hspi->Instance->CR1 & SPI_CR1_SPE) != SPI_CR1_SPE)
;;;1464     {
;;;1465       /* Enable SPI peripheral */
;;;1466       __HAL_SPI_ENABLE(hspi);
;;;1467     }
;;;1468   
;;;1469   error :
;;;1470     __HAL_UNLOCK(hspi);
;;;1471     return errorcode;
;;;1472   }
000030  e8bd81f0          POP      {r4-r8,pc}
                  |L25.52|
000034  2001              MOVS     r0,#1                 ;1405
000036  f8840050          STRB     r0,[r4,#0x50]         ;1405
00003a  bf00              NOP                            ;1405
00003c  b106              CBZ      r6,|L25.64|
00003e  b90d              CBNZ     r5,|L25.68|
                  |L25.64|
000040  2701              MOVS     r7,#1                 ;1409
000042  e03b              B        |L25.188|
                  |L25.68|
000044  f8940051          LDRB     r0,[r4,#0x51]         ;1413
000048  2801              CMP      r0,#1                 ;1413
00004a  d001              BEQ      |L25.80|
00004c  2702              MOVS     r7,#2                 ;1415
00004e  e035              B        |L25.188|
                  |L25.80|
000050  2003              MOVS     r0,#3                 ;1420
000052  f8840051          STRB     r0,[r4,#0x51]         ;1420
000056  2000              MOVS     r0,#0                 ;1421
000058  6560              STR      r0,[r4,#0x54]         ;1421
00005a  6326              STR      r6,[r4,#0x30]         ;1422
00005c  86a5              STRH     r5,[r4,#0x34]         ;1423
00005e  86e5              STRH     r5,[r4,#0x36]         ;1424
000060  63a0              STR      r0,[r4,#0x38]         ;1427
000062  87a0              STRH     r0,[r4,#0x3c]         ;1428
000064  87e0              STRH     r0,[r4,#0x3e]         ;1429
000066  6420              STR      r0,[r4,#0x40]         ;1430
000068  68e0              LDR      r0,[r4,#0xc]          ;1433
00006a  b110              CBZ      r0,|L25.114|
00006c  4825              LDR      r0,|L25.260|
00006e  6460              STR      r0,[r4,#0x44]         ;1435
000070  e001              B        |L25.118|
                  |L25.114|
000072  4825              LDR      r0,|L25.264|
000074  6460              STR      r0,[r4,#0x44]         ;1439
                  |L25.118|
000076  68a0              LDR      r0,[r4,#8]            ;1443
000078  f5b04f00          CMP      r0,#0x8000            ;1443
00007c  d10b              BNE      |L25.150|
00007e  6820              LDR      r0,[r4,#0]            ;1446
000080  6800              LDR      r0,[r0,#0]            ;1446
000082  f0200040          BIC      r0,r0,#0x40           ;1446
000086  6821              LDR      r1,[r4,#0]            ;1446
000088  6008              STR      r0,[r1,#0]            ;1446
00008a  6820              LDR      r0,[r4,#0]            ;1447
00008c  6800              LDR      r0,[r0,#0]            ;1447
00008e  f4404080          ORR      r0,r0,#0x4000         ;1447
000092  6821              LDR      r1,[r4,#0]            ;1447
000094  6008              STR      r0,[r1,#0]            ;1447
                  |L25.150|
000096  6820              LDR      r0,[r4,#0]            ;1459
000098  6840              LDR      r0,[r0,#4]            ;1459
00009a  f04000a0          ORR      r0,r0,#0xa0           ;1459
00009e  6821              LDR      r1,[r4,#0]            ;1459
0000a0  6048              STR      r0,[r1,#4]            ;1459
0000a2  6820              LDR      r0,[r4,#0]            ;1463
0000a4  6800              LDR      r0,[r0,#0]            ;1463
0000a6  f0000040          AND      r0,r0,#0x40           ;1463
0000aa  2840              CMP      r0,#0x40              ;1463
0000ac  d005              BEQ      |L25.186|
0000ae  6820              LDR      r0,[r4,#0]            ;1466
0000b0  6800              LDR      r0,[r0,#0]            ;1466
0000b2  f0400040          ORR      r0,r0,#0x40           ;1466
0000b6  6821              LDR      r1,[r4,#0]            ;1466
0000b8  6008              STR      r0,[r1,#0]            ;1466
                  |L25.186|
0000ba  bf00              NOP                            ;1469
                  |L25.188|
0000bc  bf00              NOP                            ;1470
0000be  2000              MOVS     r0,#0                 ;1470
0000c0  f8840050          STRB     r0,[r4,#0x50]         ;1470
0000c4  bf00              NOP                            ;1470
0000c6  4638              MOV      r0,r7                 ;1471
0000c8  e7b2              B        |L25.48|
;;;1473   
                          ENDP

0000ca  0000              DCW      0x0000
                  |L25.204|
0000cc  2e2e2f44          DCB      "../Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_spi.c"
0000d0  72697665
0000d4  72732f53
0000d8  544d3332
0000dc  46317878
0000e0  5f48414c
0000e4  5f447269
0000e8  7665722f
0000ec  5372632f
0000f0  73746d33
0000f4  32663178
0000f8  785f6861
0000fc  6c5f7370
000100  692e63  
000103  00                DCB      0
                  |L25.260|
                          DCD      SPI_TxISR_16BIT
                  |L25.264|
                          DCD      SPI_TxISR_8BIT

                          AREA ||i.HAL_SPI_TxCpltCallback||, CODE, READONLY, ALIGN=1

                  HAL_SPI_TxCpltCallback PROC
;;;2518     */
;;;2519   __weak void HAL_SPI_TxCpltCallback(SPI_HandleTypeDef *hspi)
000000  4770              BX       lr
;;;2520   {
;;;2521     /* Prevent unused argument(s) compilation warning */
;;;2522     UNUSED(hspi);
;;;2523   
;;;2524     /* NOTE : This function should not be modified, when the callback is needed,
;;;2525               the HAL_SPI_TxCpltCallback should be implemented in the user file
;;;2526      */
;;;2527   }
;;;2528   
                          ENDP


                          AREA ||i.HAL_SPI_TxHalfCpltCallback||, CODE, READONLY, ALIGN=1

                  HAL_SPI_TxHalfCpltCallback PROC
;;;2566     */
;;;2567   __weak void HAL_SPI_TxHalfCpltCallback(SPI_HandleTypeDef *hspi)
000000  4770              BX       lr
;;;2568   {
;;;2569     /* Prevent unused argument(s) compilation warning */
;;;2570     UNUSED(hspi);
;;;2571   
;;;2572     /* NOTE : This function should not be modified, when the callback is needed,
;;;2573               the HAL_SPI_TxHalfCpltCallback should be implemented in the user file
;;;2574      */
;;;2575   }
;;;2576   
                          ENDP


                          AREA ||i.HAL_SPI_TxRxCpltCallback||, CODE, READONLY, ALIGN=1

                  HAL_SPI_TxRxCpltCallback PROC
;;;2550     */
;;;2551   __weak void HAL_SPI_TxRxCpltCallback(SPI_HandleTypeDef *hspi)
000000  4770              BX       lr
;;;2552   {
;;;2553     /* Prevent unused argument(s) compilation warning */
;;;2554     UNUSED(hspi);
;;;2555   
;;;2556     /* NOTE : This function should not be modified, when the callback is needed,
;;;2557               the HAL_SPI_TxRxCpltCallback should be implemented in the user file
;;;2558      */
;;;2559   }
;;;2560   
                          ENDP


                          AREA ||i.HAL_SPI_TxRxHalfCpltCallback||, CODE, READONLY, ALIGN=1

                  HAL_SPI_TxRxHalfCpltCallback PROC
;;;2598     */
;;;2599   __weak void HAL_SPI_TxRxHalfCpltCallback(SPI_HandleTypeDef *hspi)
000000  4770              BX       lr
;;;2600   {
;;;2601     /* Prevent unused argument(s) compilation warning */
;;;2602     UNUSED(hspi);
;;;2603   
;;;2604     /* NOTE : This function should not be modified, when the callback is needed,
;;;2605               the HAL_SPI_TxRxHalfCpltCallback() should be implemented in the user file
;;;2606      */
;;;2607   }
;;;2608   
                          ENDP


                          AREA ||i.SPI_2linesRxISR_16BIT||, CODE, READONLY, ALIGN=1

                  SPI_2linesRxISR_16BIT PROC
;;;3253     */
;;;3254   static void SPI_2linesRxISR_16BIT(struct __SPI_HandleTypeDef *hspi)
000000  b510              PUSH     {r4,lr}
;;;3255   {
000002  4604              MOV      r4,r0
;;;3256     /* Receive data in 16 Bit mode */
;;;3257     *((uint16_t *)hspi->pRxBuffPtr) = (uint16_t)(hspi->Instance->DR);
000004  6820              LDR      r0,[r4,#0]
000006  68c0              LDR      r0,[r0,#0xc]
000008  6ba1              LDR      r1,[r4,#0x38]
00000a  8008              STRH     r0,[r1,#0]
;;;3258     hspi->pRxBuffPtr += sizeof(uint16_t);
00000c  6ba0              LDR      r0,[r4,#0x38]
00000e  1c80              ADDS     r0,r0,#2
000010  63a0              STR      r0,[r4,#0x38]
;;;3259     hspi->RxXferCount--;
000012  8fe0              LDRH     r0,[r4,#0x3e]
000014  1e40              SUBS     r0,r0,#1
000016  87e0              STRH     r0,[r4,#0x3e]
;;;3260   
;;;3261     if (hspi->RxXferCount == 0U)
000018  8fe0              LDRH     r0,[r4,#0x3e]
00001a  b950              CBNZ     r0,|L30.50|
;;;3262     {
;;;3263   #if (USE_SPI_CRC != 0U)
;;;3264       if (hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
;;;3265       {
;;;3266         hspi->RxISR =  SPI_2linesRxISR_16BITCRC;
;;;3267         return;
;;;3268       }
;;;3269   #endif /* USE_SPI_CRC */
;;;3270   
;;;3271       /* Disable RXNE interrupt */
;;;3272       __HAL_SPI_DISABLE_IT(hspi, SPI_IT_RXNE);
00001c  6820              LDR      r0,[r4,#0]
00001e  6840              LDR      r0,[r0,#4]
000020  f0200040          BIC      r0,r0,#0x40
000024  6821              LDR      r1,[r4,#0]
000026  6048              STR      r0,[r1,#4]
;;;3273   
;;;3274       if (hspi->TxXferCount == 0U)
000028  8ee0              LDRH     r0,[r4,#0x36]
00002a  b910              CBNZ     r0,|L30.50|
;;;3275       {
;;;3276         SPI_CloseRxTx_ISR(hspi);
00002c  4620              MOV      r0,r4
00002e  f7fffffe          BL       SPI_CloseRxTx_ISR
                  |L30.50|
;;;3277       }
;;;3278     }
;;;3279   }
000032  bd10              POP      {r4,pc}
;;;3280   
                          ENDP


                          AREA ||i.SPI_2linesRxISR_8BIT||, CODE, READONLY, ALIGN=1

                  SPI_2linesRxISR_8BIT PROC
;;;3161     */
;;;3162   static void SPI_2linesRxISR_8BIT(struct __SPI_HandleTypeDef *hspi)
000000  b510              PUSH     {r4,lr}
;;;3163   {
000002  4604              MOV      r4,r0
;;;3164     /* Receive data in 8bit mode */
;;;3165     *hspi->pRxBuffPtr = *((__IO uint8_t *)&hspi->Instance->DR);
000004  6820              LDR      r0,[r4,#0]
000006  7b00              LDRB     r0,[r0,#0xc]
000008  6ba1              LDR      r1,[r4,#0x38]
00000a  7008              STRB     r0,[r1,#0]
;;;3166     hspi->pRxBuffPtr++;
00000c  6ba0              LDR      r0,[r4,#0x38]
00000e  1c40              ADDS     r0,r0,#1
000010  63a0              STR      r0,[r4,#0x38]
;;;3167     hspi->RxXferCount--;
000012  8fe0              LDRH     r0,[r4,#0x3e]
000014  1e40              SUBS     r0,r0,#1
000016  87e0              STRH     r0,[r4,#0x3e]
;;;3168   
;;;3169     /* Check end of the reception */
;;;3170     if (hspi->RxXferCount == 0U)
000018  8fe0              LDRH     r0,[r4,#0x3e]
00001a  b950              CBNZ     r0,|L31.50|
;;;3171     {
;;;3172   #if (USE_SPI_CRC != 0U)
;;;3173       if (hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
;;;3174       {
;;;3175         hspi->RxISR =  SPI_2linesRxISR_8BITCRC;
;;;3176         return;
;;;3177       }
;;;3178   #endif /* USE_SPI_CRC */
;;;3179   
;;;3180       /* Disable RXNE  and ERR interrupt */
;;;3181       __HAL_SPI_DISABLE_IT(hspi, (SPI_IT_RXNE | SPI_IT_ERR));
00001c  6820              LDR      r0,[r4,#0]
00001e  6840              LDR      r0,[r0,#4]
000020  f0200060          BIC      r0,r0,#0x60
000024  6821              LDR      r1,[r4,#0]
000026  6048              STR      r0,[r1,#4]
;;;3182   
;;;3183       if (hspi->TxXferCount == 0U)
000028  8ee0              LDRH     r0,[r4,#0x36]
00002a  b910              CBNZ     r0,|L31.50|
;;;3184       {
;;;3185         SPI_CloseRxTx_ISR(hspi);
00002c  4620              MOV      r0,r4
00002e  f7fffffe          BL       SPI_CloseRxTx_ISR
                  |L31.50|
;;;3186       }
;;;3187     }
;;;3188   }
000032  bd10              POP      {r4,pc}
;;;3189   
                          ENDP


                          AREA ||i.SPI_2linesTxISR_16BIT||, CODE, READONLY, ALIGN=1

                  SPI_2linesTxISR_16BIT PROC
;;;3305     */
;;;3306   static void SPI_2linesTxISR_16BIT(struct __SPI_HandleTypeDef *hspi)
000000  b510              PUSH     {r4,lr}
;;;3307   {
000002  4604              MOV      r4,r0
;;;3308     /* Transmit data in 16 Bit mode */
;;;3309     hspi->Instance->DR = *((uint16_t *)hspi->pTxBuffPtr);
000004  6b20              LDR      r0,[r4,#0x30]
000006  8800              LDRH     r0,[r0,#0]
000008  6821              LDR      r1,[r4,#0]
00000a  60c8              STR      r0,[r1,#0xc]
;;;3310     hspi->pTxBuffPtr += sizeof(uint16_t);
00000c  6b20              LDR      r0,[r4,#0x30]
00000e  1c80              ADDS     r0,r0,#2
000010  6320              STR      r0,[r4,#0x30]
;;;3311     hspi->TxXferCount--;
000012  8ee0              LDRH     r0,[r4,#0x36]
000014  1e40              SUBS     r0,r0,#1
000016  86e0              STRH     r0,[r4,#0x36]
;;;3312   
;;;3313     /* Enable CRC Transmission */
;;;3314     if (hspi->TxXferCount == 0U)
000018  8ee0              LDRH     r0,[r4,#0x36]
00001a  b950              CBNZ     r0,|L32.50|
;;;3315     {
;;;3316   #if (USE_SPI_CRC != 0U)
;;;3317       if (hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
;;;3318       {
;;;3319         /* Set CRC Next Bit to send CRC */
;;;3320         SET_BIT(hspi->Instance->CR1, SPI_CR1_CRCNEXT);
;;;3321         /* Disable TXE interrupt */
;;;3322         __HAL_SPI_DISABLE_IT(hspi, SPI_IT_TXE);
;;;3323         return;
;;;3324       }
;;;3325   #endif /* USE_SPI_CRC */
;;;3326   
;;;3327       /* Disable TXE interrupt */
;;;3328       __HAL_SPI_DISABLE_IT(hspi, SPI_IT_TXE);
00001c  6820              LDR      r0,[r4,#0]
00001e  6840              LDR      r0,[r0,#4]
000020  f0200080          BIC      r0,r0,#0x80
000024  6821              LDR      r1,[r4,#0]
000026  6048              STR      r0,[r1,#4]
;;;3329   
;;;3330       if (hspi->RxXferCount == 0U)
000028  8fe0              LDRH     r0,[r4,#0x3e]
00002a  b910              CBNZ     r0,|L32.50|
;;;3331       {
;;;3332         SPI_CloseRxTx_ISR(hspi);
00002c  4620              MOV      r0,r4
00002e  f7fffffe          BL       SPI_CloseRxTx_ISR
                  |L32.50|
;;;3333       }
;;;3334     }
;;;3335   }
000032  bd10              POP      {r4,pc}
;;;3336   
                          ENDP


                          AREA ||i.SPI_2linesTxISR_8BIT||, CODE, READONLY, ALIGN=1

                  SPI_2linesTxISR_8BIT PROC
;;;3217     */
;;;3218   static void SPI_2linesTxISR_8BIT(struct __SPI_HandleTypeDef *hspi)
000000  b510              PUSH     {r4,lr}
;;;3219   {
000002  4604              MOV      r4,r0
;;;3220     *(__IO uint8_t *)&hspi->Instance->DR = (*hspi->pTxBuffPtr);
000004  6b20              LDR      r0,[r4,#0x30]
000006  7800              LDRB     r0,[r0,#0]
000008  6821              LDR      r1,[r4,#0]
00000a  7308              STRB     r0,[r1,#0xc]
;;;3221     hspi->pTxBuffPtr++;
00000c  6b20              LDR      r0,[r4,#0x30]
00000e  1c40              ADDS     r0,r0,#1
000010  6320              STR      r0,[r4,#0x30]
;;;3222     hspi->TxXferCount--;
000012  8ee0              LDRH     r0,[r4,#0x36]
000014  1e40              SUBS     r0,r0,#1
000016  86e0              STRH     r0,[r4,#0x36]
;;;3223   
;;;3224     /* Check the end of the transmission */
;;;3225     if (hspi->TxXferCount == 0U)
000018  8ee0              LDRH     r0,[r4,#0x36]
00001a  b950              CBNZ     r0,|L33.50|
;;;3226     {
;;;3227   #if (USE_SPI_CRC != 0U)
;;;3228       if (hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
;;;3229       {
;;;3230         /* Set CRC Next Bit to send CRC */
;;;3231         SET_BIT(hspi->Instance->CR1, SPI_CR1_CRCNEXT);
;;;3232         /* Disable TXE interrupt */
;;;3233         __HAL_SPI_DISABLE_IT(hspi, SPI_IT_TXE);
;;;3234         return;
;;;3235       }
;;;3236   #endif /* USE_SPI_CRC */
;;;3237   
;;;3238       /* Disable TXE interrupt */
;;;3239       __HAL_SPI_DISABLE_IT(hspi, SPI_IT_TXE);
00001c  6820              LDR      r0,[r4,#0]
00001e  6840              LDR      r0,[r0,#4]
000020  f0200080          BIC      r0,r0,#0x80
000024  6821              LDR      r1,[r4,#0]
000026  6048              STR      r0,[r1,#4]
;;;3240   
;;;3241       if (hspi->RxXferCount == 0U)
000028  8fe0              LDRH     r0,[r4,#0x3e]
00002a  b910              CBNZ     r0,|L33.50|
;;;3242       {
;;;3243         SPI_CloseRxTx_ISR(hspi);
00002c  4620              MOV      r0,r4
00002e  f7fffffe          BL       SPI_CloseRxTx_ISR
                  |L33.50|
;;;3244       }
;;;3245     }
;;;3246   }
000032  bd10              POP      {r4,pc}
;;;3247   
                          ENDP


                          AREA ||i.SPI_AbortRx_ISR||, CODE, READONLY, ALIGN=2

                  SPI_AbortRx_ISR PROC
;;;3874     */
;;;3875   static void SPI_AbortRx_ISR(SPI_HandleTypeDef *hspi)
000000  b508              PUSH     {r3,lr}
;;;3876   {
;;;3877     __IO uint32_t count = SPI_DEFAULT_TIMEOUT * (SystemCoreClock / 24U / 1000U);
000002  4918              LDR      r1,|L34.100|
000004  6809              LDR      r1,[r1,#0]  ; SystemCoreClock
000006  2218              MOVS     r2,#0x18
000008  fbb1f1f2          UDIV     r1,r1,r2
00000c  f44f727a          MOV      r2,#0x3e8
000010  fbb1f1f2          UDIV     r1,r1,r2
000014  2264              MOVS     r2,#0x64
000016  4351              MULS     r1,r2,r1
000018  9100              STR      r1,[sp,#0]
;;;3878   
;;;3879     /* Wait until TXE flag is set */
;;;3880     do
00001a  bf00              NOP      
                  |L34.28|
;;;3881     {
;;;3882       if (count == 0U)
00001c  9900              LDR      r1,[sp,#0]
00001e  b921              CBNZ     r1,|L34.42|
;;;3883       {
;;;3884         SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_ABORT);
000020  6d41              LDR      r1,[r0,#0x54]
000022  f0410140          ORR      r1,r1,#0x40
000026  6541              STR      r1,[r0,#0x54]
;;;3885         break;
000028  e008              B        |L34.60|
                  |L34.42|
;;;3886       }
;;;3887       count--;
00002a  9900              LDR      r1,[sp,#0]
00002c  1e49              SUBS     r1,r1,#1
00002e  9100              STR      r1,[sp,#0]
;;;3888     } while ((hspi->Instance->SR & SPI_FLAG_TXE) == RESET);
000030  6801              LDR      r1,[r0,#0]
000032  6889              LDR      r1,[r1,#8]
000034  f0010102          AND      r1,r1,#2
000038  2900              CMP      r1,#0
00003a  d0ef              BEQ      |L34.28|
                  |L34.60|
00003c  bf00              NOP                            ;3885
;;;3889   
;;;3890     /* Disable SPI Peripheral */
;;;3891     __HAL_SPI_DISABLE(hspi);
00003e  6801              LDR      r1,[r0,#0]
000040  6809              LDR      r1,[r1,#0]
000042  f0210140          BIC      r1,r1,#0x40
000046  6802              LDR      r2,[r0,#0]
000048  6011              STR      r1,[r2,#0]
;;;3892   
;;;3893     /* Disable TXEIE, RXNEIE and ERRIE(mode fault event, overrun error, TI frame error) interrupts */
;;;3894     CLEAR_BIT(hspi->Instance->CR2, (SPI_CR2_TXEIE | SPI_CR2_RXNEIE | SPI_CR2_ERRIE));
00004a  6801              LDR      r1,[r0,#0]
00004c  6849              LDR      r1,[r1,#4]
00004e  f02101e0          BIC      r1,r1,#0xe0
000052  6802              LDR      r2,[r0,#0]
000054  6051              STR      r1,[r2,#4]
;;;3895   
;;;3896     /* Read CRC to flush Data Register */
;;;3897     READ_REG(hspi->Instance->DR);
000056  6801              LDR      r1,[r0,#0]
000058  68c9              LDR      r1,[r1,#0xc]
;;;3898   
;;;3899     hspi->State = HAL_SPI_STATE_ABORT;
00005a  2107              MOVS     r1,#7
00005c  f8801051          STRB     r1,[r0,#0x51]
;;;3900   }
000060  bd08              POP      {r3,pc}
;;;3901   
                          ENDP

000062  0000              DCW      0x0000
                  |L34.100|
                          DCD      SystemCoreClock

                          AREA ||i.SPI_AbortTx_ISR||, CODE, READONLY, ALIGN=1

                  SPI_AbortTx_ISR PROC
;;;3907     */
;;;3908   static void SPI_AbortTx_ISR(SPI_HandleTypeDef *hspi)
000000  6801              LDR      r1,[r0,#0]
;;;3909   {
;;;3910     /* Disable TXEIE interrupt */
;;;3911     CLEAR_BIT(hspi->Instance->CR2, (SPI_CR2_TXEIE));
000002  6849              LDR      r1,[r1,#4]
000004  f0210180          BIC      r1,r1,#0x80
000008  6802              LDR      r2,[r0,#0]
00000a  6051              STR      r1,[r2,#4]
;;;3912   
;;;3913     /* Disable SPI Peripheral */
;;;3914     __HAL_SPI_DISABLE(hspi);
00000c  6801              LDR      r1,[r0,#0]
00000e  6809              LDR      r1,[r1,#0]
000010  f0210140          BIC      r1,r1,#0x40
000014  6802              LDR      r2,[r0,#0]
000016  6011              STR      r1,[r2,#0]
;;;3915   
;;;3916     hspi->State = HAL_SPI_STATE_ABORT;
000018  2107              MOVS     r1,#7
00001a  f8801051          STRB     r1,[r0,#0x51]
;;;3917   }
00001e  4770              BX       lr
;;;3918   
                          ENDP


                          AREA ||i.SPI_CloseRxTx_ISR||, CODE, READONLY, ALIGN=2

                  SPI_CloseRxTx_ISR PROC
;;;3633     */
;;;3634   static void SPI_CloseRxTx_ISR(SPI_HandleTypeDef *hspi)
000000  b57c              PUSH     {r2-r6,lr}
;;;3635   {
000002  4604              MOV      r4,r0
;;;3636     uint32_t tickstart;
;;;3637     __IO uint32_t count = SPI_DEFAULT_TIMEOUT * (SystemCoreClock / 24U / 1000U);
000004  482c              LDR      r0,|L36.184|
000006  6800              LDR      r0,[r0,#0]  ; SystemCoreClock
000008  2118              MOVS     r1,#0x18
00000a  fbb0f0f1          UDIV     r0,r0,r1
00000e  f44f717a          MOV      r1,#0x3e8
000012  fbb0f0f1          UDIV     r0,r0,r1
000016  2164              MOVS     r1,#0x64
000018  4348              MULS     r0,r1,r0
00001a  9001              STR      r0,[sp,#4]
;;;3638   
;;;3639     /* Init tickstart for timeout management */
;;;3640     tickstart = HAL_GetTick();
00001c  f7fffffe          BL       HAL_GetTick
000020  4605              MOV      r5,r0
;;;3641   
;;;3642     /* Disable ERR interrupt */
;;;3643     __HAL_SPI_DISABLE_IT(hspi, SPI_IT_ERR);
000022  6820              LDR      r0,[r4,#0]
000024  6840              LDR      r0,[r0,#4]
000026  f0200020          BIC      r0,r0,#0x20
00002a  6821              LDR      r1,[r4,#0]
00002c  6048              STR      r0,[r1,#4]
;;;3644   
;;;3645     /* Wait until TXE flag is set */
;;;3646     do
00002e  bf00              NOP      
                  |L36.48|
;;;3647     {
;;;3648       if (count == 0U)
000030  9801              LDR      r0,[sp,#4]
000032  b920              CBNZ     r0,|L36.62|
;;;3649       {
;;;3650         SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_FLAG);
000034  6d60              LDR      r0,[r4,#0x54]
000036  f0400020          ORR      r0,r0,#0x20
00003a  6560              STR      r0,[r4,#0x54]
;;;3651         break;
00003c  e008              B        |L36.80|
                  |L36.62|
;;;3652       }
;;;3653       count--;
00003e  9801              LDR      r0,[sp,#4]
000040  1e40              SUBS     r0,r0,#1
000042  9001              STR      r0,[sp,#4]
;;;3654     } while ((hspi->Instance->SR & SPI_FLAG_TXE) == RESET);
000044  6820              LDR      r0,[r4,#0]
000046  6880              LDR      r0,[r0,#8]
000048  f0000002          AND      r0,r0,#2
00004c  2800              CMP      r0,#0
00004e  d0ef              BEQ      |L36.48|
                  |L36.80|
000050  bf00              NOP                            ;3651
;;;3655   
;;;3656     /* Check the end of the transaction */
;;;3657     if (SPI_EndRxTxTransaction(hspi, SPI_DEFAULT_TIMEOUT, tickstart) != HAL_OK)
000052  462a              MOV      r2,r5
000054  2164              MOVS     r1,#0x64
000056  4620              MOV      r0,r4
000058  f7fffffe          BL       SPI_EndRxTxTransaction
00005c  b118              CBZ      r0,|L36.102|
;;;3658     {
;;;3659       SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_FLAG);
00005e  6d60              LDR      r0,[r4,#0x54]
000060  f0400020          ORR      r0,r0,#0x20
000064  6560              STR      r0,[r4,#0x54]
                  |L36.102|
;;;3660     }
;;;3661   
;;;3662     /* Clear overrun flag in 2 Lines communication mode because received is not read */
;;;3663     if (hspi->Init.Direction == SPI_DIRECTION_2LINES)
000066  68a0              LDR      r0,[r4,#8]
000068  b950              CBNZ     r0,|L36.128|
;;;3664     {
;;;3665       __HAL_SPI_CLEAR_OVRFLAG(hspi);
00006a  bf00              NOP      
00006c  2000              MOVS     r0,#0
00006e  9000              STR      r0,[sp,#0]
000070  6820              LDR      r0,[r4,#0]
000072  68c0              LDR      r0,[r0,#0xc]
000074  9000              STR      r0,[sp,#0]
000076  6820              LDR      r0,[r4,#0]
000078  6880              LDR      r0,[r0,#8]
00007a  9000              STR      r0,[sp,#0]
00007c  bf00              NOP      
00007e  bf00              NOP      
                  |L36.128|
;;;3666     }
;;;3667   
;;;3668   #if (USE_SPI_CRC != 0U)
;;;3669     /* Check if CRC error occurred */
;;;3670     if (__HAL_SPI_GET_FLAG(hspi, SPI_FLAG_CRCERR) != RESET)
;;;3671     {
;;;3672       /* Check if CRC error is valid or not (workaround to be applied or not) */
;;;3673       if (SPI_ISCRCErrorValid(hspi) == SPI_VALID_CRC_ERROR)
;;;3674       {
;;;3675         hspi->State = HAL_SPI_STATE_READY;
;;;3676         SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_CRC);
;;;3677   
;;;3678         /* Reset CRC Calculation */
;;;3679         SPI_RESET_CRC(hspi);
;;;3680   
;;;3681         /* Call user error callback */
;;;3682   #if (USE_HAL_SPI_REGISTER_CALLBACKS == 1U)
;;;3683         hspi->ErrorCallback(hspi);
;;;3684   #else
;;;3685         HAL_SPI_ErrorCallback(hspi);
;;;3686   #endif /* USE_HAL_SPI_REGISTER_CALLBACKS */
;;;3687       }
;;;3688       else
;;;3689       {
;;;3690         __HAL_SPI_CLEAR_CRCERRFLAG(hspi);
;;;3691       }
;;;3692     }
;;;3693     else
;;;3694     {
;;;3695   #endif /* USE_SPI_CRC */
;;;3696       if (hspi->ErrorCode == HAL_SPI_ERROR_NONE)
000080  6d60              LDR      r0,[r4,#0x54]
000082  b988              CBNZ     r0,|L36.168|
;;;3697       {
;;;3698         if (hspi->State == HAL_SPI_STATE_BUSY_RX)
000084  f8940051          LDRB     r0,[r4,#0x51]
000088  2804              CMP      r0,#4
00008a  d106              BNE      |L36.154|
;;;3699         {
;;;3700           hspi->State = HAL_SPI_STATE_READY;
00008c  2001              MOVS     r0,#1
00008e  f8840051          STRB     r0,[r4,#0x51]
;;;3701           /* Call user Rx complete callback */
;;;3702   #if (USE_HAL_SPI_REGISTER_CALLBACKS == 1U)
;;;3703           hspi->RxCpltCallback(hspi);
;;;3704   #else
;;;3705           HAL_SPI_RxCpltCallback(hspi);
000092  4620              MOV      r0,r4
000094  f7fffffe          BL       HAL_SPI_RxCpltCallback
000098  e00c              B        |L36.180|
                  |L36.154|
;;;3706   #endif /* USE_HAL_SPI_REGISTER_CALLBACKS */
;;;3707         }
;;;3708         else
;;;3709         {
;;;3710           hspi->State = HAL_SPI_STATE_READY;
00009a  2001              MOVS     r0,#1
00009c  f8840051          STRB     r0,[r4,#0x51]
;;;3711           /* Call user TxRx complete callback */
;;;3712   #if (USE_HAL_SPI_REGISTER_CALLBACKS == 1U)
;;;3713           hspi->TxRxCpltCallback(hspi);
;;;3714   #else
;;;3715           HAL_SPI_TxRxCpltCallback(hspi);
0000a0  4620              MOV      r0,r4
0000a2  f7fffffe          BL       HAL_SPI_TxRxCpltCallback
0000a6  e005              B        |L36.180|
                  |L36.168|
;;;3716   #endif /* USE_HAL_SPI_REGISTER_CALLBACKS */
;;;3717         }
;;;3718       }
;;;3719       else
;;;3720       {
;;;3721         hspi->State = HAL_SPI_STATE_READY;
0000a8  2001              MOVS     r0,#1
0000aa  f8840051          STRB     r0,[r4,#0x51]
;;;3722         /* Call user error callback */
;;;3723   #if (USE_HAL_SPI_REGISTER_CALLBACKS == 1U)
;;;3724         hspi->ErrorCallback(hspi);
;;;3725   #else
;;;3726         HAL_SPI_ErrorCallback(hspi);
0000ae  4620              MOV      r0,r4
0000b0  f7fffffe          BL       HAL_SPI_ErrorCallback
                  |L36.180|
;;;3727   #endif /* USE_HAL_SPI_REGISTER_CALLBACKS */
;;;3728       }
;;;3729   #if (USE_SPI_CRC != 0U)
;;;3730     }
;;;3731   #endif /* USE_SPI_CRC */
;;;3732   }
0000b4  bd7c              POP      {r2-r6,pc}
;;;3733   
                          ENDP

0000b6  0000              DCW      0x0000
                  |L36.184|
                          DCD      SystemCoreClock

                          AREA ||i.SPI_CloseRx_ISR||, CODE, READONLY, ALIGN=1

                  SPI_CloseRx_ISR PROC
;;;3739     */
;;;3740   static void SPI_CloseRx_ISR(SPI_HandleTypeDef *hspi)
000000  b538              PUSH     {r3-r5,lr}
;;;3741   {
000002  4604              MOV      r4,r0
;;;3742     /* Disable RXNE and ERR interrupt */
;;;3743     __HAL_SPI_DISABLE_IT(hspi, (SPI_IT_RXNE | SPI_IT_ERR));
000004  6820              LDR      r0,[r4,#0]
000006  6840              LDR      r0,[r0,#4]
000008  f0200060          BIC      r0,r0,#0x60
00000c  6821              LDR      r1,[r4,#0]
00000e  6048              STR      r0,[r1,#4]
;;;3744   
;;;3745     /* Check the end of the transaction */
;;;3746     if (SPI_EndRxTransaction(hspi, SPI_DEFAULT_TIMEOUT, HAL_GetTick()) != HAL_OK)
000010  f7fffffe          BL       HAL_GetTick
000014  4605              MOV      r5,r0
000016  462a              MOV      r2,r5
000018  2164              MOVS     r1,#0x64
00001a  4620              MOV      r0,r4
00001c  f7fffffe          BL       SPI_EndRxTransaction
000020  b118              CBZ      r0,|L37.42|
;;;3747     {
;;;3748       SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_FLAG);
000022  6d60              LDR      r0,[r4,#0x54]
000024  f0400020          ORR      r0,r0,#0x20
000028  6560              STR      r0,[r4,#0x54]
                  |L37.42|
;;;3749     }
;;;3750   
;;;3751     /* Clear overrun flag in 2 Lines communication mode because received is not read */
;;;3752     if (hspi->Init.Direction == SPI_DIRECTION_2LINES)
00002a  68a0              LDR      r0,[r4,#8]
00002c  b950              CBNZ     r0,|L37.68|
;;;3753     {
;;;3754       __HAL_SPI_CLEAR_OVRFLAG(hspi);
00002e  bf00              NOP      
000030  2000              MOVS     r0,#0
000032  9000              STR      r0,[sp,#0]
000034  6820              LDR      r0,[r4,#0]
000036  68c0              LDR      r0,[r0,#0xc]
000038  9000              STR      r0,[sp,#0]
00003a  6820              LDR      r0,[r4,#0]
00003c  6880              LDR      r0,[r0,#8]
00003e  9000              STR      r0,[sp,#0]
000040  bf00              NOP      
000042  bf00              NOP      
                  |L37.68|
;;;3755     }
;;;3756     hspi->State = HAL_SPI_STATE_READY;
000044  2001              MOVS     r0,#1
000046  f8840051          STRB     r0,[r4,#0x51]
;;;3757   
;;;3758   #if (USE_SPI_CRC != 0U)
;;;3759     /* Check if CRC error occurred */
;;;3760     if (__HAL_SPI_GET_FLAG(hspi, SPI_FLAG_CRCERR) != RESET)
;;;3761     {
;;;3762       /* Check if CRC error is valid or not (workaround to be applied or not) */
;;;3763       if (SPI_ISCRCErrorValid(hspi) == SPI_VALID_CRC_ERROR)
;;;3764       {
;;;3765         SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_CRC);
;;;3766   
;;;3767         /* Reset CRC Calculation */
;;;3768         SPI_RESET_CRC(hspi);
;;;3769   
;;;3770         /* Call user error callback */
;;;3771   #if (USE_HAL_SPI_REGISTER_CALLBACKS == 1U)
;;;3772         hspi->ErrorCallback(hspi);
;;;3773   #else
;;;3774         HAL_SPI_ErrorCallback(hspi);
;;;3775   #endif /* USE_HAL_SPI_REGISTER_CALLBACKS */
;;;3776       }
;;;3777       else
;;;3778       {
;;;3779         __HAL_SPI_CLEAR_CRCERRFLAG(hspi);
;;;3780       }
;;;3781     }
;;;3782     else
;;;3783     {
;;;3784   #endif /* USE_SPI_CRC */
;;;3785       if (hspi->ErrorCode == HAL_SPI_ERROR_NONE)
00004a  6d60              LDR      r0,[r4,#0x54]
00004c  b918              CBNZ     r0,|L37.86|
;;;3786       {
;;;3787         /* Call user Rx complete callback */
;;;3788   #if (USE_HAL_SPI_REGISTER_CALLBACKS == 1U)
;;;3789         hspi->RxCpltCallback(hspi);
;;;3790   #else
;;;3791         HAL_SPI_RxCpltCallback(hspi);
00004e  4620              MOV      r0,r4
000050  f7fffffe          BL       HAL_SPI_RxCpltCallback
000054  e002              B        |L37.92|
                  |L37.86|
;;;3792   #endif /* USE_HAL_SPI_REGISTER_CALLBACKS */
;;;3793       }
;;;3794       else
;;;3795       {
;;;3796         /* Call user error callback */
;;;3797   #if (USE_HAL_SPI_REGISTER_CALLBACKS == 1U)
;;;3798         hspi->ErrorCallback(hspi);
;;;3799   #else
;;;3800         HAL_SPI_ErrorCallback(hspi);
000056  4620              MOV      r0,r4
000058  f7fffffe          BL       HAL_SPI_ErrorCallback
                  |L37.92|
;;;3801   #endif /* USE_HAL_SPI_REGISTER_CALLBACKS */
;;;3802       }
;;;3803   #if (USE_SPI_CRC != 0U)
;;;3804     }
;;;3805   #endif /* USE_SPI_CRC */
;;;3806   }
00005c  bd38              POP      {r3-r5,pc}
;;;3807   
                          ENDP


                          AREA ||i.SPI_CloseTx_ISR||, CODE, READONLY, ALIGN=2

                  SPI_CloseTx_ISR PROC
;;;3813     */
;;;3814   static void SPI_CloseTx_ISR(SPI_HandleTypeDef *hspi)
000000  b57c              PUSH     {r2-r6,lr}
;;;3815   {
000002  4604              MOV      r4,r0
;;;3816     uint32_t tickstart;
;;;3817     __IO uint32_t count = SPI_DEFAULT_TIMEOUT * (SystemCoreClock / 24U / 1000U);
000004  4825              LDR      r0,|L38.156|
000006  6800              LDR      r0,[r0,#0]  ; SystemCoreClock
000008  2118              MOVS     r1,#0x18
00000a  fbb0f0f1          UDIV     r0,r0,r1
00000e  f44f717a          MOV      r1,#0x3e8
000012  fbb0f0f1          UDIV     r0,r0,r1
000016  2164              MOVS     r1,#0x64
000018  4348              MULS     r0,r1,r0
00001a  9001              STR      r0,[sp,#4]
;;;3818   
;;;3819     /* Init tickstart for timeout management*/
;;;3820     tickstart = HAL_GetTick();
00001c  f7fffffe          BL       HAL_GetTick
000020  4605              MOV      r5,r0
;;;3821   
;;;3822     /* Wait until TXE flag is set */
;;;3823     do
000022  bf00              NOP      
                  |L38.36|
;;;3824     {
;;;3825       if (count == 0U)
000024  9801              LDR      r0,[sp,#4]
000026  b920              CBNZ     r0,|L38.50|
;;;3826       {
;;;3827         SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_FLAG);
000028  6d60              LDR      r0,[r4,#0x54]
00002a  f0400020          ORR      r0,r0,#0x20
00002e  6560              STR      r0,[r4,#0x54]
;;;3828         break;
000030  e008              B        |L38.68|
                  |L38.50|
;;;3829       }
;;;3830       count--;
000032  9801              LDR      r0,[sp,#4]
000034  1e40              SUBS     r0,r0,#1
000036  9001              STR      r0,[sp,#4]
;;;3831     } while ((hspi->Instance->SR & SPI_FLAG_TXE) == RESET);
000038  6820              LDR      r0,[r4,#0]
00003a  6880              LDR      r0,[r0,#8]
00003c  f0000002          AND      r0,r0,#2
000040  2800              CMP      r0,#0
000042  d0ef              BEQ      |L38.36|
                  |L38.68|
000044  bf00              NOP                            ;3828
;;;3832   
;;;3833     /* Disable TXE and ERR interrupt */
;;;3834     __HAL_SPI_DISABLE_IT(hspi, (SPI_IT_TXE | SPI_IT_ERR));
000046  6820              LDR      r0,[r4,#0]
000048  6840              LDR      r0,[r0,#4]
00004a  f02000a0          BIC      r0,r0,#0xa0
00004e  6821              LDR      r1,[r4,#0]
000050  6048              STR      r0,[r1,#4]
;;;3835   
;;;3836     /* Check the end of the transaction */
;;;3837     if (SPI_EndRxTxTransaction(hspi, SPI_DEFAULT_TIMEOUT, tickstart) != HAL_OK)
000052  462a              MOV      r2,r5
000054  2164              MOVS     r1,#0x64
000056  4620              MOV      r0,r4
000058  f7fffffe          BL       SPI_EndRxTxTransaction
00005c  b118              CBZ      r0,|L38.102|
;;;3838     {
;;;3839       SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_FLAG);
00005e  6d60              LDR      r0,[r4,#0x54]
000060  f0400020          ORR      r0,r0,#0x20
000064  6560              STR      r0,[r4,#0x54]
                  |L38.102|
;;;3840     }
;;;3841   
;;;3842     /* Clear overrun flag in 2 Lines communication mode because received is not read */
;;;3843     if (hspi->Init.Direction == SPI_DIRECTION_2LINES)
000066  68a0              LDR      r0,[r4,#8]
000068  b950              CBNZ     r0,|L38.128|
;;;3844     {
;;;3845       __HAL_SPI_CLEAR_OVRFLAG(hspi);
00006a  bf00              NOP      
00006c  2000              MOVS     r0,#0
00006e  9000              STR      r0,[sp,#0]
000070  6820              LDR      r0,[r4,#0]
000072  68c0              LDR      r0,[r0,#0xc]
000074  9000              STR      r0,[sp,#0]
000076  6820              LDR      r0,[r4,#0]
000078  6880              LDR      r0,[r0,#8]
00007a  9000              STR      r0,[sp,#0]
00007c  bf00              NOP      
00007e  bf00              NOP      
                  |L38.128|
;;;3846     }
;;;3847   
;;;3848     hspi->State = HAL_SPI_STATE_READY;
000080  2001              MOVS     r0,#1
000082  f8840051          STRB     r0,[r4,#0x51]
;;;3849     if (hspi->ErrorCode != HAL_SPI_ERROR_NONE)
000086  6d60              LDR      r0,[r4,#0x54]
000088  b118              CBZ      r0,|L38.146|
;;;3850     {
;;;3851       /* Call user error callback */
;;;3852   #if (USE_HAL_SPI_REGISTER_CALLBACKS == 1U)
;;;3853       hspi->ErrorCallback(hspi);
;;;3854   #else
;;;3855       HAL_SPI_ErrorCallback(hspi);
00008a  4620              MOV      r0,r4
00008c  f7fffffe          BL       HAL_SPI_ErrorCallback
000090  e002              B        |L38.152|
                  |L38.146|
;;;3856   #endif /* USE_HAL_SPI_REGISTER_CALLBACKS */
;;;3857     }
;;;3858     else
;;;3859     {
;;;3860       /* Call user Rx complete callback */
;;;3861   #if (USE_HAL_SPI_REGISTER_CALLBACKS == 1U)
;;;3862       hspi->TxCpltCallback(hspi);
;;;3863   #else
;;;3864       HAL_SPI_TxCpltCallback(hspi);
000092  4620              MOV      r0,r4
000094  f7fffffe          BL       HAL_SPI_TxCpltCallback
                  |L38.152|
;;;3865   #endif /* USE_HAL_SPI_REGISTER_CALLBACKS */
;;;3866     }
;;;3867   }
000098  bd7c              POP      {r2-r6,pc}
;;;3868   
                          ENDP

00009a  0000              DCW      0x0000
                  |L38.156|
                          DCD      SystemCoreClock

                          AREA ||i.SPI_DMAAbortOnError||, CODE, READONLY, ALIGN=1

                  SPI_DMAAbortOnError PROC
;;;3017     */
;;;3018   static void SPI_DMAAbortOnError(DMA_HandleTypeDef *hdma)
000000  b570              PUSH     {r4-r6,lr}
;;;3019   {
000002  4605              MOV      r5,r0
;;;3020     SPI_HandleTypeDef *hspi = (SPI_HandleTypeDef *)(((DMA_HandleTypeDef *)hdma)->Parent); /* Derogation MISRAC2012-Rule-11.5 */
000004  6a6c              LDR      r4,[r5,#0x24]
;;;3021     hspi->RxXferCount = 0U;
000006  2000              MOVS     r0,#0
000008  87e0              STRH     r0,[r4,#0x3e]
;;;3022     hspi->TxXferCount = 0U;
00000a  86e0              STRH     r0,[r4,#0x36]
;;;3023   
;;;3024     /* Call user error callback */
;;;3025   #if (USE_HAL_SPI_REGISTER_CALLBACKS == 1U)
;;;3026     hspi->ErrorCallback(hspi);
;;;3027   #else
;;;3028     HAL_SPI_ErrorCallback(hspi);
00000c  4620              MOV      r0,r4
00000e  f7fffffe          BL       HAL_SPI_ErrorCallback
;;;3029   #endif /* USE_HAL_SPI_REGISTER_CALLBACKS */
;;;3030   }
000012  bd70              POP      {r4-r6,pc}
;;;3031   
                          ENDP


                          AREA ||i.SPI_DMAError||, CODE, READONLY, ALIGN=1

                  SPI_DMAError PROC
;;;2994     */
;;;2995   static void SPI_DMAError(DMA_HandleTypeDef *hdma)
000000  b570              PUSH     {r4-r6,lr}
;;;2996   {
000002  4605              MOV      r5,r0
;;;2997     SPI_HandleTypeDef *hspi = (SPI_HandleTypeDef *)(((DMA_HandleTypeDef *)hdma)->Parent); /* Derogation MISRAC2012-Rule-11.5 */
000004  6a6c              LDR      r4,[r5,#0x24]
;;;2998   
;;;2999     /* Stop the disable DMA transfer on SPI side */
;;;3000     CLEAR_BIT(hspi->Instance->CR2, SPI_CR2_TXDMAEN | SPI_CR2_RXDMAEN);
000006  6820              LDR      r0,[r4,#0]
000008  6840              LDR      r0,[r0,#4]
00000a  f0200003          BIC      r0,r0,#3
00000e  6821              LDR      r1,[r4,#0]
000010  6048              STR      r0,[r1,#4]
;;;3001   
;;;3002     SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_DMA);
000012  6d60              LDR      r0,[r4,#0x54]
000014  f0400010          ORR      r0,r0,#0x10
000018  6560              STR      r0,[r4,#0x54]
;;;3003     hspi->State = HAL_SPI_STATE_READY;
00001a  2001              MOVS     r0,#1
00001c  f8840051          STRB     r0,[r4,#0x51]
;;;3004     /* Call user error callback */
;;;3005   #if (USE_HAL_SPI_REGISTER_CALLBACKS == 1U)
;;;3006     hspi->ErrorCallback(hspi);
;;;3007   #else
;;;3008     HAL_SPI_ErrorCallback(hspi);
000020  4620              MOV      r0,r4
000022  f7fffffe          BL       HAL_SPI_ErrorCallback
;;;3009   #endif /* USE_HAL_SPI_REGISTER_CALLBACKS */
;;;3010   }
000026  bd70              POP      {r4-r6,pc}
;;;3011   
                          ENDP


                          AREA ||i.SPI_DMAHalfReceiveCplt||, CODE, READONLY, ALIGN=1

                  SPI_DMAHalfReceiveCplt PROC
;;;2958     */
;;;2959   static void SPI_DMAHalfReceiveCplt(DMA_HandleTypeDef *hdma)
000000  b570              PUSH     {r4-r6,lr}
;;;2960   {
000002  4604              MOV      r4,r0
;;;2961     SPI_HandleTypeDef *hspi = (SPI_HandleTypeDef *)(((DMA_HandleTypeDef *)hdma)->Parent); /* Derogation MISRAC2012-Rule-11.5 */
000004  6a65              LDR      r5,[r4,#0x24]
;;;2962   
;;;2963     /* Call user Rx half complete callback */
;;;2964   #if (USE_HAL_SPI_REGISTER_CALLBACKS == 1U)
;;;2965     hspi->RxHalfCpltCallback(hspi);
;;;2966   #else
;;;2967     HAL_SPI_RxHalfCpltCallback(hspi);
000006  4628              MOV      r0,r5
000008  f7fffffe          BL       HAL_SPI_RxHalfCpltCallback
;;;2968   #endif /* USE_HAL_SPI_REGISTER_CALLBACKS */
;;;2969   }
00000c  bd70              POP      {r4-r6,pc}
;;;2970   
                          ENDP


                          AREA ||i.SPI_DMAHalfTransmitCplt||, CODE, READONLY, ALIGN=1

                  SPI_DMAHalfTransmitCplt PROC
;;;2940     */
;;;2941   static void SPI_DMAHalfTransmitCplt(DMA_HandleTypeDef *hdma)
000000  b570              PUSH     {r4-r6,lr}
;;;2942   {
000002  4604              MOV      r4,r0
;;;2943     SPI_HandleTypeDef *hspi = (SPI_HandleTypeDef *)(((DMA_HandleTypeDef *)hdma)->Parent); /* Derogation MISRAC2012-Rule-11.5 */
000004  6a65              LDR      r5,[r4,#0x24]
;;;2944   
;;;2945     /* Call user Tx half complete callback */
;;;2946   #if (USE_HAL_SPI_REGISTER_CALLBACKS == 1U)
;;;2947     hspi->TxHalfCpltCallback(hspi);
;;;2948   #else
;;;2949     HAL_SPI_TxHalfCpltCallback(hspi);
000006  4628              MOV      r0,r5
000008  f7fffffe          BL       HAL_SPI_TxHalfCpltCallback
;;;2950   #endif /* USE_HAL_SPI_REGISTER_CALLBACKS */
;;;2951   }
00000c  bd70              POP      {r4-r6,pc}
;;;2952   
                          ENDP


                          AREA ||i.SPI_DMAHalfTransmitReceiveCplt||, CODE, READONLY, ALIGN=1

                  SPI_DMAHalfTransmitReceiveCplt PROC
;;;2976     */
;;;2977   static void SPI_DMAHalfTransmitReceiveCplt(DMA_HandleTypeDef *hdma)
000000  b570              PUSH     {r4-r6,lr}
;;;2978   {
000002  4604              MOV      r4,r0
;;;2979     SPI_HandleTypeDef *hspi = (SPI_HandleTypeDef *)(((DMA_HandleTypeDef *)hdma)->Parent); /* Derogation MISRAC2012-Rule-11.5 */
000004  6a65              LDR      r5,[r4,#0x24]
;;;2980   
;;;2981     /* Call user TxRx half complete callback */
;;;2982   #if (USE_HAL_SPI_REGISTER_CALLBACKS == 1U)
;;;2983     hspi->TxRxHalfCpltCallback(hspi);
;;;2984   #else
;;;2985     HAL_SPI_TxRxHalfCpltCallback(hspi);
000006  4628              MOV      r0,r5
000008  f7fffffe          BL       HAL_SPI_TxRxHalfCpltCallback
;;;2986   #endif /* USE_HAL_SPI_REGISTER_CALLBACKS */
;;;2987   }
00000c  bd70              POP      {r4-r6,pc}
;;;2988   
                          ENDP


                          AREA ||i.SPI_DMAReceiveCplt||, CODE, READONLY, ALIGN=1

                  SPI_DMAReceiveCplt PROC
;;;2761     */
;;;2762   static void SPI_DMAReceiveCplt(DMA_HandleTypeDef *hdma)
000000  b570              PUSH     {r4-r6,lr}
;;;2763   {
000002  4605              MOV      r5,r0
;;;2764     SPI_HandleTypeDef *hspi = (SPI_HandleTypeDef *)(((DMA_HandleTypeDef *)hdma)->Parent); /* Derogation MISRAC2012-Rule-11.5 */
000004  6a6c              LDR      r4,[r5,#0x24]
;;;2765     uint32_t tickstart;
;;;2766   
;;;2767     /* Init tickstart for timeout management*/
;;;2768     tickstart = HAL_GetTick();
000006  f7fffffe          BL       HAL_GetTick
00000a  4606              MOV      r6,r0
;;;2769   
;;;2770     /* DMA Normal Mode */
;;;2771     if ((hdma->Instance->CCR & DMA_CCR_CIRC) != DMA_CCR_CIRC)
00000c  6828              LDR      r0,[r5,#0]
00000e  6800              LDR      r0,[r0,#0]
000010  f0000020          AND      r0,r0,#0x20
000014  2820              CMP      r0,#0x20
000016  d02b              BEQ      |L44.112|
;;;2772     {
;;;2773       /* Disable ERR interrupt */
;;;2774       __HAL_SPI_DISABLE_IT(hspi, SPI_IT_ERR);
000018  6820              LDR      r0,[r4,#0]
00001a  6840              LDR      r0,[r0,#4]
00001c  f0200020          BIC      r0,r0,#0x20
000020  6821              LDR      r1,[r4,#0]
000022  6048              STR      r0,[r1,#4]
;;;2775   
;;;2776   #if (USE_SPI_CRC != 0U)
;;;2777       /* CRC handling */
;;;2778       if (hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
;;;2779       {
;;;2780         /* Wait until RXNE flag */
;;;2781         if (SPI_WaitFlagStateUntilTimeout(hspi, SPI_FLAG_RXNE, SET, SPI_DEFAULT_TIMEOUT, tickstart) != HAL_OK)
;;;2782         {
;;;2783           /* Error on the CRC reception */
;;;2784           SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_CRC);
;;;2785         }
;;;2786         /* Read CRC */
;;;2787         READ_REG(hspi->Instance->DR);
;;;2788       }
;;;2789   #endif /* USE_SPI_CRC */
;;;2790   
;;;2791       /* Check if we are in Master RX 2 line mode */
;;;2792       if ((hspi->Init.Direction == SPI_DIRECTION_2LINES) && (hspi->Init.Mode == SPI_MODE_MASTER))
000024  68a0              LDR      r0,[r4,#8]
000026  b950              CBNZ     r0,|L44.62|
000028  6860              LDR      r0,[r4,#4]
00002a  f5b07f82          CMP      r0,#0x104
00002e  d106              BNE      |L44.62|
;;;2793       {
;;;2794         /* Disable Rx/Tx DMA Request (done by default to handle the case master rx direction 2 lines) */
;;;2795         CLEAR_BIT(hspi->Instance->CR2, SPI_CR2_TXDMAEN | SPI_CR2_RXDMAEN);
000030  6820              LDR      r0,[r4,#0]
000032  6840              LDR      r0,[r0,#4]
000034  f0200003          BIC      r0,r0,#3
000038  6821              LDR      r1,[r4,#0]
00003a  6048              STR      r0,[r1,#4]
00003c  e005              B        |L44.74|
                  |L44.62|
;;;2796       }
;;;2797       else
;;;2798       {
;;;2799         /* Normal case */
;;;2800         CLEAR_BIT(hspi->Instance->CR2, SPI_CR2_RXDMAEN);
00003e  6820              LDR      r0,[r4,#0]
000040  6840              LDR      r0,[r0,#4]
000042  f0200001          BIC      r0,r0,#1
000046  6821              LDR      r1,[r4,#0]
000048  6048              STR      r0,[r1,#4]
                  |L44.74|
;;;2801       }
;;;2802   
;;;2803       /* Check the end of the transaction */
;;;2804       if (SPI_EndRxTransaction(hspi, SPI_DEFAULT_TIMEOUT, tickstart) != HAL_OK)
00004a  4632              MOV      r2,r6
00004c  2164              MOVS     r1,#0x64
00004e  4620              MOV      r0,r4
000050  f7fffffe          BL       SPI_EndRxTransaction
000054  b108              CBZ      r0,|L44.90|
;;;2805       {
;;;2806         hspi->ErrorCode = HAL_SPI_ERROR_FLAG;
000056  2020              MOVS     r0,#0x20
000058  6560              STR      r0,[r4,#0x54]
                  |L44.90|
;;;2807       }
;;;2808   
;;;2809       hspi->RxXferCount = 0U;
00005a  2000              MOVS     r0,#0
00005c  87e0              STRH     r0,[r4,#0x3e]
;;;2810       hspi->State = HAL_SPI_STATE_READY;
00005e  2001              MOVS     r0,#1
000060  f8840051          STRB     r0,[r4,#0x51]
;;;2811   
;;;2812   #if (USE_SPI_CRC != 0U)
;;;2813       /* Check if CRC error occurred */
;;;2814       if (__HAL_SPI_GET_FLAG(hspi, SPI_FLAG_CRCERR) != RESET)
;;;2815       {
;;;2816         /* Check if CRC error is valid or not (workaround to be applied or not) */
;;;2817         if (SPI_ISCRCErrorValid(hspi) == SPI_VALID_CRC_ERROR)
;;;2818         {
;;;2819           SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_CRC);
;;;2820   
;;;2821           /* Reset CRC Calculation */
;;;2822           SPI_RESET_CRC(hspi);
;;;2823         }
;;;2824         else
;;;2825         {
;;;2826           __HAL_SPI_CLEAR_CRCERRFLAG(hspi);
;;;2827         }
;;;2828       }
;;;2829   #endif /* USE_SPI_CRC */
;;;2830   
;;;2831       if (hspi->ErrorCode != HAL_SPI_ERROR_NONE)
000064  6d60              LDR      r0,[r4,#0x54]
000066  b118              CBZ      r0,|L44.112|
;;;2832       {
;;;2833         /* Call user error callback */
;;;2834   #if (USE_HAL_SPI_REGISTER_CALLBACKS == 1U)
;;;2835         hspi->ErrorCallback(hspi);
;;;2836   #else
;;;2837         HAL_SPI_ErrorCallback(hspi);
000068  4620              MOV      r0,r4
00006a  f7fffffe          BL       HAL_SPI_ErrorCallback
                  |L44.110|
;;;2838   #endif /* USE_HAL_SPI_REGISTER_CALLBACKS */
;;;2839         return;
;;;2840       }
;;;2841     }
;;;2842     /* Call user Rx complete callback */
;;;2843   #if (USE_HAL_SPI_REGISTER_CALLBACKS == 1U)
;;;2844     hspi->RxCpltCallback(hspi);
;;;2845   #else
;;;2846     HAL_SPI_RxCpltCallback(hspi);
;;;2847   #endif /* USE_HAL_SPI_REGISTER_CALLBACKS */
;;;2848   }
00006e  bd70              POP      {r4-r6,pc}
                  |L44.112|
000070  4620              MOV      r0,r4                 ;2846
000072  f7fffffe          BL       HAL_SPI_RxCpltCallback
000076  bf00              NOP      
000078  e7f9              B        |L44.110|
;;;2849   
                          ENDP


                          AREA ||i.SPI_DMARxAbortCallback||, CODE, READONLY, ALIGN=1

                  SPI_DMARxAbortCallback PROC
;;;3103     */
;;;3104   static void SPI_DMARxAbortCallback(DMA_HandleTypeDef *hdma)
000000  b5f8              PUSH     {r3-r7,lr}
;;;3105   {
000002  4605              MOV      r5,r0
;;;3106     SPI_HandleTypeDef *hspi = (SPI_HandleTypeDef *)(((DMA_HandleTypeDef *)hdma)->Parent); /* Derogation MISRAC2012-Rule-11.5 */
000004  6a6c              LDR      r4,[r5,#0x24]
;;;3107   
;;;3108     /* Disable SPI Peripheral */
;;;3109     __HAL_SPI_DISABLE(hspi);
000006  6820              LDR      r0,[r4,#0]
000008  6800              LDR      r0,[r0,#0]
00000a  f0200040          BIC      r0,r0,#0x40
00000e  6821              LDR      r1,[r4,#0]
000010  6008              STR      r0,[r1,#0]
;;;3110   
;;;3111     hspi->hdmarx->XferAbortCallback = NULL;
000012  2000              MOVS     r0,#0
000014  6ce1              LDR      r1,[r4,#0x4c]
000016  6348              STR      r0,[r1,#0x34]
;;;3112   
;;;3113     /* Disable Rx DMA Request */
;;;3114     CLEAR_BIT(hspi->Instance->CR2, SPI_CR2_RXDMAEN);
000018  6820              LDR      r0,[r4,#0]
00001a  6840              LDR      r0,[r0,#4]
00001c  f0200001          BIC      r0,r0,#1
000020  6821              LDR      r1,[r4,#0]
000022  6048              STR      r0,[r1,#4]
;;;3115   
;;;3116     /* Check Busy flag */
;;;3117     if (SPI_EndRxTxTransaction(hspi, SPI_DEFAULT_TIMEOUT, HAL_GetTick()) != HAL_OK)
000024  f7fffffe          BL       HAL_GetTick
000028  4606              MOV      r6,r0
00002a  4632              MOV      r2,r6
00002c  2164              MOVS     r1,#0x64
00002e  4620              MOV      r0,r4
000030  f7fffffe          BL       SPI_EndRxTxTransaction
000034  b118              CBZ      r0,|L45.62|
;;;3118     {
;;;3119       SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_ABORT);
000036  6d60              LDR      r0,[r4,#0x54]
000038  f0400040          ORR      r0,r0,#0x40
00003c  6560              STR      r0,[r4,#0x54]
                  |L45.62|
;;;3120     }
;;;3121   
;;;3122     /* Check if an Abort process is still ongoing */
;;;3123     if (hspi->hdmatx != NULL)
00003e  6ca0              LDR      r0,[r4,#0x48]
000040  b118              CBZ      r0,|L45.74|
;;;3124     {
;;;3125       if (hspi->hdmatx->XferAbortCallback != NULL)
000042  6ca0              LDR      r0,[r4,#0x48]
000044  6b40              LDR      r0,[r0,#0x34]
000046  b100              CBZ      r0,|L45.74|
                  |L45.72|
;;;3126       {
;;;3127         return;
;;;3128       }
;;;3129     }
;;;3130   
;;;3131     /* No Abort process still ongoing : All DMA Stream/Channel are aborted, call user Abort Complete callback */
;;;3132     hspi->RxXferCount = 0U;
;;;3133     hspi->TxXferCount = 0U;
;;;3134   
;;;3135     /* Check no error during Abort procedure */
;;;3136     if (hspi->ErrorCode != HAL_SPI_ERROR_ABORT)
;;;3137     {
;;;3138       /* Reset errorCode */
;;;3139       hspi->ErrorCode = HAL_SPI_ERROR_NONE;
;;;3140     }
;;;3141   
;;;3142     /* Clear the Error flags in the SR register */
;;;3143     __HAL_SPI_CLEAR_OVRFLAG(hspi);
;;;3144   
;;;3145     /* Restore hspi->State to Ready */
;;;3146     hspi->State  = HAL_SPI_STATE_READY;
;;;3147   
;;;3148     /* Call user Abort complete callback */
;;;3149   #if (USE_HAL_SPI_REGISTER_CALLBACKS == 1U)
;;;3150     hspi->AbortCpltCallback(hspi);
;;;3151   #else
;;;3152     HAL_SPI_AbortCpltCallback(hspi);
;;;3153   #endif /* USE_HAL_SPI_REGISTER_CALLBACKS */
;;;3154   }
000048  bdf8              POP      {r3-r7,pc}
                  |L45.74|
00004a  2000              MOVS     r0,#0                 ;3132
00004c  87e0              STRH     r0,[r4,#0x3e]         ;3132
00004e  86e0              STRH     r0,[r4,#0x36]         ;3133
000050  6d60              LDR      r0,[r4,#0x54]         ;3136
000052  2840              CMP      r0,#0x40              ;3136
000054  d001              BEQ      |L45.90|
000056  2000              MOVS     r0,#0                 ;3139
000058  6560              STR      r0,[r4,#0x54]         ;3139
                  |L45.90|
00005a  bf00              NOP                            ;3143
00005c  2000              MOVS     r0,#0                 ;3143
00005e  9000              STR      r0,[sp,#0]            ;3143
000060  6820              LDR      r0,[r4,#0]            ;3143
000062  68c0              LDR      r0,[r0,#0xc]          ;3143
000064  9000              STR      r0,[sp,#0]            ;3143
000066  6820              LDR      r0,[r4,#0]            ;3143
000068  6880              LDR      r0,[r0,#8]            ;3143
00006a  9000              STR      r0,[sp,#0]            ;3143
00006c  bf00              NOP                            ;3143
00006e  bf00              NOP                            ;3143
000070  2001              MOVS     r0,#1                 ;3146
000072  f8840051          STRB     r0,[r4,#0x51]         ;3146
000076  4620              MOV      r0,r4                 ;3152
000078  f7fffffe          BL       HAL_SPI_AbortCpltCallback
00007c  bf00              NOP      
00007e  e7e3              B        |L45.72|
;;;3155   
                          ENDP


                          AREA ||i.SPI_DMATransmitCplt||, CODE, READONLY, ALIGN=1

                  SPI_DMATransmitCplt PROC
;;;2704     */
;;;2705   static void SPI_DMATransmitCplt(DMA_HandleTypeDef *hdma)
000000  b5f8              PUSH     {r3-r7,lr}
;;;2706   {
000002  4605              MOV      r5,r0
;;;2707     SPI_HandleTypeDef *hspi = (SPI_HandleTypeDef *)(((DMA_HandleTypeDef *)hdma)->Parent); /* Derogation MISRAC2012-Rule-11.5 */
000004  6a6c              LDR      r4,[r5,#0x24]
;;;2708     uint32_t tickstart;
;;;2709   
;;;2710     /* Init tickstart for timeout management*/
;;;2711     tickstart = HAL_GetTick();
000006  f7fffffe          BL       HAL_GetTick
00000a  4606              MOV      r6,r0
;;;2712   
;;;2713     /* DMA Normal Mode */
;;;2714     if ((hdma->Instance->CCR & DMA_CCR_CIRC) != DMA_CCR_CIRC)
00000c  6828              LDR      r0,[r5,#0]
00000e  6800              LDR      r0,[r0,#0]
000010  f0000020          AND      r0,r0,#0x20
000014  2820              CMP      r0,#0x20
000016  d02d              BEQ      |L46.116|
;;;2715     {
;;;2716       /* Disable ERR interrupt */
;;;2717       __HAL_SPI_DISABLE_IT(hspi, SPI_IT_ERR);
000018  6820              LDR      r0,[r4,#0]
00001a  6840              LDR      r0,[r0,#4]
00001c  f0200020          BIC      r0,r0,#0x20
000020  6821              LDR      r1,[r4,#0]
000022  6048              STR      r0,[r1,#4]
;;;2718   
;;;2719       /* Disable Tx DMA Request */
;;;2720       CLEAR_BIT(hspi->Instance->CR2, SPI_CR2_TXDMAEN);
000024  6820              LDR      r0,[r4,#0]
000026  6840              LDR      r0,[r0,#4]
000028  f0200002          BIC      r0,r0,#2
00002c  6821              LDR      r1,[r4,#0]
00002e  6048              STR      r0,[r1,#4]
;;;2721   
;;;2722       /* Check the end of the transaction */
;;;2723       if (SPI_EndRxTxTransaction(hspi, SPI_DEFAULT_TIMEOUT, tickstart) != HAL_OK)
000030  4632              MOV      r2,r6
000032  2164              MOVS     r1,#0x64
000034  4620              MOV      r0,r4
000036  f7fffffe          BL       SPI_EndRxTxTransaction
00003a  b118              CBZ      r0,|L46.68|
;;;2724       {
;;;2725         SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_FLAG);
00003c  6d60              LDR      r0,[r4,#0x54]
00003e  f0400020          ORR      r0,r0,#0x20
000042  6560              STR      r0,[r4,#0x54]
                  |L46.68|
;;;2726       }
;;;2727   
;;;2728       /* Clear overrun flag in 2 Lines communication mode because received data is not read */
;;;2729       if (hspi->Init.Direction == SPI_DIRECTION_2LINES)
000044  68a0              LDR      r0,[r4,#8]
000046  b950              CBNZ     r0,|L46.94|
;;;2730       {
;;;2731         __HAL_SPI_CLEAR_OVRFLAG(hspi);
000048  bf00              NOP      
00004a  2000              MOVS     r0,#0
00004c  9000              STR      r0,[sp,#0]
00004e  6820              LDR      r0,[r4,#0]
000050  68c0              LDR      r0,[r0,#0xc]
000052  9000              STR      r0,[sp,#0]
000054  6820              LDR      r0,[r4,#0]
000056  6880              LDR      r0,[r0,#8]
000058  9000              STR      r0,[sp,#0]
00005a  bf00              NOP      
00005c  bf00              NOP      
                  |L46.94|
;;;2732       }
;;;2733   
;;;2734       hspi->TxXferCount = 0U;
00005e  2000              MOVS     r0,#0
000060  86e0              STRH     r0,[r4,#0x36]
;;;2735       hspi->State = HAL_SPI_STATE_READY;
000062  2001              MOVS     r0,#1
000064  f8840051          STRB     r0,[r4,#0x51]
;;;2736   
;;;2737       if (hspi->ErrorCode != HAL_SPI_ERROR_NONE)
000068  6d60              LDR      r0,[r4,#0x54]
00006a  b118              CBZ      r0,|L46.116|
;;;2738       {
;;;2739         /* Call user error callback */
;;;2740   #if (USE_HAL_SPI_REGISTER_CALLBACKS == 1U)
;;;2741         hspi->ErrorCallback(hspi);
;;;2742   #else
;;;2743         HAL_SPI_ErrorCallback(hspi);
00006c  4620              MOV      r0,r4
00006e  f7fffffe          BL       HAL_SPI_ErrorCallback
                  |L46.114|
;;;2744   #endif /* USE_HAL_SPI_REGISTER_CALLBACKS */
;;;2745         return;
;;;2746       }
;;;2747     }
;;;2748     /* Call user Tx complete callback */
;;;2749   #if (USE_HAL_SPI_REGISTER_CALLBACKS == 1U)
;;;2750     hspi->TxCpltCallback(hspi);
;;;2751   #else
;;;2752     HAL_SPI_TxCpltCallback(hspi);
;;;2753   #endif /* USE_HAL_SPI_REGISTER_CALLBACKS */
;;;2754   }
000072  bdf8              POP      {r3-r7,pc}
                  |L46.116|
000074  4620              MOV      r0,r4                 ;2752
000076  f7fffffe          BL       HAL_SPI_TxCpltCallback
00007a  bf00              NOP      
00007c  e7f9              B        |L46.114|
;;;2755   
                          ENDP


                          AREA ||i.SPI_DMATransmitReceiveCplt||, CODE, READONLY, ALIGN=1

                  SPI_DMATransmitReceiveCplt PROC
;;;2855     */
;;;2856   static void SPI_DMATransmitReceiveCplt(DMA_HandleTypeDef *hdma)
000000  b570              PUSH     {r4-r6,lr}
;;;2857   {
000002  4605              MOV      r5,r0
;;;2858     SPI_HandleTypeDef *hspi = (SPI_HandleTypeDef *)(((DMA_HandleTypeDef *)hdma)->Parent); /* Derogation MISRAC2012-Rule-11.5 */
000004  6a6c              LDR      r4,[r5,#0x24]
;;;2859     uint32_t tickstart;
;;;2860   
;;;2861     /* Init tickstart for timeout management*/
;;;2862     tickstart = HAL_GetTick();
000006  f7fffffe          BL       HAL_GetTick
00000a  4606              MOV      r6,r0
;;;2863   
;;;2864     /* DMA Normal Mode */
;;;2865     if ((hdma->Instance->CCR & DMA_CCR_CIRC) != DMA_CCR_CIRC)
00000c  6828              LDR      r0,[r5,#0]
00000e  6800              LDR      r0,[r0,#0]
000010  f0000020          AND      r0,r0,#0x20
000014  2820              CMP      r0,#0x20
000016  d021              BEQ      |L47.92|
;;;2866     {
;;;2867       /* Disable ERR interrupt */
;;;2868       __HAL_SPI_DISABLE_IT(hspi, SPI_IT_ERR);
000018  6820              LDR      r0,[r4,#0]
00001a  6840              LDR      r0,[r0,#4]
00001c  f0200020          BIC      r0,r0,#0x20
000020  6821              LDR      r1,[r4,#0]
000022  6048              STR      r0,[r1,#4]
;;;2869   
;;;2870   #if (USE_SPI_CRC != 0U)
;;;2871       /* CRC handling */
;;;2872       if (hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
;;;2873       {
;;;2874         /* Wait the CRC data */
;;;2875         if (SPI_WaitFlagStateUntilTimeout(hspi, SPI_FLAG_RXNE, SET, SPI_DEFAULT_TIMEOUT, tickstart) != HAL_OK)
;;;2876         {
;;;2877           SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_CRC);
;;;2878         }
;;;2879         /* Read CRC to Flush DR and RXNE flag */
;;;2880         READ_REG(hspi->Instance->DR);
;;;2881       }
;;;2882   #endif /* USE_SPI_CRC */
;;;2883   
;;;2884       /* Check the end of the transaction */
;;;2885       if (SPI_EndRxTxTransaction(hspi, SPI_DEFAULT_TIMEOUT, tickstart) != HAL_OK)
000024  4632              MOV      r2,r6
000026  2164              MOVS     r1,#0x64
000028  4620              MOV      r0,r4
00002a  f7fffffe          BL       SPI_EndRxTxTransaction
00002e  b118              CBZ      r0,|L47.56|
;;;2886       {
;;;2887         SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_FLAG);
000030  6d60              LDR      r0,[r4,#0x54]
000032  f0400020          ORR      r0,r0,#0x20
000036  6560              STR      r0,[r4,#0x54]
                  |L47.56|
;;;2888       }
;;;2889   
;;;2890       /* Disable Rx/Tx DMA Request */
;;;2891       CLEAR_BIT(hspi->Instance->CR2, SPI_CR2_TXDMAEN | SPI_CR2_RXDMAEN);
000038  6820              LDR      r0,[r4,#0]
00003a  6840              LDR      r0,[r0,#4]
00003c  f0200003          BIC      r0,r0,#3
000040  6821              LDR      r1,[r4,#0]
000042  6048              STR      r0,[r1,#4]
;;;2892   
;;;2893       hspi->TxXferCount = 0U;
000044  2000              MOVS     r0,#0
000046  86e0              STRH     r0,[r4,#0x36]
;;;2894       hspi->RxXferCount = 0U;
000048  87e0              STRH     r0,[r4,#0x3e]
;;;2895       hspi->State = HAL_SPI_STATE_READY;
00004a  2001              MOVS     r0,#1
00004c  f8840051          STRB     r0,[r4,#0x51]
;;;2896   
;;;2897   #if (USE_SPI_CRC != 0U)
;;;2898       /* Check if CRC error occurred */
;;;2899       if (__HAL_SPI_GET_FLAG(hspi, SPI_FLAG_CRCERR) != RESET)
;;;2900       {
;;;2901         /* Check if CRC error is valid or not (workaround to be applied or not) */
;;;2902         if (SPI_ISCRCErrorValid(hspi) == SPI_VALID_CRC_ERROR)
;;;2903         {
;;;2904           SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_CRC);
;;;2905   
;;;2906           /* Reset CRC Calculation */
;;;2907           SPI_RESET_CRC(hspi);
;;;2908         }
;;;2909         else
;;;2910         {
;;;2911           __HAL_SPI_CLEAR_CRCERRFLAG(hspi);
;;;2912         }
;;;2913       }
;;;2914   #endif /* USE_SPI_CRC */
;;;2915   
;;;2916       if (hspi->ErrorCode != HAL_SPI_ERROR_NONE)
000050  6d60              LDR      r0,[r4,#0x54]
000052  b118              CBZ      r0,|L47.92|
;;;2917       {
;;;2918         /* Call user error callback */
;;;2919   #if (USE_HAL_SPI_REGISTER_CALLBACKS == 1U)
;;;2920         hspi->ErrorCallback(hspi);
;;;2921   #else
;;;2922         HAL_SPI_ErrorCallback(hspi);
000054  4620              MOV      r0,r4
000056  f7fffffe          BL       HAL_SPI_ErrorCallback
                  |L47.90|
;;;2923   #endif /* USE_HAL_SPI_REGISTER_CALLBACKS */
;;;2924         return;
;;;2925       }
;;;2926     }
;;;2927     /* Call user TxRx complete callback */
;;;2928   #if (USE_HAL_SPI_REGISTER_CALLBACKS == 1U)
;;;2929     hspi->TxRxCpltCallback(hspi);
;;;2930   #else
;;;2931     HAL_SPI_TxRxCpltCallback(hspi);
;;;2932   #endif /* USE_HAL_SPI_REGISTER_CALLBACKS */
;;;2933   }
00005a  bd70              POP      {r4-r6,pc}
                  |L47.92|
00005c  4620              MOV      r0,r4                 ;2931
00005e  f7fffffe          BL       HAL_SPI_TxRxCpltCallback
000062  bf00              NOP      
000064  e7f9              B        |L47.90|
;;;2934   
                          ENDP


                          AREA ||i.SPI_DMATxAbortCallback||, CODE, READONLY, ALIGN=2

                  SPI_DMATxAbortCallback PROC
;;;3039     */
;;;3040   static void SPI_DMATxAbortCallback(DMA_HandleTypeDef *hdma)
000000  b57c              PUSH     {r2-r6,lr}
;;;3041   {
000002  4605              MOV      r5,r0
;;;3042     SPI_HandleTypeDef *hspi = (SPI_HandleTypeDef *)(((DMA_HandleTypeDef *)hdma)->Parent); /* Derogation MISRAC2012-Rule-11.5 */
000004  6a6c              LDR      r4,[r5,#0x24]
;;;3043     __IO uint32_t count;
;;;3044   
;;;3045     hspi->hdmatx->XferAbortCallback = NULL;
000006  2000              MOVS     r0,#0
000008  6ca1              LDR      r1,[r4,#0x48]
00000a  6348              STR      r0,[r1,#0x34]
;;;3046     count = SPI_DEFAULT_TIMEOUT * (SystemCoreClock / 24U / 1000U);
00000c  4822              LDR      r0,|L48.152|
00000e  6800              LDR      r0,[r0,#0]  ; SystemCoreClock
000010  2118              MOVS     r1,#0x18
000012  fbb0f0f1          UDIV     r0,r0,r1
000016  f44f717a          MOV      r1,#0x3e8
00001a  fbb0f0f1          UDIV     r0,r0,r1
00001e  2164              MOVS     r1,#0x64
000020  4348              MULS     r0,r1,r0
000022  9001              STR      r0,[sp,#4]
;;;3047   
;;;3048     /* Disable Tx DMA Request */
;;;3049     CLEAR_BIT(hspi->Instance->CR2, SPI_CR2_TXDMAEN);
000024  6820              LDR      r0,[r4,#0]
000026  6840              LDR      r0,[r0,#4]
000028  f0200002          BIC      r0,r0,#2
00002c  6821              LDR      r1,[r4,#0]
00002e  6048              STR      r0,[r1,#4]
;;;3050   
;;;3051     /* Wait until TXE flag is set */
;;;3052     do
000030  bf00              NOP      
                  |L48.50|
;;;3053     {
;;;3054       if (count == 0U)
000032  9801              LDR      r0,[sp,#4]
000034  b920              CBNZ     r0,|L48.64|
;;;3055       {
;;;3056         SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_ABORT);
000036  6d60              LDR      r0,[r4,#0x54]
000038  f0400040          ORR      r0,r0,#0x40
00003c  6560              STR      r0,[r4,#0x54]
;;;3057         break;
00003e  e008              B        |L48.82|
                  |L48.64|
;;;3058       }
;;;3059       count--;
000040  9801              LDR      r0,[sp,#4]
000042  1e40              SUBS     r0,r0,#1
000044  9001              STR      r0,[sp,#4]
;;;3060     } while ((hspi->Instance->SR & SPI_FLAG_TXE) == RESET);
000046  6820              LDR      r0,[r4,#0]
000048  6880              LDR      r0,[r0,#8]
00004a  f0000002          AND      r0,r0,#2
00004e  2800              CMP      r0,#0
000050  d0ef              BEQ      |L48.50|
                  |L48.82|
000052  bf00              NOP                            ;3057
;;;3061   
;;;3062     /* Check if an Abort process is still ongoing */
;;;3063     if (hspi->hdmarx != NULL)
000054  6ce0              LDR      r0,[r4,#0x4c]
000056  b118              CBZ      r0,|L48.96|
;;;3064     {
;;;3065       if (hspi->hdmarx->XferAbortCallback != NULL)
000058  6ce0              LDR      r0,[r4,#0x4c]
00005a  6b40              LDR      r0,[r0,#0x34]
00005c  b100              CBZ      r0,|L48.96|
                  |L48.94|
;;;3066       {
;;;3067         return;
;;;3068       }
;;;3069     }
;;;3070   
;;;3071     /* No Abort process still ongoing : All DMA Stream/Channel are aborted, call user Abort Complete callback */
;;;3072     hspi->RxXferCount = 0U;
;;;3073     hspi->TxXferCount = 0U;
;;;3074   
;;;3075     /* Check no error during Abort procedure */
;;;3076     if (hspi->ErrorCode != HAL_SPI_ERROR_ABORT)
;;;3077     {
;;;3078       /* Reset errorCode */
;;;3079       hspi->ErrorCode = HAL_SPI_ERROR_NONE;
;;;3080     }
;;;3081   
;;;3082     /* Clear the Error flags in the SR register */
;;;3083     __HAL_SPI_CLEAR_OVRFLAG(hspi);
;;;3084   
;;;3085     /* Restore hspi->State to Ready */
;;;3086     hspi->State  = HAL_SPI_STATE_READY;
;;;3087   
;;;3088     /* Call user Abort complete callback */
;;;3089   #if (USE_HAL_SPI_REGISTER_CALLBACKS == 1U)
;;;3090     hspi->AbortCpltCallback(hspi);
;;;3091   #else
;;;3092     HAL_SPI_AbortCpltCallback(hspi);
;;;3093   #endif /* USE_HAL_SPI_REGISTER_CALLBACKS */
;;;3094   }
00005e  bd7c              POP      {r2-r6,pc}
                  |L48.96|
000060  2000              MOVS     r0,#0                 ;3072
000062  87e0              STRH     r0,[r4,#0x3e]         ;3072
000064  86e0              STRH     r0,[r4,#0x36]         ;3073
000066  6d60              LDR      r0,[r4,#0x54]         ;3076
000068  2840              CMP      r0,#0x40              ;3076
00006a  d001              BEQ      |L48.112|
00006c  2000              MOVS     r0,#0                 ;3079
00006e  6560              STR      r0,[r4,#0x54]         ;3079
                  |L48.112|
000070  bf00              NOP                            ;3083
000072  2000              MOVS     r0,#0                 ;3083
000074  9000              STR      r0,[sp,#0]            ;3083
000076  6820              LDR      r0,[r4,#0]            ;3083
000078  68c0              LDR      r0,[r0,#0xc]          ;3083
00007a  9000              STR      r0,[sp,#0]            ;3083
00007c  6820              LDR      r0,[r4,#0]            ;3083
00007e  6880              LDR      r0,[r0,#8]            ;3083
000080  9000              STR      r0,[sp,#0]            ;3083
000082  bf00              NOP                            ;3083
000084  bf00              NOP                            ;3083
000086  2001              MOVS     r0,#1                 ;3086
000088  f8840051          STRB     r0,[r4,#0x51]         ;3086
00008c  4620              MOV      r0,r4                 ;3092
00008e  f7fffffe          BL       HAL_SPI_AbortCpltCallback
000092  bf00              NOP      
000094  e7e3              B        |L48.94|
;;;3095   
                          ENDP

000096  0000              DCW      0x0000
                  |L48.152|
                          DCD      SystemCoreClock

                          AREA ||i.SPI_EndRxTransaction||, CODE, READONLY, ALIGN=1

                  SPI_EndRxTransaction PROC
;;;3579     */
;;;3580   static HAL_StatusTypeDef SPI_EndRxTransaction(SPI_HandleTypeDef *hspi,  uint32_t Timeout, uint32_t Tickstart)
000000  b5f8              PUSH     {r3-r7,lr}
;;;3581   {
000002  4604              MOV      r4,r0
000004  460e              MOV      r6,r1
000006  4615              MOV      r5,r2
;;;3582     if ((hspi->Init.Mode == SPI_MODE_MASTER) && ((hspi->Init.Direction == SPI_DIRECTION_1LINE)
000008  6860              LDR      r0,[r4,#4]
00000a  f5b07f82          CMP      r0,#0x104
00000e  d10d              BNE      |L49.44|
000010  68a0              LDR      r0,[r4,#8]
000012  f5b04f00          CMP      r0,#0x8000
000016  d003              BEQ      |L49.32|
;;;3583                                                  || (hspi->Init.Direction == SPI_DIRECTION_2LINES_RXONLY)))
000018  68a0              LDR      r0,[r4,#8]
00001a  f5b06f80          CMP      r0,#0x400
00001e  d105              BNE      |L49.44|
                  |L49.32|
;;;3584     {
;;;3585       /* Disable SPI peripheral */
;;;3586       __HAL_SPI_DISABLE(hspi);
000020  6820              LDR      r0,[r4,#0]
000022  6800              LDR      r0,[r0,#0]
000024  f0200040          BIC      r0,r0,#0x40
000028  6821              LDR      r1,[r4,#0]
00002a  6008              STR      r0,[r1,#0]
                  |L49.44|
;;;3587     }
;;;3588   
;;;3589     if ((hspi->Init.Mode == SPI_MODE_MASTER) && (hspi->Init.Direction == SPI_DIRECTION_2LINES_RXONLY))
00002c  6860              LDR      r0,[r4,#4]
00002e  f5b07f82          CMP      r0,#0x104
000032  d111              BNE      |L49.88|
000034  68a0              LDR      r0,[r4,#8]
000036  f5b06f80          CMP      r0,#0x400
00003a  d10d              BNE      |L49.88|
;;;3590     {
;;;3591       /* Wait the RXNE reset */
;;;3592       if (SPI_WaitFlagStateUntilTimeout(hspi, SPI_FLAG_RXNE, RESET, Timeout, Tickstart) != HAL_OK)
00003c  4633              MOV      r3,r6
00003e  2200              MOVS     r2,#0
000040  2101              MOVS     r1,#1
000042  4620              MOV      r0,r4
000044  9500              STR      r5,[sp,#0]
000046  f7fffffe          BL       SPI_WaitFlagStateUntilTimeout
00004a  b198              CBZ      r0,|L49.116|
;;;3593       {
;;;3594         SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_FLAG);
00004c  6d60              LDR      r0,[r4,#0x54]
00004e  f0400020          ORR      r0,r0,#0x20
000052  6560              STR      r0,[r4,#0x54]
;;;3595         return HAL_TIMEOUT;
000054  2003              MOVS     r0,#3
                  |L49.86|
;;;3596       }
;;;3597     }
;;;3598     else
;;;3599     {
;;;3600       /* Control the BSY flag */
;;;3601       if (SPI_WaitFlagStateUntilTimeout(hspi, SPI_FLAG_BSY, RESET, Timeout, Tickstart) != HAL_OK)
;;;3602       {
;;;3603         SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_FLAG);
;;;3604         return HAL_TIMEOUT;
;;;3605       }
;;;3606     }
;;;3607     return HAL_OK;
;;;3608   }
000056  bdf8              POP      {r3-r7,pc}
                  |L49.88|
000058  4633              MOV      r3,r6                 ;3601
00005a  2200              MOVS     r2,#0                 ;3601
00005c  2180              MOVS     r1,#0x80              ;3601
00005e  4620              MOV      r0,r4                 ;3601
000060  9500              STR      r5,[sp,#0]            ;3601
000062  f7fffffe          BL       SPI_WaitFlagStateUntilTimeout
000066  b128              CBZ      r0,|L49.116|
000068  6d60              LDR      r0,[r4,#0x54]         ;3603
00006a  f0400020          ORR      r0,r0,#0x20           ;3603
00006e  6560              STR      r0,[r4,#0x54]         ;3603
000070  2003              MOVS     r0,#3                 ;3604
000072  e7f0              B        |L49.86|
                  |L49.116|
000074  2000              MOVS     r0,#0                 ;3607
000076  e7ee              B        |L49.86|
;;;3609   
                          ENDP


                          AREA ||i.SPI_EndRxTxTransaction||, CODE, READONLY, ALIGN=1

                  SPI_EndRxTxTransaction PROC
;;;3616     */
;;;3617   static HAL_StatusTypeDef SPI_EndRxTxTransaction(SPI_HandleTypeDef *hspi, uint32_t Timeout, uint32_t Tickstart)
000000  b5f8              PUSH     {r3-r7,lr}
;;;3618   {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
000006  4616              MOV      r6,r2
;;;3619     /* Control the BSY flag */
;;;3620     if (SPI_WaitFlagStateUntilTimeout(hspi, SPI_FLAG_BSY, RESET, Timeout, Tickstart) != HAL_OK)
000008  462b              MOV      r3,r5
00000a  2200              MOVS     r2,#0
00000c  2180              MOVS     r1,#0x80
00000e  4620              MOV      r0,r4
000010  9600              STR      r6,[sp,#0]
000012  f7fffffe          BL       SPI_WaitFlagStateUntilTimeout
000016  b128              CBZ      r0,|L50.36|
;;;3621     {
;;;3622       SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_FLAG);
000018  6d60              LDR      r0,[r4,#0x54]
00001a  f0400020          ORR      r0,r0,#0x20
00001e  6560              STR      r0,[r4,#0x54]
;;;3623       return HAL_TIMEOUT;
000020  2003              MOVS     r0,#3
                  |L50.34|
;;;3624     }
;;;3625     return HAL_OK;
;;;3626   }
000022  bdf8              POP      {r3-r7,pc}
                  |L50.36|
000024  2000              MOVS     r0,#0                 ;3625
000026  e7fc              B        |L50.34|
;;;3627   
                          ENDP


                          AREA ||i.SPI_RxISR_16BIT||, CODE, READONLY, ALIGN=1

                  SPI_RxISR_16BIT PROC
;;;3417     */
;;;3418   static void SPI_RxISR_16BIT(struct __SPI_HandleTypeDef *hspi)
000000  b510              PUSH     {r4,lr}
;;;3419   {
000002  4604              MOV      r4,r0
;;;3420     *((uint16_t *)hspi->pRxBuffPtr) = (uint16_t)(hspi->Instance->DR);
000004  6820              LDR      r0,[r4,#0]
000006  68c0              LDR      r0,[r0,#0xc]
000008  6ba1              LDR      r1,[r4,#0x38]
00000a  8008              STRH     r0,[r1,#0]
;;;3421     hspi->pRxBuffPtr += sizeof(uint16_t);
00000c  6ba0              LDR      r0,[r4,#0x38]
00000e  1c80              ADDS     r0,r0,#2
000010  63a0              STR      r0,[r4,#0x38]
;;;3422     hspi->RxXferCount--;
000012  8fe0              LDRH     r0,[r4,#0x3e]
000014  1e40              SUBS     r0,r0,#1
000016  87e0              STRH     r0,[r4,#0x3e]
;;;3423   
;;;3424   #if (USE_SPI_CRC != 0U)
;;;3425     /* Enable CRC Transmission */
;;;3426     if ((hspi->RxXferCount == 1U) && (hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE))
;;;3427     {
;;;3428       SET_BIT(hspi->Instance->CR1, SPI_CR1_CRCNEXT);
;;;3429     }
;;;3430     /* Check if CRCNEXT is well reseted by hardware */
;;;3431     if (READ_BIT(hspi->Instance->CR1, SPI_CR1_CRCNEXT))
;;;3432     {
;;;3433       /* Workaround to force CRCNEXT bit to zero in case of CRCNEXT is not reset automatically by hardware */
;;;3434       CLEAR_BIT(hspi->Instance->CR1, SPI_CR1_CRCNEXT);
;;;3435     }
;;;3436   
;;;3437   #endif /* USE_SPI_CRC */
;;;3438   
;;;3439     if (hspi->RxXferCount == 0U)
000018  8fe0              LDRH     r0,[r4,#0x3e]
00001a  b910              CBNZ     r0,|L51.34|
;;;3440     {
;;;3441   #if (USE_SPI_CRC != 0U)
;;;3442       if (hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
;;;3443       {
;;;3444         hspi->RxISR = SPI_RxISR_16BITCRC;
;;;3445         return;
;;;3446       }
;;;3447   #endif /* USE_SPI_CRC */
;;;3448       SPI_CloseRx_ISR(hspi);
00001c  4620              MOV      r0,r4
00001e  f7fffffe          BL       SPI_CloseRx_ISR
                  |L51.34|
;;;3449     }
;;;3450   }
000022  bd10              POP      {r4,pc}
;;;3451   
                          ENDP


                          AREA ||i.SPI_RxISR_8BIT||, CODE, READONLY, ALIGN=1

                  SPI_RxISR_8BIT PROC
;;;3358     */
;;;3359   static void SPI_RxISR_8BIT(struct __SPI_HandleTypeDef *hspi)
000000  b510              PUSH     {r4,lr}
;;;3360   {
000002  4604              MOV      r4,r0
;;;3361     *hspi->pRxBuffPtr = (*(__IO uint8_t *)&hspi->Instance->DR);
000004  6820              LDR      r0,[r4,#0]
000006  7b00              LDRB     r0,[r0,#0xc]
000008  6ba1              LDR      r1,[r4,#0x38]
00000a  7008              STRB     r0,[r1,#0]
;;;3362     hspi->pRxBuffPtr++;
00000c  6ba0              LDR      r0,[r4,#0x38]
00000e  1c40              ADDS     r0,r0,#1
000010  63a0              STR      r0,[r4,#0x38]
;;;3363     hspi->RxXferCount--;
000012  8fe0              LDRH     r0,[r4,#0x3e]
000014  1e40              SUBS     r0,r0,#1
000016  87e0              STRH     r0,[r4,#0x3e]
;;;3364   
;;;3365   #if (USE_SPI_CRC != 0U)
;;;3366     /* Enable CRC Transmission */
;;;3367     if ((hspi->RxXferCount == 1U) && (hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE))
;;;3368     {
;;;3369       SET_BIT(hspi->Instance->CR1, SPI_CR1_CRCNEXT);
;;;3370     }
;;;3371     /* Check if CRCNEXT is well reseted by hardware */
;;;3372     if (READ_BIT(hspi->Instance->CR1, SPI_CR1_CRCNEXT))
;;;3373     {
;;;3374       /* Workaround to force CRCNEXT bit to zero in case of CRCNEXT is not reset automatically by hardware */
;;;3375       CLEAR_BIT(hspi->Instance->CR1, SPI_CR1_CRCNEXT);
;;;3376     }
;;;3377   
;;;3378   #endif /* USE_SPI_CRC */
;;;3379   
;;;3380     if (hspi->RxXferCount == 0U)
000018  8fe0              LDRH     r0,[r4,#0x3e]
00001a  b910              CBNZ     r0,|L52.34|
;;;3381     {
;;;3382   #if (USE_SPI_CRC != 0U)
;;;3383       if (hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
;;;3384       {
;;;3385         hspi->RxISR =  SPI_RxISR_8BITCRC;
;;;3386         return;
;;;3387       }
;;;3388   #endif /* USE_SPI_CRC */
;;;3389       SPI_CloseRx_ISR(hspi);
00001c  4620              MOV      r0,r4
00001e  f7fffffe          BL       SPI_CloseRx_ISR
                  |L52.34|
;;;3390     }
;;;3391   }
000022  bd10              POP      {r4,pc}
;;;3392   
                          ENDP


                          AREA ||i.SPI_TxISR_16BIT||, CODE, READONLY, ALIGN=1

                  SPI_TxISR_16BIT PROC
;;;3482     */
;;;3483   static void SPI_TxISR_16BIT(struct __SPI_HandleTypeDef *hspi)
000000  b510              PUSH     {r4,lr}
;;;3484   {
000002  4604              MOV      r4,r0
;;;3485     /* Transmit data in 16 Bit mode */
;;;3486     hspi->Instance->DR = *((uint16_t *)hspi->pTxBuffPtr);
000004  6b20              LDR      r0,[r4,#0x30]
000006  8800              LDRH     r0,[r0,#0]
000008  6821              LDR      r1,[r4,#0]
00000a  60c8              STR      r0,[r1,#0xc]
;;;3487     hspi->pTxBuffPtr += sizeof(uint16_t);
00000c  6b20              LDR      r0,[r4,#0x30]
00000e  1c80              ADDS     r0,r0,#2
000010  6320              STR      r0,[r4,#0x30]
;;;3488     hspi->TxXferCount--;
000012  8ee0              LDRH     r0,[r4,#0x36]
000014  1e40              SUBS     r0,r0,#1
000016  86e0              STRH     r0,[r4,#0x36]
;;;3489   
;;;3490     if (hspi->TxXferCount == 0U)
000018  8ee0              LDRH     r0,[r4,#0x36]
00001a  b910              CBNZ     r0,|L53.34|
;;;3491     {
;;;3492   #if (USE_SPI_CRC != 0U)
;;;3493       if (hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
;;;3494       {
;;;3495         /* Enable CRC Transmission */
;;;3496         SET_BIT(hspi->Instance->CR1, SPI_CR1_CRCNEXT);
;;;3497       }
;;;3498   #endif /* USE_SPI_CRC */
;;;3499       SPI_CloseTx_ISR(hspi);
00001c  4620              MOV      r0,r4
00001e  f7fffffe          BL       SPI_CloseTx_ISR
                  |L53.34|
;;;3500     }
;;;3501   }
000022  bd10              POP      {r4,pc}
;;;3502   
                          ENDP


                          AREA ||i.SPI_TxISR_8BIT||, CODE, READONLY, ALIGN=1

                  SPI_TxISR_8BIT PROC
;;;3457     */
;;;3458   static void SPI_TxISR_8BIT(struct __SPI_HandleTypeDef *hspi)
000000  b510              PUSH     {r4,lr}
;;;3459   {
000002  4604              MOV      r4,r0
;;;3460     *(__IO uint8_t *)&hspi->Instance->DR = (*hspi->pTxBuffPtr);
000004  6b20              LDR      r0,[r4,#0x30]
000006  7800              LDRB     r0,[r0,#0]
000008  6821              LDR      r1,[r4,#0]
00000a  7308              STRB     r0,[r1,#0xc]
;;;3461     hspi->pTxBuffPtr++;
00000c  6b20              LDR      r0,[r4,#0x30]
00000e  1c40              ADDS     r0,r0,#1
000010  6320              STR      r0,[r4,#0x30]
;;;3462     hspi->TxXferCount--;
000012  8ee0              LDRH     r0,[r4,#0x36]
000014  1e40              SUBS     r0,r0,#1
000016  86e0              STRH     r0,[r4,#0x36]
;;;3463   
;;;3464     if (hspi->TxXferCount == 0U)
000018  8ee0              LDRH     r0,[r4,#0x36]
00001a  b910              CBNZ     r0,|L54.34|
;;;3465     {
;;;3466   #if (USE_SPI_CRC != 0U)
;;;3467       if (hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
;;;3468       {
;;;3469         /* Enable CRC Transmission */
;;;3470         SET_BIT(hspi->Instance->CR1, SPI_CR1_CRCNEXT);
;;;3471       }
;;;3472   #endif /* USE_SPI_CRC */
;;;3473       SPI_CloseTx_ISR(hspi);
00001c  4620              MOV      r0,r4
00001e  f7fffffe          BL       SPI_CloseTx_ISR
                  |L54.34|
;;;3474     }
;;;3475   }
000022  bd10              POP      {r4,pc}
;;;3476   
                          ENDP


                          AREA ||i.SPI_WaitFlagStateUntilTimeout||, CODE, READONLY, ALIGN=2

                  SPI_WaitFlagStateUntilTimeout PROC
;;;3512     */
;;;3513   static HAL_StatusTypeDef SPI_WaitFlagStateUntilTimeout(SPI_HandleTypeDef *hspi, uint32_t Flag, FlagStatus State,
000000  e92d4ff8          PUSH     {r3-r11,lr}
;;;3514                                                          uint32_t Timeout, uint32_t Tickstart)
;;;3515   {
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
000008  4690              MOV      r8,r2
00000a  461e              MOV      r6,r3
00000c  f8dd9028          LDR      r9,[sp,#0x28]
;;;3516     __IO uint32_t count;
;;;3517     uint32_t tmp_timeout;
;;;3518     uint32_t tmp_tickstart;
;;;3519   
;;;3520     /* Adjust Timeout value  in case of end of transfer */
;;;3521     tmp_timeout   = Timeout - (HAL_GetTick() - Tickstart);
000010  f7fffffe          BL       HAL_GetTick
000014  eba00009          SUB      r0,r0,r9
000018  1a37              SUBS     r7,r6,r0
;;;3522     tmp_tickstart = HAL_GetTick();
00001a  f7fffffe          BL       HAL_GetTick
00001e  4682              MOV      r10,r0
;;;3523   
;;;3524     /* Calculate Timeout based on a software loop to avoid blocking issue if Systick is disabled */
;;;3525     count = tmp_timeout * ((SystemCoreClock * 32U) >> 20U);
000020  482c              LDR      r0,|L55.212|
000022  6800              LDR      r0,[r0,#0]  ; SystemCoreClock
000024  f3c030cb          UBFX     r0,r0,#15,#12
000028  4378              MULS     r0,r7,r0
00002a  9000              STR      r0,[sp,#0]
;;;3526   
;;;3527     while ((__HAL_SPI_GET_FLAG(hspi, Flag) ? SET : RESET) != State)
00002c  e045              B        |L55.186|
                  |L55.46|
;;;3528     {
;;;3529       if (Timeout != HAL_MAX_DELAY)
00002e  1c70              ADDS     r0,r6,#1
000030  2800              CMP      r0,#0
000032  d042              BEQ      |L55.186|
;;;3530       {
;;;3531         if (((HAL_GetTick() - tmp_tickstart) >= tmp_timeout) || (tmp_timeout == 0U))
000034  f7fffffe          BL       HAL_GetTick
000038  eba0000a          SUB      r0,r0,r10
00003c  42b8              CMP      r0,r7
00003e  d200              BCS      |L55.66|
000040  bba7              CBNZ     r7,|L55.172|
                  |L55.66|
;;;3532         {
;;;3533           /* Disable the SPI and reset the CRC: the CRC value should be cleared
;;;3534              on both master and slave sides in order to resynchronize the master
;;;3535              and slave for their respective CRC calculation */
;;;3536   
;;;3537           /* Disable TXE, RXNE and ERR interrupts for the interrupt process */
;;;3538           __HAL_SPI_DISABLE_IT(hspi, (SPI_IT_TXE | SPI_IT_RXNE | SPI_IT_ERR));
000042  6820              LDR      r0,[r4,#0]
000044  6840              LDR      r0,[r0,#4]
000046  f02000e0          BIC      r0,r0,#0xe0
00004a  6821              LDR      r1,[r4,#0]
00004c  6048              STR      r0,[r1,#4]
;;;3539   
;;;3540           if ((hspi->Init.Mode == SPI_MODE_MASTER) && ((hspi->Init.Direction == SPI_DIRECTION_1LINE)
00004e  6860              LDR      r0,[r4,#4]
000050  f5b07f82          CMP      r0,#0x104
000054  d10d              BNE      |L55.114|
000056  68a0              LDR      r0,[r4,#8]
000058  f5b04f00          CMP      r0,#0x8000
00005c  d003              BEQ      |L55.102|
;;;3541                                                        || (hspi->Init.Direction == SPI_DIRECTION_2LINES_RXONLY)))
00005e  68a0              LDR      r0,[r4,#8]
000060  f5b06f80          CMP      r0,#0x400
000064  d105              BNE      |L55.114|
                  |L55.102|
;;;3542           {
;;;3543             /* Disable SPI peripheral */
;;;3544             __HAL_SPI_DISABLE(hspi);
000066  6820              LDR      r0,[r4,#0]
000068  6800              LDR      r0,[r0,#0]
00006a  f0200040          BIC      r0,r0,#0x40
00006e  6821              LDR      r1,[r4,#0]
000070  6008              STR      r0,[r1,#0]
                  |L55.114|
;;;3545           }
;;;3546   
;;;3547           /* Reset CRC Calculation */
;;;3548           if (hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
000072  6aa0              LDR      r0,[r4,#0x28]
000074  f5b05f00          CMP      r0,#0x2000
000078  d10d              BNE      |L55.150|
;;;3549           {
;;;3550             SPI_RESET_CRC(hspi);
00007a  bf00              NOP      
00007c  6820              LDR      r0,[r4,#0]
00007e  6800              LDR      r0,[r0,#0]
000080  f4205000          BIC      r0,r0,#0x2000
000084  6821              LDR      r1,[r4,#0]
000086  6008              STR      r0,[r1,#0]
000088  6820              LDR      r0,[r4,#0]
00008a  6800              LDR      r0,[r0,#0]
00008c  f4405000          ORR      r0,r0,#0x2000
000090  6821              LDR      r1,[r4,#0]
000092  6008              STR      r0,[r1,#0]
000094  bf00              NOP      
                  |L55.150|
;;;3551           }
;;;3552   
;;;3553           hspi->State = HAL_SPI_STATE_READY;
000096  2001              MOVS     r0,#1
000098  f8840051          STRB     r0,[r4,#0x51]
;;;3554   
;;;3555           /* Process Unlocked */
;;;3556           __HAL_UNLOCK(hspi);
00009c  bf00              NOP      
00009e  2000              MOVS     r0,#0
0000a0  f8840050          STRB     r0,[r4,#0x50]
0000a4  bf00              NOP      
;;;3557   
;;;3558           return HAL_TIMEOUT;
0000a6  2003              MOVS     r0,#3
                  |L55.168|
;;;3559         }
;;;3560         /* If Systick is disabled or not incremented, deactivate timeout to go in disable loop procedure */
;;;3561         if(count == 0U)
;;;3562         {
;;;3563           tmp_timeout = 0U;
;;;3564         }
;;;3565         count--;
;;;3566       }
;;;3567     }
;;;3568   
;;;3569     return HAL_OK;
;;;3570   }
0000a8  e8bd8ff8          POP      {r3-r11,pc}
                  |L55.172|
0000ac  e7ff              B        |L55.174|
                  |L55.174|
0000ae  9800              LDR      r0,[sp,#0]            ;3561
0000b0  b900              CBNZ     r0,|L55.180|
0000b2  2700              MOVS     r7,#0                 ;3563
                  |L55.180|
0000b4  9800              LDR      r0,[sp,#0]            ;3565
0000b6  1e40              SUBS     r0,r0,#1              ;3565
0000b8  9000              STR      r0,[sp,#0]            ;3565
                  |L55.186|
0000ba  6820              LDR      r0,[r4,#0]            ;3527
0000bc  6880              LDR      r0,[r0,#8]            ;3527
0000be  4028              ANDS     r0,r0,r5              ;3527
0000c0  42a8              CMP      r0,r5                 ;3527
0000c2  d101              BNE      |L55.200|
0000c4  2001              MOVS     r0,#1                 ;3527
0000c6  e000              B        |L55.202|
                  |L55.200|
0000c8  2000              MOVS     r0,#0                 ;3527
                  |L55.202|
0000ca  4540              CMP      r0,r8                 ;3527
0000cc  d1af              BNE      |L55.46|
0000ce  2000              MOVS     r0,#0                 ;3569
0000d0  e7ea              B        |L55.168|
;;;3571   
                          ENDP

0000d2  0000              DCW      0x0000
                  |L55.212|
                          DCD      SystemCoreClock

;*** Start embedded assembler ***

#line 1 "../Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_spi.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___19_stm32f1xx_hal_spi_c_5e7b22bd____REV16|
#line 463 "../Drivers/CMSIS/Include/cmsis_armcc.h"
|__asm___19_stm32f1xx_hal_spi_c_5e7b22bd____REV16| PROC
#line 464

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___19_stm32f1xx_hal_spi_c_5e7b22bd____REVSH|
#line 478
|__asm___19_stm32f1xx_hal_spi_c_5e7b22bd____REVSH| PROC
#line 479

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___19_stm32f1xx_hal_spi_c_5e7b22bd____RRX|
#line 665
|__asm___19_stm32f1xx_hal_spi_c_5e7b22bd____RRX| PROC
#line 666

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
