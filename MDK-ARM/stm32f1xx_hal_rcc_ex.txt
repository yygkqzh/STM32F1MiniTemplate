; generated by Component: ARM Compiler 5.06 update 7 (build 960) Tool: ArmCC [4d365d]
; commandline ArmCC [--c99 --split_sections --debug -c --asm --interleave -otemplate\stm32f1xx_hal_rcc_ex.o --asm_dir=./ --list_dir=--list --depend=template\stm32f1xx_hal_rcc_ex.d --cpu=Cortex-M3 --apcs=interwork -O0 --diag_suppress=9931 -I../Inc -I../Drivers/STM32F1xx_HAL_Driver/Inc -I../Drivers/STM32F1xx_HAL_Driver/Inc/Legacy -I../Middlewares/Third_Party/FatFs/src -I../Drivers/CMSIS/Device/ST/STM32F1xx/Include -I../Drivers/CMSIS/Include -I.\RTE\_Template -ID:\Keil_v5\Pack\ARM\CMSIS\5.7.0\CMSIS\Core\Include -ID:\Keil_v5\Pack\Keil\STM32F1xx_DFP\2.3.0\Device\Include -D__MICROLIB -D__UVISION_VERSION=533 -D_RTE_ -DSTM32F10X_MD -D_RTE_ -DUSE_FULL_LL_DRIVER -DUSE_HAL_DRIVER -DSTM32F103xB --signed_chars --omf_browse=template\stm32f1xx_hal_rcc_ex.crf ../Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_rcc_ex.c]
                          THUMB

                          AREA ||i.HAL_RCCEx_GetPeriphCLKConfig||, CODE, READONLY, ALIGN=2

                  HAL_RCCEx_GetPeriphCLKConfig PROC
;;;293      */
;;;294    void HAL_RCCEx_GetPeriphCLKConfig(RCC_PeriphCLKInitTypeDef  *PeriphClkInit)
000000  2100              MOVS     r1,#0
;;;295    {
;;;296      uint32_t srcclk = 0U;
;;;297    
;;;298      /* Set all possible values for the extended clock type parameter------------*/
;;;299      PeriphClkInit->PeriphClockSelection = RCC_PERIPHCLK_RTC;
000002  2201              MOVS     r2,#1
000004  6002              STR      r2,[r0,#0]
;;;300    
;;;301      /* Get the RTC configuration -----------------------------------------------*/
;;;302      srcclk = __HAL_RCC_GET_RTC_SOURCE();
000006  4a0c              LDR      r2,|L1.56|
000008  6a12              LDR      r2,[r2,#0x20]
00000a  f4027140          AND      r1,r2,#0x300
;;;303      /* Source clock is LSE or LSI*/
;;;304      PeriphClkInit->RTCClockSelection = srcclk;
00000e  6041              STR      r1,[r0,#4]
;;;305    
;;;306      /* Get the ADC clock configuration -----------------------------------------*/
;;;307      PeriphClkInit->PeriphClockSelection |= RCC_PERIPHCLK_ADC;
000010  6802              LDR      r2,[r0,#0]
000012  f0420202          ORR      r2,r2,#2
000016  6002              STR      r2,[r0,#0]
;;;308      PeriphClkInit->AdcClockSelection = __HAL_RCC_GET_ADC_SOURCE();
000018  4a07              LDR      r2,|L1.56|
00001a  6852              LDR      r2,[r2,#4]
00001c  f4024240          AND      r2,r2,#0xc000
000020  6082              STR      r2,[r0,#8]
;;;309    
;;;310    #if defined(STM32F105xC) || defined(STM32F107xC)
;;;311      /* Get the I2S2 clock configuration -----------------------------------------*/
;;;312      PeriphClkInit->PeriphClockSelection |= RCC_PERIPHCLK_I2S2;
;;;313      PeriphClkInit->I2s2ClockSelection = __HAL_RCC_GET_I2S2_SOURCE();
;;;314    
;;;315      /* Get the I2S3 clock configuration -----------------------------------------*/
;;;316      PeriphClkInit->PeriphClockSelection |= RCC_PERIPHCLK_I2S3;
;;;317      PeriphClkInit->I2s3ClockSelection = __HAL_RCC_GET_I2S3_SOURCE();
;;;318    
;;;319    #endif /* STM32F105xC || STM32F107xC */
;;;320    
;;;321    #if defined(STM32F103xE) || defined(STM32F103xG)
;;;322      /* Get the I2S2 clock configuration -----------------------------------------*/
;;;323      PeriphClkInit->PeriphClockSelection |= RCC_PERIPHCLK_I2S2;
;;;324      PeriphClkInit->I2s2ClockSelection = RCC_I2S2CLKSOURCE_SYSCLK;
;;;325    
;;;326      /* Get the I2S3 clock configuration -----------------------------------------*/
;;;327      PeriphClkInit->PeriphClockSelection |= RCC_PERIPHCLK_I2S3;
;;;328      PeriphClkInit->I2s3ClockSelection = RCC_I2S3CLKSOURCE_SYSCLK;
;;;329    
;;;330    #endif /* STM32F103xE || STM32F103xG */
;;;331    
;;;332    #if defined(STM32F102x6) || defined(STM32F102xB) || defined(STM32F103x6)\
;;;333     || defined(STM32F103xB) || defined(STM32F103xE) || defined(STM32F103xG)\
;;;334     || defined(STM32F105xC) || defined(STM32F107xC)
;;;335      /* Get the USB clock configuration -----------------------------------------*/
;;;336      PeriphClkInit->PeriphClockSelection |= RCC_PERIPHCLK_USB;
000022  6802              LDR      r2,[r0,#0]
000024  f0420210          ORR      r2,r2,#0x10
000028  6002              STR      r2,[r0,#0]
;;;337      PeriphClkInit->UsbClockSelection = __HAL_RCC_GET_USB_SOURCE();
00002a  4a03              LDR      r2,|L1.56|
00002c  6852              LDR      r2,[r2,#4]
00002e  f4020280          AND      r2,r2,#0x400000
000032  60c2              STR      r2,[r0,#0xc]
;;;338    #endif /* STM32F102x6 || STM32F102xB || STM32F103x6 || STM32F103xB || STM32F103xE || STM32F103xG || STM32F105xC || STM32F107xC */
;;;339    }
000034  4770              BX       lr
;;;340    
                          ENDP

000036  0000              DCW      0x0000
                  |L1.56|
                          DCD      0x40021000

                          AREA ||i.HAL_RCCEx_GetPeriphCLKFreq||, CODE, READONLY, ALIGN=2

                  HAL_RCCEx_GetPeriphCLKFreq PROC
;;;386      */
;;;387    uint32_t HAL_RCCEx_GetPeriphCLKFreq(uint32_t PeriphClk)
000000  e92d43f0          PUSH     {r4-r9,lr}
;;;388    {
000004  b085              SUB      sp,sp,#0x14
000006  4605              MOV      r5,r0
;;;389    #if defined(STM32F105xC) || defined(STM32F107xC)
;;;390      const uint8_t aPLLMULFactorTable[14] = {0, 0, 4, 5, 6, 7, 8, 9, 0, 0, 0, 0, 0, 13};
;;;391      const uint8_t aPredivFactorTable[16] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16};
;;;392    
;;;393      uint32_t prediv1 = 0U, pllclk = 0U, pllmul = 0U;
;;;394      uint32_t pll2mul = 0U, pll3mul = 0U, prediv2 = 0U;
;;;395    #endif /* STM32F105xC || STM32F107xC */
;;;396    #if defined(STM32F102x6) || defined(STM32F102xB) || defined(STM32F103x6) || \
;;;397        defined(STM32F103xB) || defined(STM32F103xE) || defined(STM32F103xG)
;;;398      const uint8_t aPLLMULFactorTable[16] = {2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 16};
000008  a344              ADR      r3,|L2.284|
00000a  cb0f              LDM      r3,{r0-r3}
00000c  ac01              ADD      r4,sp,#4
00000e  c40f              STM      r4!,{r0-r3}
;;;399      const uint8_t aPredivFactorTable[2] = {1, 2};
000010  a046              ADR      r0,|L2.300|
000012  6800              LDR      r0,[r0,#0]
000014  9000              STR      r0,[sp,#0]
;;;400    
;;;401      uint32_t prediv1 = 0U, pllclk = 0U, pllmul = 0U;
000016  f04f0800          MOV      r8,#0
00001a  2600              MOVS     r6,#0
00001c  2700              MOVS     r7,#0
;;;402    #endif /* STM32F102x6 || STM32F102xB || STM32F103x6 || STM32F103xB || STM32F103xE || STM32F103xG */
;;;403      uint32_t temp_reg = 0U, frequency = 0U;
00001e  2400              MOVS     r4,#0
000020  46a1              MOV      r9,r4
;;;404    
;;;405      /* Check the parameters */
;;;406      assert_param(IS_RCC_PERIPHCLOCK(PeriphClk));
000022  f0050001          AND      r0,r5,#1
000026  b938              CBNZ     r0,|L2.56|
000028  f0050002          AND      r0,r5,#2
00002c  2802              CMP      r0,#2
00002e  d003              BEQ      |L2.56|
000030  f0050010          AND      r0,r5,#0x10
000034  2810              CMP      r0,#0x10
000036  d100              BNE      |L2.58|
                  |L2.56|
000038  e004              B        |L2.68|
                  |L2.58|
00003a  f44f71cb          MOV      r1,#0x196
00003e  a03c              ADR      r0,|L2.304|
000040  f7fffffe          BL       assert_failed
                  |L2.68|
;;;407    
;;;408      switch (PeriphClk)
000044  2d01              CMP      r5,#1
000046  d030              BEQ      |L2.170|
000048  2d02              CMP      r5,#2
00004a  d055              BEQ      |L2.248|
00004c  2d10              CMP      r5,#0x10
00004e  d15e              BNE      |L2.270|
;;;409      {
;;;410    #if defined(STM32F102x6) || defined(STM32F102xB) || defined(STM32F103x6)\
;;;411     || defined(STM32F103xB) || defined(STM32F103xE) || defined(STM32F103xG)\
;;;412     || defined(STM32F105xC) || defined(STM32F107xC)
;;;413        case RCC_PERIPHCLK_USB:
;;;414        {
;;;415          /* Get RCC configuration ------------------------------------------------------*/
;;;416          temp_reg = RCC->CFGR;
000050  4846              LDR      r0,|L2.364|
000052  6844              LDR      r4,[r0,#4]
;;;417    
;;;418          /* Check if PLL is enabled */
;;;419          if (HAL_IS_BIT_SET(RCC->CR, RCC_CR_PLLON))
000054  6800              LDR      r0,[r0,#0]
000056  f0007080          AND      r0,r0,#0x1000000
00005a  b300              CBZ      r0,|L2.158|
;;;420          {
;;;421            pllmul = aPLLMULFactorTable[(uint32_t)(temp_reg & RCC_CFGR_PLLMULL) >> RCC_CFGR_PLLMULL_Pos];
00005c  a801              ADD      r0,sp,#4
00005e  f3c44183          UBFX     r1,r4,#18,#4
000062  5c47              LDRB     r7,[r0,r1]
;;;422            if ((temp_reg & RCC_CFGR_PLLSRC) != RCC_PLLSOURCE_HSI_DIV2)
000064  f4043080          AND      r0,r4,#0x10000
000068  b170              CBZ      r0,|L2.136|
;;;423            {
;;;424    #if defined(STM32F105xC) || defined(STM32F107xC) || defined(STM32F100xB)\
;;;425     || defined(STM32F100xE)
;;;426              prediv1 = aPredivFactorTable[(uint32_t)(RCC->CFGR2 & RCC_CFGR2_PREDIV1) >> RCC_CFGR2_PREDIV1_Pos];
;;;427    #else
;;;428              prediv1 = aPredivFactorTable[(uint32_t)(RCC->CFGR & RCC_CFGR_PLLXTPRE) >> RCC_CFGR_PLLXTPRE_Pos];
00006a  4840              LDR      r0,|L2.364|
00006c  6840              LDR      r0,[r0,#4]
00006e  f3c04040          UBFX     r0,r0,#17,#1
000072  f81d8000          LDRB     r8,[sp,r0]
;;;429    #endif /* STM32F105xC || STM32F107xC || STM32F100xB || STM32F100xE */
;;;430    
;;;431    #if defined(STM32F105xC) || defined(STM32F107xC)
;;;432              if (HAL_IS_BIT_SET(RCC->CFGR2, RCC_CFGR2_PREDIV1SRC))
;;;433              {
;;;434                /* PLL2 selected as Prediv1 source */
;;;435                /* PLLCLK = PLL2CLK / PREDIV1 * PLLMUL with PLL2CLK = HSE/PREDIV2 * PLL2MUL */
;;;436                prediv2 = ((RCC->CFGR2 & RCC_CFGR2_PREDIV2) >> RCC_CFGR2_PREDIV2_Pos) + 1;
;;;437                pll2mul = ((RCC->CFGR2 & RCC_CFGR2_PLL2MUL) >> RCC_CFGR2_PLL2MUL_Pos) + 2;
;;;438                pllclk = (uint32_t)((((HSE_VALUE / prediv2) * pll2mul) / prediv1) * pllmul);
;;;439              }
;;;440              else
;;;441              {
;;;442                /* HSE used as PLL clock source : PLLCLK = HSE/PREDIV1 * PLLMUL */
;;;443                pllclk = (uint32_t)((HSE_VALUE / prediv1) * pllmul);
;;;444              }
;;;445    
;;;446              /* If PLLMUL was set to 13 means that it was to cover the case PLLMUL 6.5 (avoid using float) */
;;;447              /* In this case need to divide pllclk by 2 */
;;;448              if (pllmul == aPLLMULFactorTable[(uint32_t)(RCC_CFGR_PLLMULL6_5) >> RCC_CFGR_PLLMULL_Pos])
;;;449              {
;;;450                pllclk = pllclk / 2;
;;;451              }
;;;452    #else
;;;453              if ((temp_reg & RCC_CFGR_PLLSRC) != RCC_PLLSOURCE_HSI_DIV2)
000076  f4043080          AND      r0,r4,#0x10000
00007a  b140              CBZ      r0,|L2.142|
;;;454              {
;;;455                /* HSE used as PLL clock source : PLLCLK = HSE/PREDIV1 * PLLMUL */
;;;456                pllclk = (uint32_t)((HSE_VALUE / prediv1) * pllmul);
00007c  483c              LDR      r0,|L2.368|
00007e  fbb0f0f8          UDIV     r0,r0,r8
000082  fb00f607          MUL      r6,r0,r7
000086  e002              B        |L2.142|
                  |L2.136|
;;;457              }
;;;458    #endif /* STM32F105xC || STM32F107xC */
;;;459            }
;;;460            else
;;;461            {
;;;462              /* HSI used as PLL clock source : PLLCLK = HSI/2 * PLLMUL */
;;;463              pllclk = (uint32_t)((HSI_VALUE >> 1) * pllmul);
000088  483a              LDR      r0,|L2.372|
00008a  fb07f600          MUL      r6,r7,r0
                  |L2.142|
;;;464            }
;;;465    
;;;466            /* Calcul of the USB frequency*/
;;;467    #if defined(STM32F105xC) || defined(STM32F107xC)
;;;468            /* USBCLK = PLLVCO = (2 x PLLCLK) / USB prescaler */
;;;469            if (__HAL_RCC_GET_USB_SOURCE() == RCC_USBCLKSOURCE_PLL_DIV2)
;;;470            {
;;;471              /* Prescaler of 2 selected for USB */
;;;472              frequency = pllclk;
;;;473            }
;;;474            else
;;;475            {
;;;476              /* Prescaler of 3 selected for USB */
;;;477              frequency = (2 * pllclk) / 3;
;;;478            }
;;;479    #else
;;;480            /* USBCLK = PLLCLK / USB prescaler */
;;;481            if (__HAL_RCC_GET_USB_SOURCE() == RCC_USBCLKSOURCE_PLL)
00008e  4837              LDR      r0,|L2.364|
000090  6840              LDR      r0,[r0,#4]
000092  f4000080          AND      r0,r0,#0x400000
000096  f5b00f80          CMP      r0,#0x400000
00009a  d101              BNE      |L2.160|
;;;482            {
;;;483              /* No prescaler selected for USB */
;;;484              frequency = pllclk;
00009c  46b1              MOV      r9,r6
                  |L2.158|
00009e  e003              B        |L2.168|
                  |L2.160|
;;;485            }
;;;486            else
;;;487            {
;;;488              /* Prescaler of 1.5 selected for USB */
;;;489              frequency = (pllclk * 2) / 3;
0000a0  0070              LSLS     r0,r6,#1
0000a2  2103              MOVS     r1,#3
0000a4  fbb0f9f1          UDIV     r9,r0,r1
                  |L2.168|
;;;490            }
;;;491    #endif
;;;492          }
;;;493          break;
0000a8  e032              B        |L2.272|
                  |L2.170|
;;;494        }
;;;495    #endif /* STM32F102x6 || STM32F102xB || STM32F103x6 || STM32F103xB || STM32F103xE || STM32F103xG || STM32F105xC || STM32F107xC */
;;;496    #if defined(STM32F103xE) || defined(STM32F103xG) || defined(STM32F105xC) || defined(STM32F107xC)
;;;497        case RCC_PERIPHCLK_I2S2:
;;;498        {
;;;499    #if defined(STM32F103xE) || defined(STM32F103xG)
;;;500          /* SYSCLK used as source clock for I2S2 */
;;;501          frequency = HAL_RCC_GetSysClockFreq();
;;;502    #else
;;;503          if (__HAL_RCC_GET_I2S2_SOURCE() == RCC_I2S2CLKSOURCE_SYSCLK)
;;;504          {
;;;505            /* SYSCLK used as source clock for I2S2 */
;;;506            frequency = HAL_RCC_GetSysClockFreq();
;;;507          }
;;;508          else
;;;509          {
;;;510            /* Check if PLLI2S is enabled */
;;;511            if (HAL_IS_BIT_SET(RCC->CR, RCC_CR_PLL3ON))
;;;512            {
;;;513              /* PLLI2SVCO = 2 * PLLI2SCLK = 2 * (HSE/PREDIV2 * PLL3MUL) */
;;;514              prediv2 = ((RCC->CFGR2 & RCC_CFGR2_PREDIV2) >> RCC_CFGR2_PREDIV2_Pos) + 1;
;;;515              pll3mul = ((RCC->CFGR2 & RCC_CFGR2_PLL3MUL) >> RCC_CFGR2_PLL3MUL_Pos) + 2;
;;;516              frequency = (uint32_t)(2 * ((HSE_VALUE / prediv2) * pll3mul));
;;;517            }
;;;518          }
;;;519    #endif /* STM32F103xE || STM32F103xG */
;;;520          break;
;;;521        }
;;;522        case RCC_PERIPHCLK_I2S3:
;;;523        {
;;;524    #if defined(STM32F103xE) || defined(STM32F103xG)
;;;525          /* SYSCLK used as source clock for I2S3 */
;;;526          frequency = HAL_RCC_GetSysClockFreq();
;;;527    #else
;;;528          if (__HAL_RCC_GET_I2S3_SOURCE() == RCC_I2S3CLKSOURCE_SYSCLK)
;;;529          {
;;;530            /* SYSCLK used as source clock for I2S3 */
;;;531            frequency = HAL_RCC_GetSysClockFreq();
;;;532          }
;;;533          else
;;;534          {
;;;535            /* Check if PLLI2S is enabled */
;;;536            if (HAL_IS_BIT_SET(RCC->CR, RCC_CR_PLL3ON))
;;;537            {
;;;538              /* PLLI2SVCO = 2 * PLLI2SCLK = 2 * (HSE/PREDIV2 * PLL3MUL) */
;;;539              prediv2 = ((RCC->CFGR2 & RCC_CFGR2_PREDIV2) >> RCC_CFGR2_PREDIV2_Pos) + 1;
;;;540              pll3mul = ((RCC->CFGR2 & RCC_CFGR2_PLL3MUL) >> RCC_CFGR2_PLL3MUL_Pos) + 2;
;;;541              frequency = (uint32_t)(2 * ((HSE_VALUE / prediv2) * pll3mul));
;;;542            }
;;;543          }
;;;544    #endif /* STM32F103xE || STM32F103xG */
;;;545          break;
;;;546        }
;;;547    #endif /* STM32F103xE || STM32F103xG || STM32F105xC || STM32F107xC */
;;;548        case RCC_PERIPHCLK_RTC:
;;;549        {
;;;550          /* Get RCC BDCR configuration ------------------------------------------------------*/
;;;551          temp_reg = RCC->BDCR;
0000aa  4830              LDR      r0,|L2.364|
0000ac  6a04              LDR      r4,[r0,#0x20]
;;;552    
;;;553          /* Check if LSE is ready if RTC clock selection is LSE */
;;;554          if (((temp_reg & RCC_BDCR_RTCSEL) == RCC_RTCCLKSOURCE_LSE) && (HAL_IS_BIT_SET(temp_reg, RCC_BDCR_LSERDY)))
0000ae  f4047040          AND      r0,r4,#0x300
0000b2  f5b07f80          CMP      r0,#0x100
0000b6  d105              BNE      |L2.196|
0000b8  f0040002          AND      r0,r4,#2
0000bc  b110              CBZ      r0,|L2.196|
;;;555          {
;;;556            frequency = LSE_VALUE;
0000be  f44f4900          MOV      r9,#0x8000
0000c2  e018              B        |L2.246|
                  |L2.196|
;;;557          }
;;;558          /* Check if LSI is ready if RTC clock selection is LSI */
;;;559          else if (((temp_reg & RCC_BDCR_RTCSEL) == RCC_RTCCLKSOURCE_LSI) && (HAL_IS_BIT_SET(RCC->CSR, RCC_CSR_LSIRDY)))
0000c4  f4047040          AND      r0,r4,#0x300
0000c8  f5b07f00          CMP      r0,#0x200
0000cc  d107              BNE      |L2.222|
0000ce  4827              LDR      r0,|L2.364|
0000d0  6a40              LDR      r0,[r0,#0x24]
0000d2  f0000002          AND      r0,r0,#2
0000d6  b110              CBZ      r0,|L2.222|
;;;560          {
;;;561            frequency = LSI_VALUE;
0000d8  f6494940          MOV      r9,#0x9c40
0000dc  e00b              B        |L2.246|
                  |L2.222|
;;;562          }
;;;563          else if (((temp_reg & RCC_BDCR_RTCSEL) == RCC_RTCCLKSOURCE_HSE_DIV128) && (HAL_IS_BIT_SET(RCC->CR, RCC_CR_HSERDY)))
0000de  f4047040          AND      r0,r4,#0x300
0000e2  f5b07f40          CMP      r0,#0x300
0000e6  d106              BNE      |L2.246|
0000e8  4820              LDR      r0,|L2.364|
0000ea  6800              LDR      r0,[r0,#0]
0000ec  f4003000          AND      r0,r0,#0x20000
0000f0  b108              CBZ      r0,|L2.246|
;;;564          {
;;;565            frequency = HSE_VALUE / 128U;
0000f2  f24f4924          MOV      r9,#0xf424
                  |L2.246|
;;;566          }
;;;567          /* Clock not enabled for RTC*/
;;;568          else
;;;569          {
;;;570            /* nothing to do: frequency already initialized to 0U */
;;;571          }
;;;572          break;
0000f6  e00b              B        |L2.272|
                  |L2.248|
;;;573        }
;;;574        case RCC_PERIPHCLK_ADC:
;;;575        {
;;;576          frequency = HAL_RCC_GetPCLK2Freq() / (((__HAL_RCC_GET_ADC_SOURCE() >> RCC_CFGR_ADCPRE_Pos) + 1) * 2);
0000f8  f7fffffe          BL       HAL_RCC_GetPCLK2Freq
0000fc  491b              LDR      r1,|L2.364|
0000fe  6849              LDR      r1,[r1,#4]
000100  f3c13181          UBFX     r1,r1,#14,#2
000104  1c49              ADDS     r1,r1,#1
000106  0049              LSLS     r1,r1,#1
000108  fbb0f9f1          UDIV     r9,r0,r1
;;;577          break;
00010c  e000              B        |L2.272|
                  |L2.270|
;;;578        }
;;;579        default:
;;;580        {
;;;581          break;
00010e  bf00              NOP      
                  |L2.272|
000110  bf00              NOP                            ;493
;;;582        }
;;;583      }
;;;584      return (frequency);
000112  4648              MOV      r0,r9
;;;585    }
000114  b005              ADD      sp,sp,#0x14
000116  e8bd83f0          POP      {r4-r9,pc}
;;;586    
                          ENDP

00011a  0000              DCW      0x0000
                  |L2.284|
00011c  02030405          DCB      2,3,4,5,6,"\a\b\t\n\v\f\r",14,15,16,16
000120  06070809
000124  0a0b0c0d
000128  0e0f1010
                  |L2.300|
00012c  010200            DCB      1,2,0
00012f  00                DCB      0
                  |L2.304|
000130  2e2e2f44          DCB      "../Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_rcc_e"
000134  72697665
000138  72732f53
00013c  544d3332
000140  46317878
000144  5f48414c
000148  5f447269
00014c  7665722f
000150  5372632f
000154  73746d33
000158  32663178
00015c  785f6861
000160  6c5f7263
000164  635f65  
000167  782e6300          DCB      "x.c",0
00016b  00                DCB      0
                  |L2.364|
                          DCD      0x40021000
                  |L2.368|
                          DCD      0x007a1200
                  |L2.372|
                          DCD      0x003d0900

                          AREA ||i.HAL_RCCEx_PeriphCLKConfig||, CODE, READONLY, ALIGN=2

                  HAL_RCCEx_PeriphCLKConfig PROC
;;;99       */
;;;100    HAL_StatusTypeDef HAL_RCCEx_PeriphCLKConfig(RCC_PeriphCLKInitTypeDef  *PeriphClkInit)
000000  b5f8              PUSH     {r3-r7,lr}
;;;101    {
000002  4604              MOV      r4,r0
;;;102      uint32_t tickstart = 0U, temp_reg = 0U;
000004  2600              MOVS     r6,#0
000006  2500              MOVS     r5,#0
;;;103    #if defined(STM32F105xC) || defined(STM32F107xC)
;;;104      uint32_t  pllactive = 0U;
;;;105    #endif /* STM32F105xC || STM32F107xC */
;;;106    
;;;107      /* Check the parameters */
;;;108      assert_param(IS_RCC_PERIPHCLOCK(PeriphClkInit->PeriphClockSelection));
000008  7820              LDRB     r0,[r4,#0]
00000a  f0000001          AND      r0,r0,#1
00000e  b948              CBNZ     r0,|L3.36|
000010  7820              LDRB     r0,[r4,#0]
000012  f0000002          AND      r0,r0,#2
000016  2802              CMP      r0,#2
000018  d004              BEQ      |L3.36|
00001a  7820              LDRB     r0,[r4,#0]
00001c  f0000010          AND      r0,r0,#0x10
000020  2810              CMP      r0,#0x10
000022  d100              BNE      |L3.38|
                  |L3.36|
000024  e003              B        |L3.46|
                  |L3.38|
000026  216c              MOVS     r1,#0x6c
000028  a061              ADR      r0,|L3.432|
00002a  f7fffffe          BL       assert_failed
                  |L3.46|
;;;109    
;;;110      /*------------------------------- RTC/LCD Configuration ------------------------*/
;;;111      if ((((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_RTC) == RCC_PERIPHCLK_RTC))
00002e  7820              LDRB     r0,[r4,#0]
000030  f0000001          AND      r0,r0,#1
000034  2800              CMP      r0,#0
000036  d07d              BEQ      |L3.308|
;;;112      {
;;;113        /* check for RTC Parameters used to output RTCCLK */
;;;114        assert_param(IS_RCC_RTCCLKSOURCE(PeriphClkInit->RTCClockSelection));
000038  6860              LDR      r0,[r4,#4]
00003a  b158              CBZ      r0,|L3.84|
00003c  6860              LDR      r0,[r4,#4]
00003e  f5b07f80          CMP      r0,#0x100
000042  d007              BEQ      |L3.84|
000044  6860              LDR      r0,[r4,#4]
000046  f5b07f00          CMP      r0,#0x200
00004a  d003              BEQ      |L3.84|
00004c  6860              LDR      r0,[r4,#4]
00004e  f5b07f40          CMP      r0,#0x300
000052  d100              BNE      |L3.86|
                  |L3.84|
000054  e003              B        |L3.94|
                  |L3.86|
000056  2172              MOVS     r1,#0x72
000058  a055              ADR      r0,|L3.432|
00005a  f7fffffe          BL       assert_failed
                  |L3.94|
;;;115    
;;;116        FlagStatus       pwrclkchanged = RESET;
00005e  2700              MOVS     r7,#0
;;;117    
;;;118        /* As soon as function is called to change RTC clock source, activation of the
;;;119           power domain is done. */
;;;120        /* Requires to enable write access to Backup Domain of necessary */
;;;121        if (__HAL_RCC_PWR_IS_CLK_DISABLED())
000060  4862              LDR      r0,|L3.492|
000062  69c0              LDR      r0,[r0,#0x1c]
000064  f0005080          AND      r0,r0,#0x10000000
000068  b970              CBNZ     r0,|L3.136|
;;;122        {
;;;123          __HAL_RCC_PWR_CLK_ENABLE();
00006a  bf00              NOP      
00006c  485f              LDR      r0,|L3.492|
00006e  69c0              LDR      r0,[r0,#0x1c]
000070  f0405080          ORR      r0,r0,#0x10000000
000074  495d              LDR      r1,|L3.492|
000076  61c8              STR      r0,[r1,#0x1c]
000078  4608              MOV      r0,r1
00007a  69c0              LDR      r0,[r0,#0x1c]
00007c  f0005080          AND      r0,r0,#0x10000000
000080  9000              STR      r0,[sp,#0]
000082  bf00              NOP      
000084  bf00              NOP      
;;;124          pwrclkchanged = SET;
000086  2701              MOVS     r7,#1
                  |L3.136|
;;;125        }
;;;126    
;;;127        if (HAL_IS_BIT_CLR(PWR->CR, PWR_CR_DBP))
000088  4859              LDR      r0,|L3.496|
00008a  6800              LDR      r0,[r0,#0]
00008c  f4007080          AND      r0,r0,#0x100
000090  b9b0              CBNZ     r0,|L3.192|
;;;128        {
;;;129          /* Enable write access to Backup domain */
;;;130          SET_BIT(PWR->CR, PWR_CR_DBP);
000092  4857              LDR      r0,|L3.496|
000094  6800              LDR      r0,[r0,#0]
000096  f4407080          ORR      r0,r0,#0x100
00009a  4955              LDR      r1,|L3.496|
00009c  6008              STR      r0,[r1,#0]
;;;131    
;;;132          /* Wait for Backup domain Write protection disable */
;;;133          tickstart = HAL_GetTick();
00009e  f7fffffe          BL       HAL_GetTick
0000a2  4606              MOV      r6,r0
;;;134    
;;;135          while (HAL_IS_BIT_CLR(PWR->CR, PWR_CR_DBP))
0000a4  e006              B        |L3.180|
                  |L3.166|
;;;136          {
;;;137            if ((HAL_GetTick() - tickstart) > RCC_DBP_TIMEOUT_VALUE)
0000a6  f7fffffe          BL       HAL_GetTick
0000aa  1b80              SUBS     r0,r0,r6
0000ac  2864              CMP      r0,#0x64
0000ae  d901              BLS      |L3.180|
;;;138            {
;;;139              return HAL_TIMEOUT;
0000b0  2003              MOVS     r0,#3
                  |L3.178|
;;;140            }
;;;141          }
;;;142        }
;;;143    
;;;144        /* Reset the Backup domain only if the RTC Clock source selection is modified from reset value */
;;;145        temp_reg = (RCC->BDCR & RCC_BDCR_RTCSEL);
;;;146        if ((temp_reg != 0x00000000U) && (temp_reg != (PeriphClkInit->RTCClockSelection & RCC_BDCR_RTCSEL)))
;;;147        {
;;;148          /* Store the content of BDCR register before the reset of Backup Domain */
;;;149          temp_reg = (RCC->BDCR & ~(RCC_BDCR_RTCSEL));
;;;150          /* RTC Clock selection can be changed only if the Backup Domain is reset */
;;;151          __HAL_RCC_BACKUPRESET_FORCE();
;;;152          __HAL_RCC_BACKUPRESET_RELEASE();
;;;153          /* Restore the Content of BDCR register */
;;;154          RCC->BDCR = temp_reg;
;;;155    
;;;156          /* Wait for LSERDY if LSE was enabled */
;;;157          if (HAL_IS_BIT_SET(temp_reg, RCC_BDCR_LSEON))
;;;158          {
;;;159            /* Get Start Tick */
;;;160            tickstart = HAL_GetTick();
;;;161    
;;;162            /* Wait till LSE is ready */
;;;163            while (__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) == RESET)
;;;164            {
;;;165              if ((HAL_GetTick() - tickstart) > RCC_LSE_TIMEOUT_VALUE)
;;;166              {
;;;167                return HAL_TIMEOUT;
;;;168              }
;;;169            }
;;;170          }
;;;171        }
;;;172        __HAL_RCC_RTC_CONFIG(PeriphClkInit->RTCClockSelection);
;;;173    
;;;174        /* Require to disable power clock if necessary */
;;;175        if (pwrclkchanged == SET)
;;;176        {
;;;177          __HAL_RCC_PWR_CLK_DISABLE();
;;;178        }
;;;179      }
;;;180    
;;;181      /*------------------------------ ADC clock Configuration ------------------*/
;;;182      if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_ADC) == RCC_PERIPHCLK_ADC)
;;;183      {
;;;184        /* Check the parameters */
;;;185        assert_param(IS_RCC_ADCPLLCLK_DIV(PeriphClkInit->AdcClockSelection));
;;;186    
;;;187        /* Configure the ADC clock source */
;;;188        __HAL_RCC_ADC_CONFIG(PeriphClkInit->AdcClockSelection);
;;;189      }
;;;190    
;;;191    #if defined(STM32F105xC) || defined(STM32F107xC)
;;;192      /*------------------------------ I2S2 Configuration ------------------------*/
;;;193      if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_I2S2) == RCC_PERIPHCLK_I2S2)
;;;194      {
;;;195        /* Check the parameters */
;;;196        assert_param(IS_RCC_I2S2CLKSOURCE(PeriphClkInit->I2s2ClockSelection));
;;;197    
;;;198        /* Configure the I2S2 clock source */
;;;199        __HAL_RCC_I2S2_CONFIG(PeriphClkInit->I2s2ClockSelection);
;;;200      }
;;;201    
;;;202      /*------------------------------ I2S3 Configuration ------------------------*/
;;;203      if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_I2S3) == RCC_PERIPHCLK_I2S3)
;;;204      {
;;;205        /* Check the parameters */
;;;206        assert_param(IS_RCC_I2S3CLKSOURCE(PeriphClkInit->I2s3ClockSelection));
;;;207    
;;;208        /* Configure the I2S3 clock source */
;;;209        __HAL_RCC_I2S3_CONFIG(PeriphClkInit->I2s3ClockSelection);
;;;210      }
;;;211    
;;;212      /*------------------------------ PLL I2S Configuration ----------------------*/
;;;213      /* Check that PLLI2S need to be enabled */
;;;214      if (HAL_IS_BIT_SET(RCC->CFGR2, RCC_CFGR2_I2S2SRC) || HAL_IS_BIT_SET(RCC->CFGR2, RCC_CFGR2_I2S3SRC))
;;;215      {
;;;216        /* Update flag to indicate that PLL I2S should be active */
;;;217        pllactive = 1;
;;;218      }
;;;219    
;;;220      /* Check if PLL I2S need to be enabled */
;;;221      if (pllactive == 1)
;;;222      {
;;;223        /* Enable PLL I2S only if not active */
;;;224        if (HAL_IS_BIT_CLR(RCC->CR, RCC_CR_PLL3ON))
;;;225        {
;;;226          /* Check the parameters */
;;;227          assert_param(IS_RCC_PLLI2S_MUL(PeriphClkInit->PLLI2S.PLLI2SMUL));
;;;228          assert_param(IS_RCC_HSE_PREDIV2(PeriphClkInit->PLLI2S.HSEPrediv2Value));
;;;229    
;;;230          /* Prediv2 can be written only when the PLL2 is disabled. */
;;;231          /* Return an error only if new value is different from the programmed value */
;;;232          if (HAL_IS_BIT_SET(RCC->CR, RCC_CR_PLL2ON) && \
;;;233              (__HAL_RCC_HSE_GET_PREDIV2() != PeriphClkInit->PLLI2S.HSEPrediv2Value))
;;;234          {
;;;235            return HAL_ERROR;
;;;236          }
;;;237    
;;;238          /* Configure the HSE prediv2 factor --------------------------------*/
;;;239          __HAL_RCC_HSE_PREDIV2_CONFIG(PeriphClkInit->PLLI2S.HSEPrediv2Value);
;;;240    
;;;241          /* Configure the main PLLI2S multiplication factors. */
;;;242          __HAL_RCC_PLLI2S_CONFIG(PeriphClkInit->PLLI2S.PLLI2SMUL);
;;;243    
;;;244          /* Enable the main PLLI2S. */
;;;245          __HAL_RCC_PLLI2S_ENABLE();
;;;246    
;;;247          /* Get Start Tick*/
;;;248          tickstart = HAL_GetTick();
;;;249    
;;;250          /* Wait till PLLI2S is ready */
;;;251          while (__HAL_RCC_GET_FLAG(RCC_FLAG_PLLI2SRDY)  == RESET)
;;;252          {
;;;253            if ((HAL_GetTick() - tickstart) > PLLI2S_TIMEOUT_VALUE)
;;;254            {
;;;255              return HAL_TIMEOUT;
;;;256            }
;;;257          }
;;;258        }
;;;259        else
;;;260        {
;;;261          /* Return an error only if user wants to change the PLLI2SMUL whereas PLLI2S is active */
;;;262          if (READ_BIT(RCC->CFGR2, RCC_CFGR2_PLL3MUL) != PeriphClkInit->PLLI2S.PLLI2SMUL)
;;;263          {
;;;264            return HAL_ERROR;
;;;265          }
;;;266        }
;;;267      }
;;;268    #endif /* STM32F105xC || STM32F107xC */
;;;269    
;;;270    #if defined(STM32F102x6) || defined(STM32F102xB) || defined(STM32F103x6)\
;;;271     || defined(STM32F103xB) || defined(STM32F103xE) || defined(STM32F103xG)\
;;;272     || defined(STM32F105xC) || defined(STM32F107xC)
;;;273      /*------------------------------ USB clock Configuration ------------------*/
;;;274      if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_USB) == RCC_PERIPHCLK_USB)
;;;275      {
;;;276        /* Check the parameters */
;;;277        assert_param(IS_RCC_USBPLLCLK_DIV(PeriphClkInit->UsbClockSelection));
;;;278    
;;;279        /* Configure the USB clock source */
;;;280        __HAL_RCC_USB_CONFIG(PeriphClkInit->UsbClockSelection);
;;;281      }
;;;282    #endif /* STM32F102x6 || STM32F102xB || STM32F103x6 || STM32F103xB || STM32F103xE || STM32F103xG || STM32F105xC || STM32F107xC */
;;;283    
;;;284      return HAL_OK;
;;;285    }
0000b2  bdf8              POP      {r3-r7,pc}
                  |L3.180|
0000b4  484e              LDR      r0,|L3.496|
0000b6  6800              LDR      r0,[r0,#0]            ;135
0000b8  f4007080          AND      r0,r0,#0x100          ;135
0000bc  2800              CMP      r0,#0                 ;135
0000be  d0f2              BEQ      |L3.166|
                  |L3.192|
0000c0  484a              LDR      r0,|L3.492|
0000c2  6a00              LDR      r0,[r0,#0x20]         ;145
0000c4  f4007540          AND      r5,r0,#0x300          ;145
0000c8  b32d              CBZ      r5,|L3.278|
0000ca  88a0              LDRH     r0,[r4,#4]            ;146
0000cc  f4007040          AND      r0,r0,#0x300          ;146
0000d0  42a8              CMP      r0,r5                 ;146
0000d2  d020              BEQ      |L3.278|
0000d4  4845              LDR      r0,|L3.492|
0000d6  6a00              LDR      r0,[r0,#0x20]         ;149
0000d8  f4207540          BIC      r5,r0,#0x300          ;149
0000dc  2001              MOVS     r0,#1                 ;151
0000de  4945              LDR      r1,|L3.500|
0000e0  6008              STR      r0,[r1,#0]            ;151
0000e2  2000              MOVS     r0,#0                 ;152
0000e4  6008              STR      r0,[r1,#0]            ;152
0000e6  4841              LDR      r0,|L3.492|
0000e8  6205              STR      r5,[r0,#0x20]         ;154
0000ea  f0050001          AND      r0,r5,#1              ;157
0000ee  b190              CBZ      r0,|L3.278|
0000f0  f7fffffe          BL       HAL_GetTick
0000f4  4606              MOV      r6,r0                 ;160
0000f6  e008              B        |L3.266|
                  |L3.248|
0000f8  f7fffffe          BL       HAL_GetTick
0000fc  1b80              SUBS     r0,r0,r6              ;165
0000fe  f2413188          MOV      r1,#0x1388            ;165
000102  4288              CMP      r0,r1                 ;165
000104  d901              BLS      |L3.266|
000106  2003              MOVS     r0,#3                 ;167
000108  e7d3              B        |L3.178|
                  |L3.266|
00010a  4838              LDR      r0,|L3.492|
00010c  6a00              LDR      r0,[r0,#0x20]         ;163
00010e  f0000002          AND      r0,r0,#2              ;163
000112  2800              CMP      r0,#0                 ;163
000114  d0f0              BEQ      |L3.248|
                  |L3.278|
000116  4835              LDR      r0,|L3.492|
000118  6a00              LDR      r0,[r0,#0x20]         ;172
00011a  f4207040          BIC      r0,r0,#0x300          ;172
00011e  6861              LDR      r1,[r4,#4]            ;172
000120  4308              ORRS     r0,r0,r1              ;172
000122  4932              LDR      r1,|L3.492|
000124  6208              STR      r0,[r1,#0x20]         ;172
000126  2f01              CMP      r7,#1                 ;175
000128  d106              BNE      |L3.312|
00012a  4608              MOV      r0,r1                 ;177
00012c  69c0              LDR      r0,[r0,#0x1c]         ;177
00012e  f0205080          BIC      r0,r0,#0x10000000     ;177
000132  e000              B        |L3.310|
                  |L3.308|
000134  e001              B        |L3.314|
                  |L3.310|
000136  61c8              STR      r0,[r1,#0x1c]         ;177
                  |L3.312|
000138  bf00              NOP                            ;179
                  |L3.314|
00013a  7820              LDRB     r0,[r4,#0]            ;182
00013c  f0000002          AND      r0,r0,#2              ;182
000140  2802              CMP      r0,#2                 ;182
000142  d11a              BNE      |L3.378|
000144  68a0              LDR      r0,[r4,#8]            ;185
000146  b158              CBZ      r0,|L3.352|
000148  68a0              LDR      r0,[r4,#8]            ;185
00014a  f5b04f80          CMP      r0,#0x4000            ;185
00014e  d007              BEQ      |L3.352|
000150  68a0              LDR      r0,[r4,#8]            ;185
000152  f5b04f00          CMP      r0,#0x8000            ;185
000156  d003              BEQ      |L3.352|
000158  68a0              LDR      r0,[r4,#8]            ;185
00015a  f5b04f40          CMP      r0,#0xc000            ;185
00015e  d100              BNE      |L3.354|
                  |L3.352|
000160  e003              B        |L3.362|
                  |L3.354|
000162  21b9              MOVS     r1,#0xb9              ;185
000164  a012              ADR      r0,|L3.432|
000166  f7fffffe          BL       assert_failed
                  |L3.362|
00016a  4820              LDR      r0,|L3.492|
00016c  6840              LDR      r0,[r0,#4]            ;188
00016e  f4204040          BIC      r0,r0,#0xc000         ;188
000172  68a1              LDR      r1,[r4,#8]            ;188
000174  4308              ORRS     r0,r0,r1              ;188
000176  491d              LDR      r1,|L3.492|
000178  6048              STR      r0,[r1,#4]            ;188
                  |L3.378|
00017a  7820              LDRB     r0,[r4,#0]            ;274
00017c  f0000010          AND      r0,r0,#0x10           ;274
000180  2810              CMP      r0,#0x10              ;274
000182  d113              BNE      |L3.428|
000184  68e0              LDR      r0,[r4,#0xc]          ;277
000186  f5b00f80          CMP      r0,#0x400000          ;277
00018a  d001              BEQ      |L3.400|
00018c  68e0              LDR      r0,[r4,#0xc]          ;277
00018e  b900              CBNZ     r0,|L3.402|
                  |L3.400|
000190  e004              B        |L3.412|
                  |L3.402|
000192  f2401115          MOV      r1,#0x115             ;277
000196  a006              ADR      r0,|L3.432|
000198  f7fffffe          BL       assert_failed
                  |L3.412|
00019c  4813              LDR      r0,|L3.492|
00019e  6840              LDR      r0,[r0,#4]            ;280
0001a0  f4200080          BIC      r0,r0,#0x400000       ;280
0001a4  68e1              LDR      r1,[r4,#0xc]          ;280
0001a6  4308              ORRS     r0,r0,r1              ;280
0001a8  4910              LDR      r1,|L3.492|
0001aa  6048              STR      r0,[r1,#4]            ;280
                  |L3.428|
0001ac  2000              MOVS     r0,#0                 ;284
0001ae  e780              B        |L3.178|
;;;286    
                          ENDP

                  |L3.432|
0001b0  2e2e2f44          DCB      "../Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_rcc_e"
0001b4  72697665
0001b8  72732f53
0001bc  544d3332
0001c0  46317878
0001c4  5f48414c
0001c8  5f447269
0001cc  7665722f
0001d0  5372632f
0001d4  73746d33
0001d8  32663178
0001dc  785f6861
0001e0  6c5f7263
0001e4  635f65  
0001e7  782e6300          DCB      "x.c",0
0001eb  00                DCB      0
                  |L3.492|
                          DCD      0x40021000
                  |L3.496|
                          DCD      0x40007000
                  |L3.500|
                          DCD      0x42420440

;*** Start embedded assembler ***

#line 1 "../Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_rcc_ex.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___22_stm32f1xx_hal_rcc_ex_c_bed13b44____REV16|
#line 463 "../Drivers/CMSIS/Include/cmsis_armcc.h"
|__asm___22_stm32f1xx_hal_rcc_ex_c_bed13b44____REV16| PROC
#line 464

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___22_stm32f1xx_hal_rcc_ex_c_bed13b44____REVSH|
#line 478
|__asm___22_stm32f1xx_hal_rcc_ex_c_bed13b44____REVSH| PROC
#line 479

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___22_stm32f1xx_hal_rcc_ex_c_bed13b44____RRX|
#line 665
|__asm___22_stm32f1xx_hal_rcc_ex_c_bed13b44____RRX| PROC
#line 666

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
