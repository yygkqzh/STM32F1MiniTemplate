; generated by Component: ARM Compiler 5.06 update 7 (build 960) Tool: ArmCC [4d365d]
; commandline ArmCC [--c99 --split_sections --debug -c --asm --interleave -otemplate\stm32f1xx_hal_pwr.o --asm_dir=./ --list_dir=--list --depend=template\stm32f1xx_hal_pwr.d --cpu=Cortex-M3 --apcs=interwork -O0 --diag_suppress=9931 -I../Inc -I../Drivers/STM32F1xx_HAL_Driver/Inc -I../Drivers/STM32F1xx_HAL_Driver/Inc/Legacy -I../Middlewares/Third_Party/FatFs/src -I../Drivers/CMSIS/Device/ST/STM32F1xx/Include -I../Drivers/CMSIS/Include -I.\RTE\_Template -ID:\Keil_v5\Pack\ARM\CMSIS\5.7.0\CMSIS\Core\Include -ID:\Keil_v5\Pack\Keil\STM32F1xx_DFP\2.3.0\Device\Include -D__MICROLIB -D__UVISION_VERSION=533 -D_RTE_ -DSTM32F10X_MD -D_RTE_ -DUSE_FULL_LL_DRIVER -DUSE_HAL_DRIVER -DSTM32F103xB --signed_chars --omf_browse=template\stm32f1xx_hal_pwr.crf ../Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c]
                          THUMB

                          AREA ||i.HAL_PWR_ConfigPVD||, CODE, READONLY, ALIGN=2

                  HAL_PWR_ConfigPVD PROC
;;;315      */
;;;316    void HAL_PWR_ConfigPVD(PWR_PVDTypeDef *sConfigPVD)
000000  b510              PUSH     {r4,lr}
;;;317    {
000002  4604              MOV      r4,r0
;;;318      /* Check the parameters */
;;;319      assert_param(IS_PWR_PVD_LEVEL(sConfigPVD->PVDLevel));
000004  6820              LDR      r0,[r4,#0]
000006  b1a0              CBZ      r0,|L1.50|
000008  6820              LDR      r0,[r4,#0]
00000a  2820              CMP      r0,#0x20
00000c  d011              BEQ      |L1.50|
00000e  6820              LDR      r0,[r4,#0]
000010  2840              CMP      r0,#0x40
000012  d00e              BEQ      |L1.50|
000014  6820              LDR      r0,[r4,#0]
000016  2860              CMP      r0,#0x60
000018  d00b              BEQ      |L1.50|
00001a  6820              LDR      r0,[r4,#0]
00001c  2880              CMP      r0,#0x80
00001e  d008              BEQ      |L1.50|
000020  6820              LDR      r0,[r4,#0]
000022  28a0              CMP      r0,#0xa0
000024  d005              BEQ      |L1.50|
000026  6820              LDR      r0,[r4,#0]
000028  28c0              CMP      r0,#0xc0
00002a  d002              BEQ      |L1.50|
00002c  6820              LDR      r0,[r4,#0]
00002e  28e0              CMP      r0,#0xe0
000030  d100              BNE      |L1.52|
                  |L1.50|
000032  e004              B        |L1.62|
                  |L1.52|
000034  f240113f          MOV      r1,#0x13f
000038  a03c              ADR      r0,|L1.300|
00003a  f7fffffe          BL       assert_failed
                  |L1.62|
;;;320      assert_param(IS_PWR_PVD_MODE(sConfigPVD->Mode));
00003e  6860              LDR      r0,[r4,#4]
000040  f1b01f01          CMP      r0,#0x10001
000044  d015              BEQ      |L1.114|
000046  4947              LDR      r1,|L1.356|
000048  6860              LDR      r0,[r4,#4]
00004a  4288              CMP      r0,r1
00004c  d011              BEQ      |L1.114|
00004e  1c49              ADDS     r1,r1,#1
000050  6860              LDR      r0,[r4,#4]
000052  4288              CMP      r0,r1
000054  d00d              BEQ      |L1.114|
000056  4944              LDR      r1,|L1.360|
000058  6860              LDR      r0,[r4,#4]
00005a  4288              CMP      r0,r1
00005c  d009              BEQ      |L1.114|
00005e  6860              LDR      r0,[r4,#4]
000060  f1b01f02          CMP      r0,#0x20002
000064  d005              BEQ      |L1.114|
000066  1c89              ADDS     r1,r1,#2
000068  6860              LDR      r0,[r4,#4]
00006a  4288              CMP      r0,r1
00006c  d001              BEQ      |L1.114|
00006e  6860              LDR      r0,[r4,#4]
000070  b900              CBNZ     r0,|L1.116|
                  |L1.114|
000072  e004              B        |L1.126|
                  |L1.116|
000074  f44f71a0          MOV      r1,#0x140
000078  a02c              ADR      r0,|L1.300|
00007a  f7fffffe          BL       assert_failed
                  |L1.126|
;;;321    
;;;322      /* Set PLS[7:5] bits according to PVDLevel value */
;;;323      MODIFY_REG(PWR->CR, PWR_CR_PLS, sConfigPVD->PVDLevel);
00007e  483b              LDR      r0,|L1.364|
000080  6800              LDR      r0,[r0,#0]
000082  f02000e0          BIC      r0,r0,#0xe0
000086  6821              LDR      r1,[r4,#0]
000088  4308              ORRS     r0,r0,r1
00008a  4938              LDR      r1,|L1.364|
00008c  6008              STR      r0,[r1,#0]
;;;324      
;;;325      /* Clear any previous config. Keep it clear if no event or IT mode is selected */
;;;326      __HAL_PWR_PVD_EXTI_DISABLE_EVENT();
00008e  4838              LDR      r0,|L1.368|
000090  6800              LDR      r0,[r0,#0]
000092  f4203080          BIC      r0,r0,#0x10000
000096  4936              LDR      r1,|L1.368|
000098  6008              STR      r0,[r1,#0]
;;;327      __HAL_PWR_PVD_EXTI_DISABLE_IT();
00009a  1f08              SUBS     r0,r1,#4
00009c  6800              LDR      r0,[r0,#0]
00009e  f4203080          BIC      r0,r0,#0x10000
0000a2  1f09              SUBS     r1,r1,#4
0000a4  6008              STR      r0,[r1,#0]
;;;328      __HAL_PWR_PVD_EXTI_DISABLE_FALLING_EDGE(); 
0000a6  4832              LDR      r0,|L1.368|
0000a8  3008              ADDS     r0,r0,#8
0000aa  6800              LDR      r0,[r0,#0]
0000ac  f4203080          BIC      r0,r0,#0x10000
0000b0  492f              LDR      r1,|L1.368|
0000b2  3108              ADDS     r1,r1,#8
0000b4  6008              STR      r0,[r1,#0]
;;;329      __HAL_PWR_PVD_EXTI_DISABLE_RISING_EDGE();
0000b6  1f08              SUBS     r0,r1,#4
0000b8  6800              LDR      r0,[r0,#0]
0000ba  f4203080          BIC      r0,r0,#0x10000
0000be  1f09              SUBS     r1,r1,#4
0000c0  6008              STR      r0,[r1,#0]
;;;330    
;;;331      /* Configure interrupt mode */
;;;332      if((sConfigPVD->Mode & PVD_MODE_IT) == PVD_MODE_IT)
0000c2  6860              LDR      r0,[r4,#4]
0000c4  f4003080          AND      r0,r0,#0x10000
0000c8  f5b03f80          CMP      r0,#0x10000
0000cc  d107              BNE      |L1.222|
;;;333      {
;;;334        __HAL_PWR_PVD_EXTI_ENABLE_IT();
0000ce  4828              LDR      r0,|L1.368|
0000d0  1f00              SUBS     r0,r0,#4
0000d2  6800              LDR      r0,[r0,#0]
0000d4  f4403080          ORR      r0,r0,#0x10000
0000d8  4925              LDR      r1,|L1.368|
0000da  1f09              SUBS     r1,r1,#4
0000dc  6008              STR      r0,[r1,#0]
                  |L1.222|
;;;335      }
;;;336      
;;;337      /* Configure event mode */
;;;338      if((sConfigPVD->Mode & PVD_MODE_EVT) == PVD_MODE_EVT)
0000de  6860              LDR      r0,[r4,#4]
0000e0  f4003000          AND      r0,r0,#0x20000
0000e4  f5b03f00          CMP      r0,#0x20000
0000e8  d105              BNE      |L1.246|
;;;339      {
;;;340        __HAL_PWR_PVD_EXTI_ENABLE_EVENT();
0000ea  4821              LDR      r0,|L1.368|
0000ec  6800              LDR      r0,[r0,#0]
0000ee  f4403080          ORR      r0,r0,#0x10000
0000f2  491f              LDR      r1,|L1.368|
0000f4  6008              STR      r0,[r1,#0]
                  |L1.246|
;;;341      }
;;;342      
;;;343      /* Configure the edge */
;;;344      if((sConfigPVD->Mode & PVD_RISING_EDGE) == PVD_RISING_EDGE)
0000f6  7920              LDRB     r0,[r4,#4]
0000f8  f0000001          AND      r0,r0,#1
0000fc  b138              CBZ      r0,|L1.270|
;;;345      {
;;;346        __HAL_PWR_PVD_EXTI_ENABLE_RISING_EDGE();
0000fe  481c              LDR      r0,|L1.368|
000100  1d00              ADDS     r0,r0,#4
000102  6800              LDR      r0,[r0,#0]
000104  f4403080          ORR      r0,r0,#0x10000
000108  4919              LDR      r1,|L1.368|
00010a  1d09              ADDS     r1,r1,#4
00010c  6008              STR      r0,[r1,#0]
                  |L1.270|
;;;347      }
;;;348      
;;;349      if((sConfigPVD->Mode & PVD_FALLING_EDGE) == PVD_FALLING_EDGE)
00010e  7920              LDRB     r0,[r4,#4]
000110  f0000002          AND      r0,r0,#2
000114  2802              CMP      r0,#2
000116  d107              BNE      |L1.296|
;;;350      {
;;;351        __HAL_PWR_PVD_EXTI_ENABLE_FALLING_EDGE();
000118  4815              LDR      r0,|L1.368|
00011a  3008              ADDS     r0,r0,#8
00011c  6800              LDR      r0,[r0,#0]
00011e  f4403080          ORR      r0,r0,#0x10000
000122  4913              LDR      r1,|L1.368|
000124  3108              ADDS     r1,r1,#8
000126  6008              STR      r0,[r1,#0]
                  |L1.296|
;;;352      }
;;;353    }
000128  bd10              POP      {r4,pc}
;;;354    
                          ENDP

00012a  0000              DCW      0x0000
                  |L1.300|
00012c  2e2e2f44          DCB      "../Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c"
000130  72697665
000134  72732f53
000138  544d3332
00013c  46317878
000140  5f48414c
000144  5f447269
000148  7665722f
00014c  5372632f
000150  73746d33
000154  32663178
000158  785f6861
00015c  6c5f7077
000160  722e63  
000163  00                DCB      0
                  |L1.356|
                          DCD      0x00010002
                  |L1.360|
                          DCD      0x00020001
                  |L1.364|
                          DCD      0x40007000
                  |L1.368|
                          DCD      0x40010404

                          AREA ||i.HAL_PWR_DeInit||, CODE, READONLY, ALIGN=2

                  HAL_PWR_DeInit PROC
;;;155      */
;;;156    void HAL_PWR_DeInit(void)
000000  4805              LDR      r0,|L2.24|
;;;157    {
;;;158      __HAL_RCC_PWR_FORCE_RESET();
000002  6900              LDR      r0,[r0,#0x10]
000004  f0405080          ORR      r0,r0,#0x10000000
000008  4903              LDR      r1,|L2.24|
00000a  6108              STR      r0,[r1,#0x10]
;;;159      __HAL_RCC_PWR_RELEASE_RESET();
00000c  4608              MOV      r0,r1
00000e  6900              LDR      r0,[r0,#0x10]
000010  f0205080          BIC      r0,r0,#0x10000000
000014  6108              STR      r0,[r1,#0x10]
;;;160    }
000016  4770              BX       lr
;;;161    
                          ENDP

                  |L2.24|
                          DCD      0x40021000

                          AREA ||i.HAL_PWR_DisableBkUpAccess||, CODE, READONLY, ALIGN=2

                  HAL_PWR_DisableBkUpAccess PROC
;;;181      */
;;;182    void HAL_PWR_DisableBkUpAccess(void)
000000  2000              MOVS     r0,#0
;;;183    {
;;;184      /* Disable access to RTC and backup registers */
;;;185      *(__IO uint32_t *) CR_DBP_BB = (uint32_t)DISABLE;
000002  4901              LDR      r1,|L3.8|
000004  6208              STR      r0,[r1,#0x20]
;;;186    }
000006  4770              BX       lr
;;;187    
                          ENDP

                  |L3.8|
                          DCD      0x420e0000

                          AREA ||i.HAL_PWR_DisablePVD||, CODE, READONLY, ALIGN=2

                  HAL_PWR_DisablePVD PROC
;;;368      */
;;;369    void HAL_PWR_DisablePVD(void)
000000  2000              MOVS     r0,#0
;;;370    {
;;;371      /* Disable the power voltage detector */
;;;372      *(__IO uint32_t *) CR_PVDE_BB = (uint32_t)DISABLE;
000002  4901              LDR      r1,|L4.8|
000004  6108              STR      r0,[r1,#0x10]
;;;373    }
000006  4770              BX       lr
;;;374    
                          ENDP

                  |L4.8|
                          DCD      0x420e0000

                          AREA ||i.HAL_PWR_DisableSEVOnPend||, CODE, READONLY, ALIGN=2

                  HAL_PWR_DisableSEVOnPend PROC
;;;566      */
;;;567    void HAL_PWR_DisableSEVOnPend(void)
000000  4803              LDR      r0,|L5.16|
;;;568    {
;;;569      /* Clear SEVONPEND bit of Cortex System Control Register */
;;;570      CLEAR_BIT(SCB->SCR, ((uint32_t)SCB_SCR_SEVONPEND_Msk));
000002  6800              LDR      r0,[r0,#0]
000004  f0200010          BIC      r0,r0,#0x10
000008  4901              LDR      r1,|L5.16|
00000a  6008              STR      r0,[r1,#0]
;;;571    }
00000c  4770              BX       lr
;;;572    
                          ENDP

00000e  0000              DCW      0x0000
                  |L5.16|
                          DCD      0xe000ed10

                          AREA ||i.HAL_PWR_DisableSleepOnExit||, CODE, READONLY, ALIGN=2

                  HAL_PWR_DisableSleepOnExit PROC
;;;540      */
;;;541    void HAL_PWR_DisableSleepOnExit(void)
000000  4803              LDR      r0,|L6.16|
;;;542    {
;;;543      /* Clear SLEEPONEXIT bit of Cortex System Control Register */
;;;544      CLEAR_BIT(SCB->SCR, ((uint32_t)SCB_SCR_SLEEPONEXIT_Msk));
000002  6800              LDR      r0,[r0,#0]
000004  f0200002          BIC      r0,r0,#2
000008  4901              LDR      r1,|L6.16|
00000a  6008              STR      r0,[r1,#0]
;;;545    }
00000c  4770              BX       lr
;;;546    
                          ENDP

00000e  0000              DCW      0x0000
                  |L6.16|
                          DCD      0xe000ed10

                          AREA ||i.HAL_PWR_DisableWakeUpPin||, CODE, READONLY, ALIGN=2

                  HAL_PWR_DisableWakeUpPin PROC
;;;396      */
;;;397    void HAL_PWR_DisableWakeUpPin(uint32_t WakeUpPinx)
000000  b510              PUSH     {r4,lr}
;;;398    {
000002  4604              MOV      r4,r0
;;;399      /* Check the parameter */
;;;400      assert_param(IS_PWR_WAKEUP_PIN(WakeUpPinx));
000004  f5b47f80          CMP      r4,#0x100
000008  d100              BNE      |L7.12|
00000a  e004              B        |L7.22|
                  |L7.12|
00000c  f44f71c8          MOV      r1,#0x190
000010  a006              ADR      r0,|L7.44|
000012  f7fffffe          BL       assert_failed
                  |L7.22|
;;;401      /* Disable the EWUPx pin */
;;;402      *(__IO uint32_t *) CSR_EWUP_BB(WakeUpPinx) = (uint32_t)DISABLE;
000016  2000              MOVS     r0,#0
000018  fa94f1a4          RBIT     r1,r4
00001c  fab1f181          CLZ      r1,r1
000020  4a10              LDR      r2,|L7.100|
000022  eb020181          ADD      r1,r2,r1,LSL #2
000026  f8c10080          STR      r0,[r1,#0x80]
;;;403    }
00002a  bd10              POP      {r4,pc}
;;;404    
                          ENDP

                  |L7.44|
00002c  2e2e2f44          DCB      "../Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c"
000030  72697665
000034  72732f53
000038  544d3332
00003c  46317878
000040  5f48414c
000044  5f447269
000048  7665722f
00004c  5372632f
000050  73746d33
000054  32663178
000058  785f6861
00005c  6c5f7077
000060  722e63  
000063  00                DCB      0
                  |L7.100|
                          DCD      0x420e0000

                          AREA ||i.HAL_PWR_EnableBkUpAccess||, CODE, READONLY, ALIGN=2

                  HAL_PWR_EnableBkUpAccess PROC
;;;168      */
;;;169    void HAL_PWR_EnableBkUpAccess(void)
000000  2001              MOVS     r0,#1
;;;170    {
;;;171      /* Enable access to RTC and backup registers */
;;;172      *(__IO uint32_t *) CR_DBP_BB = (uint32_t)ENABLE;
000002  4901              LDR      r1,|L8.8|
000004  6208              STR      r0,[r1,#0x20]
;;;173    }
000006  4770              BX       lr
;;;174    
                          ENDP

                  |L8.8|
                          DCD      0x420e0000

                          AREA ||i.HAL_PWR_EnablePVD||, CODE, READONLY, ALIGN=2

                  HAL_PWR_EnablePVD PROC
;;;358      */
;;;359    void HAL_PWR_EnablePVD(void)
000000  2001              MOVS     r0,#1
;;;360    {
;;;361      /* Enable the power voltage detector */
;;;362      *(__IO uint32_t *) CR_PVDE_BB = (uint32_t)ENABLE;
000002  4901              LDR      r1,|L9.8|
000004  6108              STR      r0,[r1,#0x10]
;;;363    }
000006  4770              BX       lr
;;;364    
                          ENDP

                  |L9.8|
                          DCD      0x420e0000

                          AREA ||i.HAL_PWR_EnableSEVOnPend||, CODE, READONLY, ALIGN=2

                  HAL_PWR_EnableSEVOnPend PROC
;;;553      */
;;;554    void HAL_PWR_EnableSEVOnPend(void)
000000  4803              LDR      r0,|L10.16|
;;;555    {
;;;556      /* Set SEVONPEND bit of Cortex System Control Register */
;;;557      SET_BIT(SCB->SCR, ((uint32_t)SCB_SCR_SEVONPEND_Msk));
000002  6800              LDR      r0,[r0,#0]
000004  f0400010          ORR      r0,r0,#0x10
000008  4901              LDR      r1,|L10.16|
00000a  6008              STR      r0,[r1,#0]
;;;558    }
00000c  4770              BX       lr
;;;559    
                          ENDP

00000e  0000              DCW      0x0000
                  |L10.16|
                          DCD      0xe000ed10

                          AREA ||i.HAL_PWR_EnableSleepOnExit||, CODE, READONLY, ALIGN=2

                  HAL_PWR_EnableSleepOnExit PROC
;;;527      */
;;;528    void HAL_PWR_EnableSleepOnExit(void)
000000  4803              LDR      r0,|L11.16|
;;;529    {
;;;530      /* Set SLEEPONEXIT bit of Cortex System Control Register */
;;;531      SET_BIT(SCB->SCR, ((uint32_t)SCB_SCR_SLEEPONEXIT_Msk));
000002  6800              LDR      r0,[r0,#0]
000004  f0400002          ORR      r0,r0,#2
000008  4901              LDR      r1,|L11.16|
00000a  6008              STR      r0,[r1,#0]
;;;532    }
00000c  4770              BX       lr
;;;533    
                          ENDP

00000e  0000              DCW      0x0000
                  |L11.16|
                          DCD      0xe000ed10

                          AREA ||i.HAL_PWR_EnableWakeUpPin||, CODE, READONLY, ALIGN=2

                  HAL_PWR_EnableWakeUpPin PROC
;;;381      */
;;;382    void HAL_PWR_EnableWakeUpPin(uint32_t WakeUpPinx)
000000  b510              PUSH     {r4,lr}
;;;383    {
000002  4604              MOV      r4,r0
;;;384      /* Check the parameter */
;;;385      assert_param(IS_PWR_WAKEUP_PIN(WakeUpPinx));
000004  f5b47f80          CMP      r4,#0x100
000008  d100              BNE      |L12.12|
00000a  e004              B        |L12.22|
                  |L12.12|
00000c  f2401181          MOV      r1,#0x181
000010  a006              ADR      r0,|L12.44|
000012  f7fffffe          BL       assert_failed
                  |L12.22|
;;;386      /* Enable the EWUPx pin */
;;;387      *(__IO uint32_t *) CSR_EWUP_BB(WakeUpPinx) = (uint32_t)ENABLE;
000016  2001              MOVS     r0,#1
000018  fa94f1a4          RBIT     r1,r4
00001c  fab1f181          CLZ      r1,r1
000020  4a10              LDR      r2,|L12.100|
000022  eb020181          ADD      r1,r2,r1,LSL #2
000026  f8c10080          STR      r0,[r1,#0x80]
;;;388    }
00002a  bd10              POP      {r4,pc}
;;;389    
                          ENDP

                  |L12.44|
00002c  2e2e2f44          DCB      "../Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c"
000030  72697665
000034  72732f53
000038  544d3332
00003c  46317878
000040  5f48414c
000044  5f447269
000048  7665722f
00004c  5372632f
000050  73746d33
000054  32663178
000058  785f6861
00005c  6c5f7077
000060  722e63  
000063  00                DCB      0
                  |L12.100|
                          DCD      0x420e0000

                          AREA ||i.HAL_PWR_EnterSLEEPMode||, CODE, READONLY, ALIGN=2

                  HAL_PWR_EnterSLEEPMode PROC
;;;416      */
;;;417    void HAL_PWR_EnterSLEEPMode(uint32_t Regulator, uint8_t SLEEPEntry)
000000  b570              PUSH     {r4-r6,lr}
;;;418    {
000002  4605              MOV      r5,r0
000004  460c              MOV      r4,r1
;;;419      /* Check the parameters */
;;;420      /* No check on Regulator because parameter not used in SLEEP mode */
;;;421      /* Prevent unused argument(s) compilation warning */
;;;422      UNUSED(Regulator);
;;;423    
;;;424      assert_param(IS_PWR_SLEEP_ENTRY(SLEEPEntry));
000006  2c01              CMP      r4,#1
000008  d001              BEQ      |L13.14|
00000a  2c02              CMP      r4,#2
00000c  d100              BNE      |L13.16|
                  |L13.14|
00000e  e004              B        |L13.26|
                  |L13.16|
000010  f44f71d4          MOV      r1,#0x1a8
000014  a008              ADR      r0,|L13.56|
000016  f7fffffe          BL       assert_failed
                  |L13.26|
;;;425    
;;;426      /* Clear SLEEPDEEP bit of Cortex System Control Register */
;;;427      CLEAR_BIT(SCB->SCR, ((uint32_t)SCB_SCR_SLEEPDEEP_Msk));
00001a  4815              LDR      r0,|L13.112|
00001c  6800              LDR      r0,[r0,#0]
00001e  f0200004          BIC      r0,r0,#4
000022  4913              LDR      r1,|L13.112|
000024  6008              STR      r0,[r1,#0]
;;;428    
;;;429      /* Select SLEEP mode entry -------------------------------------------------*/
;;;430      if(SLEEPEntry == PWR_SLEEPENTRY_WFI)
000026  2c01              CMP      r4,#1
000028  d101              BNE      |L13.46|
;;;431      {
;;;432        /* Request Wait For Interrupt */
;;;433        __WFI();
00002a  bf30              WFI      
00002c  e002              B        |L13.52|
                  |L13.46|
;;;434      }
;;;435      else
;;;436      {
;;;437        /* Request Wait For Event */
;;;438        __SEV();
00002e  bf40              SEV      
;;;439        __WFE();
000030  bf20              WFE      
;;;440        __WFE();
000032  bf20              WFE      
                  |L13.52|
;;;441      }
;;;442    }
000034  bd70              POP      {r4-r6,pc}
;;;443    
                          ENDP

000036  0000              DCW      0x0000
                  |L13.56|
000038  2e2e2f44          DCB      "../Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c"
00003c  72697665
000040  72732f53
000044  544d3332
000048  46317878
00004c  5f48414c
000050  5f447269
000054  7665722f
000058  5372632f
00005c  73746d33
000060  32663178
000064  785f6861
000068  6c5f7077
00006c  722e63  
00006f  00                DCB      0
                  |L13.112|
                          DCD      0xe000ed10

                          AREA ||i.HAL_PWR_EnterSTANDBYMode||, CODE, READONLY, ALIGN=2

                  HAL_PWR_EnterSTANDBYMode PROC
;;;502      */
;;;503    void HAL_PWR_EnterSTANDBYMode(void)
000000  4807              LDR      r0,|L14.32|
;;;504    {
;;;505      /* Select Standby mode */
;;;506      SET_BIT(PWR->CR, PWR_CR_PDDS);
000002  6800              LDR      r0,[r0,#0]
000004  f0400002          ORR      r0,r0,#2
000008  4905              LDR      r1,|L14.32|
00000a  6008              STR      r0,[r1,#0]
;;;507    
;;;508      /* Set SLEEPDEEP bit of Cortex System Control Register */
;;;509      SET_BIT(SCB->SCR, ((uint32_t)SCB_SCR_SLEEPDEEP_Msk));
00000c  4805              LDR      r0,|L14.36|
00000e  6800              LDR      r0,[r0,#0]
000010  f0400004          ORR      r0,r0,#4
000014  4903              LDR      r1,|L14.36|
000016  6008              STR      r0,[r1,#0]
;;;510    
;;;511      /* This option is used to ensure that store operations are completed */
;;;512    #if defined ( __CC_ARM)
;;;513      __force_stores();
000018  bf00              NOP      
00001a  bf00              NOP      
;;;514    #endif
;;;515      /* Request Wait For Interrupt */
;;;516      __WFI();
00001c  bf30              WFI      
;;;517    }
00001e  4770              BX       lr
;;;518    
                          ENDP

                  |L14.32|
                          DCD      0x40007000
                  |L14.36|
                          DCD      0xe000ed10

                          AREA ||i.HAL_PWR_EnterSTOPMode||, CODE, READONLY, ALIGN=2

                  HAL_PWR_EnterSTOPMode PROC
;;;462      */
;;;463    void HAL_PWR_EnterSTOPMode(uint32_t Regulator, uint8_t STOPEntry)
000000  b570              PUSH     {r4-r6,lr}
;;;464    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;465      /* Check the parameters */
;;;466      assert_param(IS_PWR_REGULATOR(Regulator));
000006  b10c              CBZ      r4,|L15.12|
000008  2c01              CMP      r4,#1
00000a  d100              BNE      |L15.14|
                  |L15.12|
00000c  e004              B        |L15.24|
                  |L15.14|
00000e  f44f71e9          MOV      r1,#0x1d2
000012  a017              ADR      r0,|L15.112|
000014  f7fffffe          BL       assert_failed
                  |L15.24|
;;;467      assert_param(IS_PWR_STOP_ENTRY(STOPEntry));
000018  2d01              CMP      r5,#1
00001a  d001              BEQ      |L15.32|
00001c  2d02              CMP      r5,#2
00001e  d100              BNE      |L15.34|
                  |L15.32|
000020  e004              B        |L15.44|
                  |L15.34|
000022  f24011d3          MOV      r1,#0x1d3
000026  a012              ADR      r0,|L15.112|
000028  f7fffffe          BL       assert_failed
                  |L15.44|
;;;468    
;;;469      /* Clear PDDS bit in PWR register to specify entering in STOP mode when CPU enter in Deepsleep */ 
;;;470      CLEAR_BIT(PWR->CR,  PWR_CR_PDDS);
00002c  481e              LDR      r0,|L15.168|
00002e  6800              LDR      r0,[r0,#0]
000030  f0200002          BIC      r0,r0,#2
000034  491c              LDR      r1,|L15.168|
000036  6008              STR      r0,[r1,#0]
;;;471    
;;;472      /* Select the voltage regulator mode by setting LPDS bit in PWR register according to Regulator parameter value */
;;;473      MODIFY_REG(PWR->CR, PWR_CR_LPDS, Regulator);
000038  4608              MOV      r0,r1
00003a  6800              LDR      r0,[r0,#0]
00003c  f0200001          BIC      r0,r0,#1
000040  4320              ORRS     r0,r0,r4
000042  6008              STR      r0,[r1,#0]
;;;474    
;;;475      /* Set SLEEPDEEP bit of Cortex System Control Register */
;;;476      SET_BIT(SCB->SCR, ((uint32_t)SCB_SCR_SLEEPDEEP_Msk));
000044  4819              LDR      r0,|L15.172|
000046  6800              LDR      r0,[r0,#0]
000048  f0400004          ORR      r0,r0,#4
00004c  4917              LDR      r1,|L15.172|
00004e  6008              STR      r0,[r1,#0]
;;;477    
;;;478      /* Select Stop mode entry --------------------------------------------------*/
;;;479      if(STOPEntry == PWR_STOPENTRY_WFI)
000050  2d01              CMP      r5,#1
000052  d101              BNE      |L15.88|
;;;480      {
;;;481        /* Request Wait For Interrupt */
;;;482        __WFI();
000054  bf30              WFI      
000056  e004              B        |L15.98|
                  |L15.88|
;;;483      }
;;;484      else
;;;485      {
;;;486        /* Request Wait For Event */
;;;487        __SEV();
000058  bf40              SEV      
;;;488        PWR_OverloadWfe(); /* WFE redefine locally */
00005a  f7fffffe          BL       PWR_OverloadWfe
;;;489        PWR_OverloadWfe(); /* WFE redefine locally */
00005e  f7fffffe          BL       PWR_OverloadWfe
                  |L15.98|
;;;490      }
;;;491      /* Reset SLEEPDEEP bit of Cortex System Control Register */
;;;492      CLEAR_BIT(SCB->SCR, ((uint32_t)SCB_SCR_SLEEPDEEP_Msk));
000062  4812              LDR      r0,|L15.172|
000064  6800              LDR      r0,[r0,#0]
000066  f0200004          BIC      r0,r0,#4
00006a  4910              LDR      r1,|L15.172|
00006c  6008              STR      r0,[r1,#0]
;;;493    }
00006e  bd70              POP      {r4-r6,pc}
;;;494    
                          ENDP

                  |L15.112|
000070  2e2e2f44          DCB      "../Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c"
000074  72697665
000078  72732f53
00007c  544d3332
000080  46317878
000084  5f48414c
000088  5f447269
00008c  7665722f
000090  5372632f
000094  73746d33
000098  32663178
00009c  785f6861
0000a0  6c5f7077
0000a4  722e63  
0000a7  00                DCB      0
                  |L15.168|
                          DCD      0x40007000
                  |L15.172|
                          DCD      0xe000ed10

                          AREA ||i.HAL_PWR_PVDCallback||, CODE, READONLY, ALIGN=1

                  HAL_PWR_PVDCallback PROC
;;;596      */
;;;597    __weak void HAL_PWR_PVDCallback(void)
000000  4770              BX       lr
;;;598    {
;;;599      /* NOTE : This function Should not be modified, when the callback is needed,
;;;600                the HAL_PWR_PVDCallback could be implemented in the user file
;;;601       */ 
;;;602    }
;;;603    
                          ENDP


                          AREA ||i.HAL_PWR_PVD_IRQHandler||, CODE, READONLY, ALIGN=2

                  HAL_PWR_PVD_IRQHandler PROC
;;;579      */
;;;580    void HAL_PWR_PVD_IRQHandler(void)
000000  b510              PUSH     {r4,lr}
;;;581    {
;;;582      /* Check PWR exti flag */
;;;583      if(__HAL_PWR_PVD_EXTI_GET_FLAG() != RESET)
000002  4806              LDR      r0,|L17.28|
000004  6800              LDR      r0,[r0,#0]
000006  f4003080          AND      r0,r0,#0x10000
00000a  b128              CBZ      r0,|L17.24|
;;;584      {
;;;585        /* PWR PVD interrupt user callback */
;;;586        HAL_PWR_PVDCallback();
00000c  f7fffffe          BL       HAL_PWR_PVDCallback
;;;587    
;;;588        /* Clear PWR Exti pending bit */
;;;589        __HAL_PWR_PVD_EXTI_CLEAR_FLAG();
000010  f44f3080          MOV      r0,#0x10000
000014  4901              LDR      r1,|L17.28|
000016  6008              STR      r0,[r1,#0]
                  |L17.24|
;;;590      }
;;;591    }
000018  bd10              POP      {r4,pc}
;;;592    
                          ENDP

00001a  0000              DCW      0x0000
                  |L17.28|
                          DCD      0x40010414

                          AREA ||i.PWR_OverloadWfe||, CODE, READONLY, ALIGN=1

                  PWR_OverloadWfe PROC
                  ||__tagsym$$noinline||
;;;116    __NOINLINE
;;;117    static void PWR_OverloadWfe(void)
000000  bf20              WFE      
;;;118    {
;;;119      __asm volatile( "wfe" );
;;;120      __asm volatile( "nop" );
000002  bf00              NOP      
;;;121    }
000004  4770              BX       lr
;;;122    
                          ENDP


;*** Start embedded assembler ***

#line 1 "../Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___19_stm32f1xx_hal_pwr_c_f2cfe8be____REV16|
#line 463 "../Drivers/CMSIS/Include/cmsis_armcc.h"
|__asm___19_stm32f1xx_hal_pwr_c_f2cfe8be____REV16| PROC
#line 464

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___19_stm32f1xx_hal_pwr_c_f2cfe8be____REVSH|
#line 478
|__asm___19_stm32f1xx_hal_pwr_c_f2cfe8be____REVSH| PROC
#line 479

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___19_stm32f1xx_hal_pwr_c_f2cfe8be____RRX|
#line 665
|__asm___19_stm32f1xx_hal_pwr_c_f2cfe8be____RRX| PROC
#line 666

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
