; generated by Component: ARM Compiler 5.06 update 7 (build 960) Tool: ArmCC [4d365d]
; commandline ArmCC [--c99 --split_sections --debug -c --asm --interleave -otemplate\user_diskio.o --asm_dir=./ --list_dir=--list --depend=template\user_diskio.d --cpu=Cortex-M3 --apcs=interwork -O0 --diag_suppress=9931 -I../Inc -I../Drivers/STM32F1xx_HAL_Driver/Inc -I../Drivers/STM32F1xx_HAL_Driver/Inc/Legacy -I../Middlewares/Third_Party/FatFs/src -I../Drivers/CMSIS/Device/ST/STM32F1xx/Include -I../Drivers/CMSIS/Include -I.\RTE\_Template -ID:\Keil_v5\Pack\ARM\CMSIS\5.7.0\CMSIS\Core\Include -ID:\Keil_v5\Pack\Keil\STM32F1xx_DFP\2.3.0\Device\Include -D__MICROLIB -D__UVISION_VERSION=533 -D_RTE_ -DSTM32F10X_MD -D_RTE_ -DUSE_FULL_LL_DRIVER -DUSE_HAL_DRIVER -DSTM32F103xB --signed_chars --omf_browse=template\user_diskio.crf ../Src/user_diskio.c]
                          THUMB

                          AREA ||i.USER_initialize||, CODE, READONLY, ALIGN=2

                  USER_initialize PROC
;;;83       */
;;;84     DSTATUS USER_initialize (
000000  b510              PUSH     {r4,lr}
;;;85     	BYTE pdrv           /* Physical drive nmuber to identify the drive */
;;;86     )
;;;87     {
000002  4604              MOV      r4,r0
;;;88       /* USER CODE BEGIN INIT */
;;;89       Stat = STA_NOINIT;
000004  2001              MOVS     r0,#1
000006  4905              LDR      r1,|L1.28|
000008  7008              STRB     r0,[r1,#0]
;;;90     
;;;91       if (w25qxx_init())
00000a  f7fffffe          BL       w25qxx_init
00000e  b110              CBZ      r0,|L1.22|
;;;92       {
;;;93         Stat = RES_OK;
000010  2000              MOVS     r0,#0
000012  4902              LDR      r1,|L1.28|
000014  7008              STRB     r0,[r1,#0]
                  |L1.22|
;;;94       }
;;;95     
;;;96       return Stat;
000016  4801              LDR      r0,|L1.28|
000018  7800              LDRB     r0,[r0,#0]  ; Stat
;;;97       /* USER CODE END INIT */
;;;98     }
00001a  bd10              POP      {r4,pc}
;;;99     
                          ENDP

                  |L1.28|
                          DCD      Stat

                          AREA ||i.USER_ioctl||, CODE, READONLY, ALIGN=1

                  USER_ioctl PROC
;;;183    #if _USE_IOCTL == 1
;;;184    DRESULT USER_ioctl (
000000  b510              PUSH     {r4,lr}
;;;185    	BYTE pdrv,      /* Physical drive nmuber (0..) */
;;;186    	BYTE cmd,       /* Control code */
;;;187    	void *buff      /* Buffer to send/receive control data */
;;;188    )
;;;189    {
000002  4603              MOV      r3,r0
;;;190      /* USER CODE BEGIN IOCTL */
;;;191      DRESULT res = RES_ERROR;
000004  2001              MOVS     r0,#1
;;;192    
;;;193      switch (cmd)
000006  b131              CBZ      r1,|L2.22|
000008  2901              CMP      r1,#1
00000a  d00f              BEQ      |L2.44|
00000c  2902              CMP      r1,#2
00000e  d004              BEQ      |L2.26|
000010  2903              CMP      r1,#3
000012  d110              BNE      |L2.54|
000014  e006              B        |L2.36|
                  |L2.22|
;;;194      {
;;;195      case CTRL_SYNC:
;;;196        res = RES_OK;
000016  2000              MOVS     r0,#0
;;;197        break;
000018  e00f              B        |L2.58|
                  |L2.26|
;;;198      case GET_SECTOR_SIZE:
;;;199        *(WORD *)buff = FLASH_SECTOR_SIZE;
00001a  f44f7400          MOV      r4,#0x200
00001e  8014              STRH     r4,[r2,#0]
;;;200        res = RES_OK;
000020  2000              MOVS     r0,#0
;;;201        break;
000022  e00a              B        |L2.58|
                  |L2.36|
;;;202      case GET_BLOCK_SIZE:
;;;203        *(WORD *)buff = FLASH_BLOCK_SIZE;
000024  2408              MOVS     r4,#8
000026  8014              STRH     r4,[r2,#0]
;;;204        res = RES_OK;
000028  2000              MOVS     r0,#0
;;;205        break;
00002a  e006              B        |L2.58|
                  |L2.44|
;;;206      case GET_SECTOR_COUNT:
;;;207        *(DWORD *)buff = FLASH_SECTOR_COUNT;
00002c  f44f44c0          MOV      r4,#0x6000
000030  6014              STR      r4,[r2,#0]
;;;208        res = RES_OK;
000032  2000              MOVS     r0,#0
;;;209        break;
000034  e001              B        |L2.58|
                  |L2.54|
;;;210      default:
;;;211        res = RES_PARERR;
000036  2004              MOVS     r0,#4
;;;212        break;
000038  bf00              NOP      
                  |L2.58|
00003a  bf00              NOP                            ;197
;;;213      }
;;;214    
;;;215      return res;
;;;216      /* USER CODE END IOCTL */
;;;217    }
00003c  bd10              POP      {r4,pc}
;;;218    #endif /* _USE_IOCTL == 1 */
                          ENDP


                          AREA ||i.USER_read||, CODE, READONLY, ALIGN=1

                  USER_read PROC
;;;123      */
;;;124    DRESULT USER_read (
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;125    	BYTE pdrv,      /* Physical drive nmuber to identify the drive */
;;;126    	BYTE *buff,     /* Data buffer to store read data */
;;;127    	DWORD sector,   /* Sector address in LBA */
;;;128    	UINT count      /* Number of sectors to read */
;;;129    )
;;;130    {
000004  4607              MOV      r7,r0
000006  460d              MOV      r5,r1
000008  4616              MOV      r6,r2
00000a  461c              MOV      r4,r3
;;;131      /* USER CODE BEGIN READ */
;;;132      if (!count)
00000c  b914              CBNZ     r4,|L3.20|
;;;133        return RES_PARERR; //count ä¸èƒ½ç­‰äºŽ 0ï¼Œå¦åˆ™è¿”å›žå‚æ•°é”™è¯?
00000e  2004              MOVS     r0,#4
                  |L3.16|
;;;134      for (; count > 0; count--)
;;;135      {
;;;136        w25qxx_read(buff, sector * FLASH_SECTOR_SIZE, FLASH_SECTOR_SIZE);
;;;137        sector++;
;;;138        buff += FLASH_SECTOR_SIZE;
;;;139      }
;;;140    
;;;141      return RES_OK;
;;;142      /* USER CODE END READ */
;;;143    }
000010  e8bd81f0          POP      {r4-r8,pc}
                  |L3.20|
000014  e009              B        |L3.42|
                  |L3.22|
000016  0271              LSLS     r1,r6,#9              ;136
000018  f44f7200          MOV      r2,#0x200             ;136
00001c  4628              MOV      r0,r5                 ;136
00001e  f7fffffe          BL       w25qxx_read
000022  1c76              ADDS     r6,r6,#1              ;137
000024  f5057500          ADD      r5,r5,#0x200          ;138
000028  1e64              SUBS     r4,r4,#1              ;134
                  |L3.42|
00002a  2c00              CMP      r4,#0                 ;134
00002c  d1f3              BNE      |L3.22|
00002e  2000              MOVS     r0,#0                 ;141
000030  e7ee              B        |L3.16|
;;;144    
                          ENDP


                          AREA ||i.USER_status||, CODE, READONLY, ALIGN=2

                  USER_status PROC
;;;104      */
;;;105    DSTATUS USER_status (
000000  4601              MOV      r1,r0
;;;106    	BYTE pdrv       /* Physical drive number to identify the drive */
;;;107    )
;;;108    {
;;;109      /* USER CODE BEGIN STATUS */
;;;110      Stat = STA_NOINIT;
000002  2001              MOVS     r0,#1
000004  4a03              LDR      r2,|L4.20|
000006  7010              STRB     r0,[r2,#0]
;;;111      Stat = RES_OK;
000008  2000              MOVS     r0,#0
00000a  7010              STRB     r0,[r2,#0]
;;;112      return Stat;
00000c  4610              MOV      r0,r2
00000e  7800              LDRB     r0,[r0,#0]  ; Stat
;;;113      /* USER CODE END STATUS */
;;;114    }
000010  4770              BX       lr
;;;115    
                          ENDP

000012  0000              DCW      0x0000
                  |L4.20|
                          DCD      Stat

                          AREA ||i.USER_write||, CODE, READONLY, ALIGN=1

                  USER_write PROC
;;;153    #if _USE_WRITE == 1
;;;154    DRESULT USER_write (
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;155    	BYTE pdrv,          /* Physical drive nmuber to identify the drive */
;;;156    	const BYTE *buff,   /* Data to be written */
;;;157    	DWORD sector,       /* Sector address in LBA */
;;;158    	UINT count          /* Number of sectors to write */
;;;159    )
;;;160    {
000004  4607              MOV      r7,r0
000006  460d              MOV      r5,r1
000008  4616              MOV      r6,r2
00000a  461c              MOV      r4,r3
;;;161      /* USER CODE BEGIN WRITE */
;;;162      /* USER CODE HERE */
;;;163      if (!count)
00000c  b914              CBNZ     r4,|L5.20|
;;;164        return RES_PARERR; //count ä¸èƒ½ç­‰äºŽ 0ï¼Œå¦åˆ™è¿”å›žå‚æ•°é”™è¯?
00000e  2004              MOVS     r0,#4
                  |L5.16|
;;;165      for (; count > 0; count--)
;;;166      {
;;;167        w25qxx_write((uint8_t *)buff, sector * FLASH_SECTOR_SIZE, FLASH_SECTOR_SIZE);
;;;168        sector++;
;;;169        buff += FLASH_SECTOR_SIZE;
;;;170      }
;;;171      return RES_OK;
;;;172      /* USER CODE END WRITE */
;;;173    }
000010  e8bd81f0          POP      {r4-r8,pc}
                  |L5.20|
000014  e009              B        |L5.42|
                  |L5.22|
000016  0271              LSLS     r1,r6,#9              ;167
000018  f44f7200          MOV      r2,#0x200             ;167
00001c  4628              MOV      r0,r5                 ;167
00001e  f7fffffe          BL       w25qxx_write
000022  1c76              ADDS     r6,r6,#1              ;168
000024  f5057500          ADD      r5,r5,#0x200          ;169
000028  1e64              SUBS     r4,r4,#1              ;165
                  |L5.42|
00002a  2c00              CMP      r4,#0                 ;165
00002c  d1f3              BNE      |L5.22|
00002e  2000              MOVS     r0,#0                 ;171
000030  e7ee              B        |L5.16|
;;;174    #endif /* _USE_WRITE == 1 */
                          ENDP


                          AREA ||.constdata||, DATA, READONLY, ALIGN=0

                  CHANNEL_OFFSET_TAB
000000  081c3044          DCB      0x08,0x1c,0x30,0x44
000004  586c80            DCB      0x58,0x6c,0x80

                          AREA ||.data||, DATA, ALIGN=2

                  Stat
000000  01000000          DCB      0x01,0x00,0x00,0x00
                  USER_Driver
                          DCD      USER_initialize
                          DCD      USER_status
                          DCD      USER_read
                          DCD      USER_write
                          DCD      USER_ioctl

;*** Start embedded assembler ***

#line 1 "../Src/user_diskio.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___13_user_diskio_c_c1de0e20____REV16|
#line 463 "../Drivers/CMSIS/Include/cmsis_armcc.h"
|__asm___13_user_diskio_c_c1de0e20____REV16| PROC
#line 464

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___13_user_diskio_c_c1de0e20____REVSH|
#line 478
|__asm___13_user_diskio_c_c1de0e20____REVSH| PROC
#line 479

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___13_user_diskio_c_c1de0e20____RRX|
#line 665
|__asm___13_user_diskio_c_c1de0e20____RRX| PROC
#line 666

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
