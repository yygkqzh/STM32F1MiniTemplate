; generated by Component: ARM Compiler 5.06 update 7 (build 960) Tool: ArmCC [4d365d]
; commandline ArmCC [--c99 --split_sections --debug -c --asm --interleave -otemplate\spi.o --asm_dir=./ --list_dir=--list --depend=template\spi.d --cpu=Cortex-M3 --apcs=interwork -O0 --diag_suppress=9931 -I../Inc -I../Drivers/STM32F1xx_HAL_Driver/Inc -I../Drivers/STM32F1xx_HAL_Driver/Inc/Legacy -I../Middlewares/Third_Party/FatFs/src -I../Drivers/CMSIS/Device/ST/STM32F1xx/Include -I../Drivers/CMSIS/Include -I.\RTE\_Template -ID:\Keil_v5\Pack\ARM\CMSIS\5.7.0\CMSIS\Core\Include -ID:\Keil_v5\Pack\Keil\STM32F1xx_DFP\2.3.0\Device\Include -D__MICROLIB -D__UVISION_VERSION=533 -D_RTE_ -DSTM32F10X_MD -D_RTE_ -DUSE_FULL_LL_DRIVER -DUSE_HAL_DRIVER -DSTM32F103xB --signed_chars --omf_browse=template\spi.crf ../Src/spi.c]
                          THUMB

                          AREA ||i.HAL_SPI_MspDeInit||, CODE, READONLY, ALIGN=2

                  HAL_SPI_MspDeInit PROC
;;;123    
;;;124    void HAL_SPI_MspDeInit(SPI_HandleTypeDef* spiHandle)
000000  b510              PUSH     {r4,lr}
;;;125    {
000002  4604              MOV      r4,r0
;;;126    
;;;127      if(spiHandle->Instance==SPI1)
000004  490b              LDR      r1,|L1.52|
000006  6820              LDR      r0,[r4,#0]
000008  4288              CMP      r0,r1
00000a  d112              BNE      |L1.50|
;;;128      {
;;;129      /* USER CODE BEGIN SPI1_MspDeInit 0 */
;;;130    
;;;131      /* USER CODE END SPI1_MspDeInit 0 */
;;;132        /* Peripheral clock disable */
;;;133        __HAL_RCC_SPI1_CLK_DISABLE();
00000c  480a              LDR      r0,|L1.56|
00000e  6980              LDR      r0,[r0,#0x18]
000010  f4205080          BIC      r0,r0,#0x1000
000014  4908              LDR      r1,|L1.56|
000016  6188              STR      r0,[r1,#0x18]
;;;134    
;;;135        /**SPI1 GPIO Configuration
;;;136        PA5     ------> SPI1_SCK
;;;137        PA6     ------> SPI1_MISO
;;;138        PA7     ------> SPI1_MOSI
;;;139        */
;;;140        HAL_GPIO_DeInit(GPIOA, GPIO_PIN_5|GPIO_PIN_6|GPIO_PIN_7);
000018  21e0              MOVS     r1,#0xe0
00001a  4808              LDR      r0,|L1.60|
00001c  f7fffffe          BL       HAL_GPIO_DeInit
;;;141    
;;;142        /* SPI1 DMA DeInit */
;;;143        HAL_DMA_DeInit(spiHandle->hdmarx);
000020  6ce0              LDR      r0,[r4,#0x4c]
000022  f7fffffe          BL       HAL_DMA_DeInit
;;;144        HAL_DMA_DeInit(spiHandle->hdmatx);
000026  6ca0              LDR      r0,[r4,#0x48]
000028  f7fffffe          BL       HAL_DMA_DeInit
;;;145    
;;;146        /* SPI1 interrupt Deinit */
;;;147        HAL_NVIC_DisableIRQ(SPI1_IRQn);
00002c  2023              MOVS     r0,#0x23
00002e  f7fffffe          BL       HAL_NVIC_DisableIRQ
                  |L1.50|
;;;148      /* USER CODE BEGIN SPI1_MspDeInit 1 */
;;;149    
;;;150      /* USER CODE END SPI1_MspDeInit 1 */
;;;151      }
;;;152    }
000032  bd10              POP      {r4,pc}
;;;153    
                          ENDP

                  |L1.52|
                          DCD      0x40013000
                  |L1.56|
                          DCD      0x40021000
                  |L1.60|
                          DCD      0x40010800

                          AREA ||i.HAL_SPI_MspInit||, CODE, READONLY, ALIGN=2

                  HAL_SPI_MspInit PROC
;;;53     
;;;54     void HAL_SPI_MspInit(SPI_HandleTypeDef* spiHandle)
000000  b510              PUSH     {r4,lr}
;;;55     {
000002  b086              SUB      sp,sp,#0x18
000004  4604              MOV      r4,r0
;;;56     
;;;57       GPIO_InitTypeDef GPIO_InitStruct = {0};
000006  2000              MOVS     r0,#0
000008  9002              STR      r0,[sp,#8]
00000a  9003              STR      r0,[sp,#0xc]
00000c  9004              STR      r0,[sp,#0x10]
00000e  9005              STR      r0,[sp,#0x14]
;;;58       if(spiHandle->Instance==SPI1)
000010  4937              LDR      r1,|L2.240|
000012  6820              LDR      r0,[r4,#0]
000014  4288              CMP      r0,r1
000016  d168              BNE      |L2.234|
;;;59       {
;;;60       /* USER CODE BEGIN SPI1_MspInit 0 */
;;;61     
;;;62       /* USER CODE END SPI1_MspInit 0 */
;;;63         /* SPI1 clock enable */
;;;64         __HAL_RCC_SPI1_CLK_ENABLE();
000018  bf00              NOP      
00001a  4836              LDR      r0,|L2.244|
00001c  6980              LDR      r0,[r0,#0x18]
00001e  f4405080          ORR      r0,r0,#0x1000
000022  4934              LDR      r1,|L2.244|
000024  6188              STR      r0,[r1,#0x18]
000026  4608              MOV      r0,r1
000028  6980              LDR      r0,[r0,#0x18]
00002a  f4005080          AND      r0,r0,#0x1000
00002e  9001              STR      r0,[sp,#4]
000030  bf00              NOP      
000032  bf00              NOP      
;;;65     
;;;66         __HAL_RCC_GPIOA_CLK_ENABLE();
000034  bf00              NOP      
000036  4608              MOV      r0,r1
000038  6980              LDR      r0,[r0,#0x18]
00003a  f0400004          ORR      r0,r0,#4
00003e  6188              STR      r0,[r1,#0x18]
000040  4608              MOV      r0,r1
000042  6980              LDR      r0,[r0,#0x18]
000044  f0000004          AND      r0,r0,#4
000048  9001              STR      r0,[sp,#4]
00004a  bf00              NOP      
00004c  bf00              NOP      
;;;67         /**SPI1 GPIO Configuration
;;;68         PA5     ------> SPI1_SCK
;;;69         PA6     ------> SPI1_MISO
;;;70         PA7     ------> SPI1_MOSI
;;;71         */
;;;72         GPIO_InitStruct.Pin = GPIO_PIN_5|GPIO_PIN_7;
00004e  20a0              MOVS     r0,#0xa0
000050  9002              STR      r0,[sp,#8]
;;;73         GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
000052  2002              MOVS     r0,#2
000054  9003              STR      r0,[sp,#0xc]
;;;74         GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_HIGH;
000056  2003              MOVS     r0,#3
000058  9005              STR      r0,[sp,#0x14]
;;;75         HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
00005a  a902              ADD      r1,sp,#8
00005c  4826              LDR      r0,|L2.248|
00005e  f7fffffe          BL       HAL_GPIO_Init
;;;76     
;;;77         GPIO_InitStruct.Pin = GPIO_PIN_6;
000062  2040              MOVS     r0,#0x40
000064  9002              STR      r0,[sp,#8]
;;;78         GPIO_InitStruct.Mode = GPIO_MODE_INPUT;
000066  2000              MOVS     r0,#0
000068  9003              STR      r0,[sp,#0xc]
;;;79         GPIO_InitStruct.Pull = GPIO_NOPULL;
00006a  9004              STR      r0,[sp,#0x10]
;;;80         HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
00006c  a902              ADD      r1,sp,#8
00006e  4822              LDR      r0,|L2.248|
000070  f7fffffe          BL       HAL_GPIO_Init
;;;81     
;;;82         /* SPI1 DMA Init */
;;;83         /* SPI1_RX Init */
;;;84         hdma_spi1_rx.Instance = DMA1_Channel2;
000074  4821              LDR      r0,|L2.252|
000076  4922              LDR      r1,|L2.256|
000078  6008              STR      r0,[r1,#0]  ; hdma_spi1_rx
;;;85         hdma_spi1_rx.Init.Direction = DMA_PERIPH_TO_MEMORY;
00007a  2000              MOVS     r0,#0
00007c  6048              STR      r0,[r1,#4]  ; hdma_spi1_rx
;;;86         hdma_spi1_rx.Init.PeriphInc = DMA_PINC_DISABLE;
00007e  2100              MOVS     r1,#0
000080  481f              LDR      r0,|L2.256|
000082  6081              STR      r1,[r0,#8]
;;;87         hdma_spi1_rx.Init.MemInc = DMA_MINC_ENABLE;
000084  2180              MOVS     r1,#0x80
000086  60c1              STR      r1,[r0,#0xc]
;;;88         hdma_spi1_rx.Init.PeriphDataAlignment = DMA_PDATAALIGN_BYTE;
000088  2100              MOVS     r1,#0
00008a  6101              STR      r1,[r0,#0x10]
;;;89         hdma_spi1_rx.Init.MemDataAlignment = DMA_MDATAALIGN_BYTE;
00008c  6141              STR      r1,[r0,#0x14]
;;;90         hdma_spi1_rx.Init.Mode = DMA_NORMAL;
00008e  6181              STR      r1,[r0,#0x18]
;;;91         hdma_spi1_rx.Init.Priority = DMA_PRIORITY_LOW;
000090  61c1              STR      r1,[r0,#0x1c]
;;;92         if (HAL_DMA_Init(&hdma_spi1_rx) != HAL_OK)
000092  f7fffffe          BL       HAL_DMA_Init
000096  b108              CBZ      r0,|L2.156|
;;;93         {
;;;94           Error_Handler();
000098  f7fffffe          BL       Error_Handler
                  |L2.156|
;;;95         }
;;;96     
;;;97         __HAL_LINKDMA(spiHandle,hdmarx,hdma_spi1_rx);
00009c  bf00              NOP      
00009e  4818              LDR      r0,|L2.256|
0000a0  64e0              STR      r0,[r4,#0x4c]
0000a2  6244              STR      r4,[r0,#0x24]  ; hdma_spi1_rx
0000a4  bf00              NOP      
;;;98     
;;;99         /* SPI1_TX Init */
;;;100        hdma_spi1_tx.Instance = DMA1_Channel3;
0000a6  4815              LDR      r0,|L2.252|
0000a8  3014              ADDS     r0,r0,#0x14
0000aa  4916              LDR      r1,|L2.260|
0000ac  6008              STR      r0,[r1,#0]  ; hdma_spi1_tx
;;;101        hdma_spi1_tx.Init.Direction = DMA_MEMORY_TO_PERIPH;
0000ae  2010              MOVS     r0,#0x10
0000b0  6048              STR      r0,[r1,#4]  ; hdma_spi1_tx
;;;102        hdma_spi1_tx.Init.PeriphInc = DMA_PINC_DISABLE;
0000b2  2100              MOVS     r1,#0
0000b4  4813              LDR      r0,|L2.260|
0000b6  6081              STR      r1,[r0,#8]
;;;103        hdma_spi1_tx.Init.MemInc = DMA_MINC_ENABLE;
0000b8  2180              MOVS     r1,#0x80
0000ba  60c1              STR      r1,[r0,#0xc]
;;;104        hdma_spi1_tx.Init.PeriphDataAlignment = DMA_PDATAALIGN_BYTE;
0000bc  2100              MOVS     r1,#0
0000be  6101              STR      r1,[r0,#0x10]
;;;105        hdma_spi1_tx.Init.MemDataAlignment = DMA_MDATAALIGN_BYTE;
0000c0  6141              STR      r1,[r0,#0x14]
;;;106        hdma_spi1_tx.Init.Mode = DMA_NORMAL;
0000c2  6181              STR      r1,[r0,#0x18]
;;;107        hdma_spi1_tx.Init.Priority = DMA_PRIORITY_LOW;
0000c4  61c1              STR      r1,[r0,#0x1c]
;;;108        if (HAL_DMA_Init(&hdma_spi1_tx) != HAL_OK)
0000c6  f7fffffe          BL       HAL_DMA_Init
0000ca  b108              CBZ      r0,|L2.208|
;;;109        {
;;;110          Error_Handler();
0000cc  f7fffffe          BL       Error_Handler
                  |L2.208|
;;;111        }
;;;112    
;;;113        __HAL_LINKDMA(spiHandle,hdmatx,hdma_spi1_tx);
0000d0  bf00              NOP      
0000d2  480c              LDR      r0,|L2.260|
0000d4  64a0              STR      r0,[r4,#0x48]
0000d6  6244              STR      r4,[r0,#0x24]  ; hdma_spi1_tx
0000d8  bf00              NOP      
;;;114    
;;;115        /* SPI1 interrupt Init */
;;;116        HAL_NVIC_SetPriority(SPI1_IRQn, 0, 0);
0000da  2200              MOVS     r2,#0
0000dc  4611              MOV      r1,r2
0000de  2023              MOVS     r0,#0x23
0000e0  f7fffffe          BL       HAL_NVIC_SetPriority
;;;117        HAL_NVIC_EnableIRQ(SPI1_IRQn);
0000e4  2023              MOVS     r0,#0x23
0000e6  f7fffffe          BL       HAL_NVIC_EnableIRQ
                  |L2.234|
;;;118      /* USER CODE BEGIN SPI1_MspInit 1 */
;;;119    
;;;120      /* USER CODE END SPI1_MspInit 1 */
;;;121      }
;;;122    }
0000ea  b006              ADD      sp,sp,#0x18
0000ec  bd10              POP      {r4,pc}
;;;123    
                          ENDP

0000ee  0000              DCW      0x0000
                  |L2.240|
                          DCD      0x40013000
                  |L2.244|
                          DCD      0x40021000
                  |L2.248|
                          DCD      0x40010800
                  |L2.252|
                          DCD      0x4002001c
                  |L2.256|
                          DCD      hdma_spi1_rx
                  |L2.260|
                          DCD      hdma_spi1_tx

                          AREA ||i.MX_SPI1_Init||, CODE, READONLY, ALIGN=2

                  MX_SPI1_Init PROC
;;;31     /* SPI1 init function */
;;;32     void MX_SPI1_Init(void)
000000  b510              PUSH     {r4,lr}
;;;33     {
;;;34     
;;;35       hspi1.Instance = SPI1;
000002  480f              LDR      r0,|L3.64|
000004  490f              LDR      r1,|L3.68|
000006  6008              STR      r0,[r1,#0]  ; hspi1
;;;36       hspi1.Init.Mode = SPI_MODE_MASTER;
000008  f44f7082          MOV      r0,#0x104
00000c  6048              STR      r0,[r1,#4]  ; hspi1
;;;37       hspi1.Init.Direction = SPI_DIRECTION_2LINES;
00000e  2100              MOVS     r1,#0
000010  480c              LDR      r0,|L3.68|
000012  6081              STR      r1,[r0,#8]
;;;38       hspi1.Init.DataSize = SPI_DATASIZE_8BIT;
000014  60c1              STR      r1,[r0,#0xc]
;;;39       hspi1.Init.CLKPolarity = SPI_POLARITY_HIGH;
000016  2102              MOVS     r1,#2
000018  6101              STR      r1,[r0,#0x10]
;;;40       hspi1.Init.CLKPhase = SPI_PHASE_2EDGE;
00001a  2101              MOVS     r1,#1
00001c  6141              STR      r1,[r0,#0x14]
;;;41       hspi1.Init.NSS = SPI_NSS_SOFT;
00001e  0249              LSLS     r1,r1,#9
000020  6181              STR      r1,[r0,#0x18]
;;;42       hspi1.Init.BaudRatePrescaler = SPI_BAUDRATEPRESCALER_256;
000022  2138              MOVS     r1,#0x38
000024  61c1              STR      r1,[r0,#0x1c]
;;;43       hspi1.Init.FirstBit = SPI_FIRSTBIT_MSB;
000026  2100              MOVS     r1,#0
000028  6201              STR      r1,[r0,#0x20]
;;;44       hspi1.Init.TIMode = SPI_TIMODE_DISABLE;
00002a  6241              STR      r1,[r0,#0x24]
;;;45       hspi1.Init.CRCCalculation = SPI_CRCCALCULATION_DISABLE;
00002c  6281              STR      r1,[r0,#0x28]
;;;46       hspi1.Init.CRCPolynomial = 10;
00002e  210a              MOVS     r1,#0xa
000030  62c1              STR      r1,[r0,#0x2c]
;;;47       if (HAL_SPI_Init(&hspi1) != HAL_OK)
000032  f7fffffe          BL       HAL_SPI_Init
000036  b108              CBZ      r0,|L3.60|
;;;48       {
;;;49         Error_Handler();
000038  f7fffffe          BL       Error_Handler
                  |L3.60|
;;;50       }
;;;51     
;;;52     }
00003c  bd10              POP      {r4,pc}
;;;53     
                          ENDP

00003e  0000              DCW      0x0000
                  |L3.64|
                          DCD      0x40013000
                  |L3.68|
                          DCD      hspi1

                          AREA ||i.Spi1Select||, CODE, READONLY, ALIGN=2

                  Spi1Select PROC
;;;202    }
;;;203    void Spi1Select(Spi1Select_TypeDef select)
000000  b110              CBZ      r0,|L4.8|
;;;204    {
;;;205      switch (select)
000002  2801              CMP      r0,#1
000004  d10e              BNE      |L4.36|
000006  e006              B        |L4.22|
                  |L4.8|
;;;206      {
;;;207      case UnSelect:
;;;208      {
;;;209        LL_GPIO_SetOutputPin(GPIOA, F_CS_Pin);
000008  f2404104          MOV      r1,#0x404
00000c  0a0a              LSRS     r2,r1,#8
00000e  4b07              LDR      r3,|L4.44|
000010  611a              STR      r2,[r3,#0x10]
000012  bf00              NOP      
;;;210      }
;;;211      break;
000014  e007              B        |L4.38|
                  |L4.22|
;;;212      case Select:
;;;213      {
;;;214        LL_GPIO_ResetOutputPin(GPIOA, F_CS_Pin);
000016  f2404104          MOV      r1,#0x404
00001a  0a0a              LSRS     r2,r1,#8
00001c  4b03              LDR      r3,|L4.44|
00001e  615a              STR      r2,[r3,#0x14]
000020  bf00              NOP      
;;;215      }
;;;216      break;
000022  e000              B        |L4.38|
                  |L4.36|
;;;217      default:
;;;218        break;
000024  bf00              NOP      
                  |L4.38|
000026  bf00              NOP                            ;211
;;;219      }
;;;220    }
000028  4770              BX       lr
;;;221    /* USER CODE END 1 */
                          ENDP

00002a  0000              DCW      0x0000
                  |L4.44|
                          DCD      0x40010800

                          AREA ||i.Spi1WriteByte||, CODE, READONLY, ALIGN=2

                  Spi1WriteByte PROC
;;;154    /* USER CODE BEGIN 1 */
;;;155    void Spi1WriteByte(uint8_t data)
000000  b501              PUSH     {r0,lr}
;;;156    {
;;;157      if (HAL_SPI_Transmit(&hspi1, &data, sizeof(data), 1000) != HAL_OK)
000002  f44f737a          MOV      r3,#0x3e8
000006  2201              MOVS     r2,#1
000008  4669              MOV      r1,sp
00000a  4803              LDR      r0,|L5.24|
00000c  f7fffffe          BL       HAL_SPI_Transmit
000010  b108              CBZ      r0,|L5.22|
;;;158      {
;;;159        Error_Handler();
000012  f7fffffe          BL       Error_Handler
                  |L5.22|
;;;160      }
;;;161    }
000016  bd08              POP      {r3,pc}
;;;162    void Spi1WriteWord(uint16_t data)
                          ENDP

                  |L5.24|
                          DCD      hspi1

                          AREA ||i.Spi1WriteDWord||, CODE, READONLY, ALIGN=2

                  Spi1WriteDWord PROC
;;;168    }
;;;169    void Spi1WriteDWord(uint32_t data)
000000  b501              PUSH     {r0,lr}
;;;170    {
;;;171      if (HAL_SPI_Transmit(&hspi1, (uint8_t *)&data, sizeof(data), 1000) != HAL_OK)
000002  f44f737a          MOV      r3,#0x3e8
000006  2204              MOVS     r2,#4
000008  4669              MOV      r1,sp
00000a  4803              LDR      r0,|L6.24|
00000c  f7fffffe          BL       HAL_SPI_Transmit
000010  b108              CBZ      r0,|L6.22|
;;;172      {
;;;173        Error_Handler();
000012  f7fffffe          BL       Error_Handler
                  |L6.22|
;;;174      }
;;;175    }
000016  bd08              POP      {r3,pc}
;;;176    uint8_t Spi1WriteReadByte(uint8_t data)
                          ENDP

                  |L6.24|
                          DCD      hspi1

                          AREA ||i.Spi1WriteReadByte||, CODE, READONLY, ALIGN=2

                  Spi1WriteReadByte PROC
;;;175    }
;;;176    uint8_t Spi1WriteReadByte(uint8_t data)
000000  b501              PUSH     {r0,lr}
;;;177    {
000002  b082              SUB      sp,sp,#8
;;;178      uint8_t ret = 0;
000004  2000              MOVS     r0,#0
000006  9001              STR      r0,[sp,#4]
;;;179      if (HAL_SPI_TransmitReceive(&hspi1, &data, &ret, sizeof(data), 1000) != HAL_OK)
000008  f44f707a          MOV      r0,#0x3e8
00000c  2301              MOVS     r3,#1
00000e  aa01              ADD      r2,sp,#4
000010  a902              ADD      r1,sp,#8
000012  9000              STR      r0,[sp,#0]
000014  4804              LDR      r0,|L7.40|
000016  f7fffffe          BL       HAL_SPI_TransmitReceive
00001a  b108              CBZ      r0,|L7.32|
;;;180      {
;;;181        Error_Handler();
00001c  f7fffffe          BL       Error_Handler
                  |L7.32|
;;;182      }
;;;183      return ret;
000020  f89d0004          LDRB     r0,[sp,#4]
;;;184    }
000024  bd0e              POP      {r1-r3,pc}
;;;185    uint16_t Spi1WriteReadWord(uint16_t data)
                          ENDP

000026  0000              DCW      0x0000
                  |L7.40|
                          DCD      hspi1

                          AREA ||i.Spi1WriteReadDWord||, CODE, READONLY, ALIGN=2

                  Spi1WriteReadDWord PROC
;;;193    }
;;;194    uint32_t Spi1WriteReadDWord(uint32_t data)
000000  b501              PUSH     {r0,lr}
;;;195    {
000002  b082              SUB      sp,sp,#8
;;;196      uint8_t buf[4] = {0};
000004  2000              MOVS     r0,#0
000006  9001              STR      r0,[sp,#4]
;;;197      if (HAL_SPI_TransmitReceive(&hspi1, (uint8_t *)&data, buf, sizeof(data), 1000) != HAL_OK)
000008  f44f707a          MOV      r0,#0x3e8
00000c  2304              MOVS     r3,#4
00000e  aa01              ADD      r2,sp,#4
000010  a902              ADD      r1,sp,#8
000012  9000              STR      r0,[sp,#0]
000014  480a              LDR      r0,|L8.64|
000016  f7fffffe          BL       HAL_SPI_TransmitReceive
00001a  b108              CBZ      r0,|L8.32|
;;;198      {
;;;199        Error_Handler();
00001c  f7fffffe          BL       Error_Handler
                  |L8.32|
;;;200      }
;;;201      return (buf[0] << 24 | buf[1] << 16 | buf[2] << 8 | buf[3]);
000020  f89d0004          LDRB     r0,[sp,#4]
000024  0600              LSLS     r0,r0,#24
000026  f89d1005          LDRB     r1,[sp,#5]
00002a  ea404001          ORR      r0,r0,r1,LSL #16
00002e  f89d1006          LDRB     r1,[sp,#6]
000032  ea402001          ORR      r0,r0,r1,LSL #8
000036  f89d1007          LDRB     r1,[sp,#7]
00003a  4308              ORRS     r0,r0,r1
;;;202    }
00003c  bd0e              POP      {r1-r3,pc}
;;;203    void Spi1Select(Spi1Select_TypeDef select)
                          ENDP

00003e  0000              DCW      0x0000
                  |L8.64|
                          DCD      hspi1

                          AREA ||i.Spi1WriteReadWord||, CODE, READONLY, ALIGN=2

                  Spi1WriteReadWord PROC
;;;184    }
;;;185    uint16_t Spi1WriteReadWord(uint16_t data)
000000  b501              PUSH     {r0,lr}
;;;186    {
000002  b082              SUB      sp,sp,#8
;;;187      uint8_t buf[2] = {0};
000004  2000              MOVS     r0,#0
000006  9001              STR      r0,[sp,#4]
;;;188      if (HAL_SPI_TransmitReceive(&hspi1, (uint8_t *)&data, buf, sizeof(data), 1000) != HAL_OK)
000008  f44f707a          MOV      r0,#0x3e8
00000c  2302              MOVS     r3,#2
00000e  aa01              ADD      r2,sp,#4
000010  a902              ADD      r1,sp,#8
000012  9000              STR      r0,[sp,#0]
000014  4806              LDR      r0,|L9.48|
000016  f7fffffe          BL       HAL_SPI_TransmitReceive
00001a  b108              CBZ      r0,|L9.32|
;;;189      {
;;;190        Error_Handler();
00001c  f7fffffe          BL       Error_Handler
                  |L9.32|
;;;191      }
;;;192      return (buf[0] << 8 | buf[1]);
000020  f89d0005          LDRB     r0,[sp,#5]
000024  f89d1004          LDRB     r1,[sp,#4]
000028  ea402001          ORR      r0,r0,r1,LSL #8
;;;193    }
00002c  bd0e              POP      {r1-r3,pc}
;;;194    uint32_t Spi1WriteReadDWord(uint32_t data)
                          ENDP

00002e  0000              DCW      0x0000
                  |L9.48|
                          DCD      hspi1

                          AREA ||i.Spi1WriteWord||, CODE, READONLY, ALIGN=2

                  Spi1WriteWord PROC
;;;161    }
;;;162    void Spi1WriteWord(uint16_t data)
000000  b501              PUSH     {r0,lr}
;;;163    {
;;;164      if (HAL_SPI_Transmit(&hspi1, (uint8_t *)&data, sizeof(data), 1000) != HAL_OK)
000002  f44f737a          MOV      r3,#0x3e8
000006  2202              MOVS     r2,#2
000008  4669              MOV      r1,sp
00000a  4803              LDR      r0,|L10.24|
00000c  f7fffffe          BL       HAL_SPI_Transmit
000010  b108              CBZ      r0,|L10.22|
;;;165      {
;;;166        Error_Handler();
000012  f7fffffe          BL       Error_Handler
                  |L10.22|
;;;167      }
;;;168    }
000016  bd08              POP      {r3,pc}
;;;169    void Spi1WriteDWord(uint32_t data)
                          ENDP

                  |L10.24|
                          DCD      hspi1

                          AREA ||.bss||, DATA, NOINIT, ALIGN=2

                  hspi1
                          %        88
                  hdma_spi1_rx
                          %        68
                  hdma_spi1_tx
                          %        68

                          AREA ||.constdata||, DATA, READONLY, ALIGN=0

                  CHANNEL_OFFSET_TAB
000000  081c3044          DCB      0x08,0x1c,0x30,0x44
000004  586c80            DCB      0x58,0x6c,0x80

;*** Start embedded assembler ***

#line 1 "../Src/spi.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___5_spi_c_a276374e____REV16|
#line 463 "../Drivers/CMSIS/Include/cmsis_armcc.h"
|__asm___5_spi_c_a276374e____REV16| PROC
#line 464

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___5_spi_c_a276374e____REVSH|
#line 478
|__asm___5_spi_c_a276374e____REVSH| PROC
#line 479

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___5_spi_c_a276374e____RRX|
#line 665
|__asm___5_spi_c_a276374e____RRX| PROC
#line 666

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
