; generated by Component: ARM Compiler 5.06 update 7 (build 960) Tool: ArmCC [4d365d]
; commandline ArmCC [--c99 --split_sections --debug -c --asm --interleave -otemplate\w25qxx.o --asm_dir=./ --list_dir=--list --depend=template\w25qxx.d --cpu=Cortex-M3 --apcs=interwork -O0 --diag_suppress=9931 -I../Inc -I../Drivers/STM32F1xx_HAL_Driver/Inc -I../Drivers/STM32F1xx_HAL_Driver/Inc/Legacy -I../Middlewares/Third_Party/FatFs/src -I../Drivers/CMSIS/Device/ST/STM32F1xx/Include -I../Drivers/CMSIS/Include -I.\RTE\_Template -ID:\Keil_v5\Pack\ARM\CMSIS\5.7.0\CMSIS\Core\Include -ID:\Keil_v5\Pack\Keil\STM32F1xx_DFP\2.3.0\Device\Include -D__MICROLIB -D__UVISION_VERSION=533 -D_RTE_ -DSTM32F10X_MD -D_RTE_ -DUSE_FULL_LL_DRIVER -DUSE_HAL_DRIVER -DSTM32F103xB --signed_chars --omf_browse=template\w25qxx.crf ..\Src\w25qxx.c]
                          THUMB

                          AREA ||i.flash_test||, CODE, READONLY, ALIGN=1

                  flash_test PROC
;;;286    
;;;287    __attribute__((unused)) static uint8_t flash_test()
000000  b51c              PUSH     {r2-r4,lr}
;;;288    {
;;;289    	uint16_t i = 0;
000002  2400              MOVS     r4,#0
;;;290    	uint8_t dat[5];
;;;291    
;;;292    	for (i = 0; i < sizeof(dat); i++)
000004  bf00              NOP      
000006  e004              B        |L1.18|
                  |L1.8|
;;;293    	{
;;;294    		dat[i] = i;
000008  b2e0              UXTB     r0,r4
00000a  f80d0004          STRB     r0,[sp,r4]
00000e  1c60              ADDS     r0,r4,#1              ;292
000010  b284              UXTH     r4,r0                 ;292
                  |L1.18|
000012  2c05              CMP      r4,#5                 ;292
000014  d3f8              BCC      |L1.8|
;;;295    	}
;;;296    
;;;297    	w25qxx_write(dat, 0x1000, sizeof(dat));
000016  2205              MOVS     r2,#5
000018  f44f5180          MOV      r1,#0x1000
00001c  4668              MOV      r0,sp
00001e  f7fffffe          BL       w25qxx_write
;;;298    
;;;299    	memset(dat, 0, sizeof(dat));
000022  2000              MOVS     r0,#0
000024  9000              STR      r0,[sp,#0]
000026  9001              STR      r0,[sp,#4]
;;;300    
;;;301    	w25qxx_read(dat, 0x1000, sizeof(dat));
000028  2205              MOVS     r2,#5
00002a  f44f5180          MOV      r1,#0x1000
00002e  4668              MOV      r0,sp
000030  f7fffffe          BL       w25qxx_read
;;;302    	for (i = 0; i < sizeof(dat); i++)
000034  2400              MOVS     r4,#0
000036  e008              B        |L1.74|
                  |L1.56|
;;;303    	{
;;;304    		if (dat[i] != (uint8_t)i)
000038  f81d0004          LDRB     r0,[sp,r4]
00003c  b2e1              UXTB     r1,r4
00003e  4288              CMP      r0,r1
000040  d001              BEQ      |L1.70|
;;;305    			return 1;
000042  2001              MOVS     r0,#1
                  |L1.68|
;;;306    	}
;;;307    
;;;308    	return 0;
;;;309    }
000044  bd1c              POP      {r2-r4,pc}
                  |L1.70|
000046  1c60              ADDS     r0,r4,#1              ;302
000048  b284              UXTH     r4,r0                 ;302
                  |L1.74|
00004a  2c05              CMP      r4,#5                 ;302
00004c  d3f4              BCC      |L1.56|
00004e  2000              MOVS     r0,#0                 ;308
000050  e7f8              B        |L1.68|
                          ENDP


                          AREA ||i.w25qxx_erase_chip||, CODE, READONLY, ALIGN=1

                  w25qxx_erase_chip PROC
;;;229    //等待时间超长...
;;;230    void w25qxx_erase_chip(void)
000000  b510              PUSH     {r4,lr}
;;;231    {
;;;232    	Spi1Select(Select); //使能器件
000002  2001              MOVS     r0,#1
000004  f7fffffe          BL       Spi1Select
;;;233    	//w25qxx_write_enable(); //SET WEL
;;;234    	//w25qxx_wait_busy();
;;;235    	Spi1WriteByte(W25X_ChipErase);
000008  20c7              MOVS     r0,#0xc7
00000a  f7fffffe          BL       Spi1WriteByte
;;;236    	//Spi1WriteReadByte(W25X_ChipErase); //发送片擦除命令
;;;237    	w25qxx_wait_busy();	  //等待芯片擦除结束
00000e  f7fffffe          BL       w25qxx_wait_busy
;;;238    	Spi1Select(UnSelect); //取消片选
000012  2000              MOVS     r0,#0
000014  f7fffffe          BL       Spi1Select
;;;239    }
000018  bd10              POP      {r4,pc}
;;;240    //擦除一个扇区
                          ENDP


                          AREA ||i.w25qxx_erase_sector||, CODE, READONLY, ALIGN=1

                  w25qxx_erase_sector PROC
;;;242    //擦除一个山区的最少时间:150ms
;;;243    void w25qxx_erase_sector(uint32_t dst_addr)
000000  b510              PUSH     {r4,lr}
;;;244    {
000002  4604              MOV      r4,r0
;;;245    	dst_addr *= 4096;
000004  0324              LSLS     r4,r4,#12
;;;246    	w25qxx_write_enable(); //SET WEL
000006  f7fffffe          BL       w25qxx_write_enable
;;;247    	w25qxx_wait_busy();
00000a  f7fffffe          BL       w25qxx_wait_busy
;;;248    	Spi1Select(Select);	   //使能器件
00000e  2001              MOVS     r0,#1
000010  f7fffffe          BL       Spi1Select
;;;249    	
;;;250    	dst_addr <<= 8;
000014  0224              LSLS     r4,r4,#8
;;;251    	dst_addr |= W25X_SectorErase;
000016  f0440420          ORR      r4,r4,#0x20
;;;252    	//	dst_addr &= 0xffffff;
;;;253    	//	dst_addr |= W25X_SectorErase << 24;
;;;254    	//	Spi1WriteReadDWord(dst_addr);
;;;255    	Spi1WriteDWord(dst_addr);
00001a  4620              MOV      r0,r4
00001c  f7fffffe          BL       Spi1WriteDWord
;;;256    	//	spi3_readwritebyte(W25X_SectorErase);			 //发送扇区擦除指令
;;;257    	//	spi3_readwritebyte((uint8_t)((dst_addr) >> 16)); //发送24bit地址
;;;258    	//	spi3_readwritebyte((uint8_t)((dst_addr) >> 8));
;;;259    	//	spi3_readwritebyte((uint8_t)dst_addr);
;;;260    	
;;;261    	Spi1Select(UnSelect); //取消片选
000020  2000              MOVS     r0,#0
000022  f7fffffe          BL       Spi1Select
;;;262    	w25qxx_wait_busy();	  //等待擦除完成
000026  f7fffffe          BL       w25qxx_wait_busy
;;;263    }
00002a  bd10              POP      {r4,pc}
;;;264    //等待空闲
                          ENDP


                          AREA ||i.w25qxx_init||, CODE, READONLY, ALIGN=1

                  w25qxx_init PROC
;;;72     
;;;73     bool w25qxx_init()
000000  b510              PUSH     {r4,lr}
;;;74     {
000002  b0fe              SUB      sp,sp,#0x1f8
;;;75     	uint16_t chip_id = 0;
000004  2400              MOVS     r4,#0
;;;76     	uint8_t dat[500];
;;;77     	chip_id = w25qxx_readID();
000006  f7fffffe          BL       w25qxx_readID
00000a  4604              MOV      r4,r0
;;;78     	if (chip_id == W25Q128)
00000c  f64e7017          MOV      r0,#0xef17
000010  4284              CMP      r4,r0
000012  d10a              BNE      |L4.42|
;;;79     	{
;;;80     		//w25qxx_erase_chip();
;;;81     		w25qxx_read(dat, 0, sizeof(dat));
000014  f44f72fa          MOV      r2,#0x1f4
000018  2100              MOVS     r1,#0
00001a  a801              ADD      r0,sp,#4
00001c  f7fffffe          BL       w25qxx_read
;;;82     		flash_test();
000020  f7fffffe          BL       flash_test
;;;83     		return true;
000024  2001              MOVS     r0,#1
                  |L4.38|
;;;84     	}
;;;85     	return false;
;;;86     }
000026  b07e              ADD      sp,sp,#0x1f8
000028  bd10              POP      {r4,pc}
                  |L4.42|
00002a  2000              MOVS     r0,#0                 ;85
00002c  e7fb              B        |L4.38|
;;;87     
                          ENDP


                          AREA ||i.w25qxx_powerdown||, CODE, READONLY, ALIGN=1

                  w25qxx_powerdown PROC
;;;270    //进入掉电模式
;;;271    void w25qxx_powerdown(void)
000000  b510              PUSH     {r4,lr}
;;;272    {
;;;273    	Spi1Select(Select);				   //使能器件
000002  2001              MOVS     r0,#1
000004  f7fffffe          BL       Spi1Select
;;;274    	Spi1WriteReadByte(W25X_PowerDown); //发送掉电命令
000008  20b9              MOVS     r0,#0xb9
00000a  f7fffffe          BL       Spi1WriteReadByte
;;;275    	Spi1Select(UnSelect);			   //取消片选
00000e  2000              MOVS     r0,#0
000010  f7fffffe          BL       Spi1Select
;;;276    	HAL_Delay(1);					   //等待TPD
000014  2001              MOVS     r0,#1
000016  f7fffffe          BL       HAL_Delay
;;;277    }
00001a  bd10              POP      {r4,pc}
;;;278    //唤醒
                          ENDP


                          AREA ||i.w25qxx_read||, CODE, READONLY, ALIGN=1

                  w25qxx_read PROC
;;;92     //NumByteToRead:要读取的字节数(最大65535)
;;;93     void w25qxx_read(uint8_t *pBuffer, uint32_t readaddr, uint16_t numbytetoread)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;94     {
000004  4606              MOV      r6,r0
000006  460c              MOV      r4,r1
000008  4617              MOV      r7,r2
;;;95     	uint16_t i = 0;
00000a  2500              MOVS     r5,#0
;;;96     //	readaddr <<= 8;
;;;97     //	readaddr |= W25X_ReadData;
;;;98     	Spi1Select(Select); //使能器件
00000c  2001              MOVS     r0,#1
00000e  f7fffffe          BL       Spi1Select
;;;99     
;;;100    	//Spi1WriteDWord(readaddr);
;;;101    	Spi1WriteReadByte(W25X_ReadData);
000012  2003              MOVS     r0,#3
000014  f7fffffe          BL       Spi1WriteReadByte
;;;102    	Spi1WriteReadByte(readaddr >> 16);
000018  f3c44007          UBFX     r0,r4,#16,#8
00001c  f7fffffe          BL       Spi1WriteReadByte
;;;103    	Spi1WriteReadByte(readaddr >> 8);
000020  f3c42007          UBFX     r0,r4,#8,#8
000024  f7fffffe          BL       Spi1WriteReadByte
;;;104    	Spi1WriteReadByte(readaddr);
000028  b2e0              UXTB     r0,r4
00002a  f7fffffe          BL       Spi1WriteReadByte
;;;105    	
;;;106    	
;;;107    	for (i = 0; i < numbytetoread; i++)
00002e  bf00              NOP      
000030  e005              B        |L6.62|
                  |L6.50|
;;;108    	{
;;;109    		pBuffer[i] = Spi1WriteReadByte(0XFF); //循环读数
000032  20ff              MOVS     r0,#0xff
000034  f7fffffe          BL       Spi1WriteReadByte
000038  5570              STRB     r0,[r6,r5]
00003a  1c68              ADDS     r0,r5,#1              ;107
00003c  b285              UXTH     r5,r0                 ;107
                  |L6.62|
00003e  42bd              CMP      r5,r7                 ;107
000040  dbf7              BLT      |L6.50|
;;;110    	}
;;;111    	Spi1Select(UnSelect);
000042  2000              MOVS     r0,#0
000044  f7fffffe          BL       Spi1Select
;;;112    }
000048  e8bd81f0          POP      {r4-r8,pc}
;;;113    //SPI在一页(0~65535)内写入少于256个字节的数据
                          ENDP


                          AREA ||i.w25qxx_readID||, CODE, READONLY, ALIGN=1

                  w25qxx_readID PROC
;;;60     //0XEF17,表示芯片型号为W25Q128
;;;61     static uint16_t w25qxx_readID(void)
000000  b570              PUSH     {r4-r6,lr}
;;;62     {
;;;63     	uint16_t temp = 0;
000002  2400              MOVS     r4,#0
;;;64     	uint32_t read_id = W25X_ManufactDeviceID;
000004  2590              MOVS     r5,#0x90
;;;65     	uint16_t idle_dat = 0xffff;
000006  f64f76ff          MOV      r6,#0xffff
;;;66     	Spi1Select(Select);
00000a  2001              MOVS     r0,#1
00000c  f7fffffe          BL       Spi1Select
;;;67     	Spi1WriteReadDWord(read_id);
000010  4628              MOV      r0,r5
000012  f7fffffe          BL       Spi1WriteReadDWord
;;;68     	temp = Spi1WriteReadWord(idle_dat);
000016  4630              MOV      r0,r6
000018  f7fffffe          BL       Spi1WriteReadWord
00001c  4604              MOV      r4,r0
;;;69     	Spi1Select(UnSelect);
00001e  2000              MOVS     r0,#0
000020  f7fffffe          BL       Spi1Select
;;;70     	return temp;
000024  4620              MOV      r0,r4
;;;71     }
000026  bd70              POP      {r4-r6,pc}
;;;72     
                          ENDP


                          AREA ||i.w25qxx_readSR||, CODE, READONLY, ALIGN=1

                  w25qxx_readSR PROC
;;;19     //默认:0x00
;;;20     uint8_t w25qxx_readSR(void)
000000  b510              PUSH     {r4,lr}
;;;21     {
;;;22     	uint8_t byte = 0;
000002  2400              MOVS     r4,#0
;;;23     	Spi1Select(Select); //使能器件
000004  2001              MOVS     r0,#1
000006  f7fffffe          BL       Spi1Select
;;;24     	Spi1WriteReadByte(W25X_ReadStatusReg); //发送读取状态寄存器命令
00000a  2005              MOVS     r0,#5
00000c  f7fffffe          BL       Spi1WriteReadByte
;;;25     	byte = Spi1WriteReadByte(0Xff);		   //读取一个字节
000010  20ff              MOVS     r0,#0xff
000012  f7fffffe          BL       Spi1WriteReadByte
000016  4604              MOV      r4,r0
;;;26     	Spi1Select(UnSelect);
000018  2000              MOVS     r0,#0
00001a  f7fffffe          BL       Spi1Select
;;;27     	return byte;
00001e  4620              MOV      r0,r4
;;;28     }
000020  bd10              POP      {r4,pc}
;;;29     //写W25QXX状态寄存器
                          ENDP


                          AREA ||i.w25qxx_wait_busy||, CODE, READONLY, ALIGN=1

                  w25qxx_wait_busy PROC
;;;264    //等待空闲
;;;265    void w25qxx_wait_busy(void)
000000  b510              PUSH     {r4,lr}
;;;266    {
;;;267    	while ((w25qxx_readSR() & 0x01) == 0x01)
000002  bf00              NOP      
                  |L9.4|
000004  f7fffffe          BL       w25qxx_readSR
000008  f0000001          AND      r0,r0,#1
00000c  2800              CMP      r0,#0
00000e  d1f9              BNE      |L9.4|
;;;268    		; // 等待BUSY位清空
;;;269    }
000010  bd10              POP      {r4,pc}
;;;270    //进入掉电模式
                          ENDP


                          AREA ||i.w25qxx_wakeup||, CODE, READONLY, ALIGN=1

                  w25qxx_wakeup PROC
;;;278    //唤醒
;;;279    void w25qxx_wakeup(void)
000000  b510              PUSH     {r4,lr}
;;;280    {
;;;281    	Spi1Select(Select);						  //使能器件
000002  2001              MOVS     r0,#1
000004  f7fffffe          BL       Spi1Select
;;;282    	Spi1WriteReadByte(W25X_ReleasePowerDown); //  send W25X_PowerDown command 0xAB
000008  20ab              MOVS     r0,#0xab
00000a  f7fffffe          BL       Spi1WriteReadByte
;;;283    	Spi1Select(UnSelect);					  //取消片选
00000e  2000              MOVS     r0,#0
000010  f7fffffe          BL       Spi1Select
;;;284    	HAL_Delay(1);							  //等待TRES1
000014  2001              MOVS     r0,#1
000016  f7fffffe          BL       HAL_Delay
;;;285    }
00001a  bd10              POP      {r4,pc}
;;;286    
                          ENDP


                          AREA ||i.w25qxx_write||, CODE, READONLY, ALIGN=2

                  w25qxx_write PROC
;;;177    uint8_t w25qxx_buffer[4096];
;;;178    void w25qxx_write(uint8_t *pBuffer, uint32_t writeaddr, uint16_t numbytetowrite)
000000  e92d5ff0          PUSH     {r4-r12,lr}
;;;179    {
000004  4681              MOV      r9,r0
000006  460f              MOV      r7,r1
000008  4616              MOV      r6,r2
;;;180    	uint32_t secpos;
;;;181    	uint16_t secoff;
;;;182    	uint16_t secremain;
;;;183    	uint16_t i;
;;;184    	uint8_t *w25qxx_buf;
;;;185    	w25qxx_buf = w25qxx_buffer;
00000a  f8dfb0a8          LDR      r11,|L11.180|
;;;186    	secpos = writeaddr / 4096; //扇区地址
00000e  ea4f3817          LSR      r8,r7,#12
;;;187    	secoff = writeaddr % 4096; //在扇区内的偏移
000012  f3c70a0b          UBFX     r10,r7,#0,#12
;;;188    	secremain = 4096 - secoff; //扇区剩余空间大小
000016  f5ca5480          RSB      r4,r10,#0x1000
;;;189    	//printf("ad:%X,nb:%X\r\n",writeaddr,numbytetowrite);//测试用
;;;190    	if (numbytetowrite <= secremain)
00001a  42a6              CMP      r6,r4
00001c  dc00              BGT      |L11.32|
;;;191    		secremain = numbytetowrite; //不大于4096个字节
00001e  4634              MOV      r4,r6
                  |L11.32|
;;;192    	while (1)
000020  e044              B        |L11.172|
                  |L11.34|
;;;193    	{
;;;194    		w25qxx_read(w25qxx_buf, secpos * 4096, 4096); //读出整个扇区的内容
000022  ea4f3108          LSL      r1,r8,#12
000026  f44f5280          MOV      r2,#0x1000
00002a  4658              MOV      r0,r11
00002c  f7fffffe          BL       w25qxx_read
;;;195    		for (i = 0; i < secremain; i++)				  //校验数据
000030  2500              MOVS     r5,#0
000032  e008              B        |L11.70|
                  |L11.52|
;;;196    		{
;;;197    			if (w25qxx_buf[secoff + i] != 0XFF)
000034  eb0a0005          ADD      r0,r10,r5
000038  f81b0000          LDRB     r0,[r11,r0]
00003c  28ff              CMP      r0,#0xff
00003e  d000              BEQ      |L11.66|
;;;198    				break; //需要擦除
000040  e003              B        |L11.74|
                  |L11.66|
000042  1c68              ADDS     r0,r5,#1              ;195
000044  b285              UXTH     r5,r0                 ;195
                  |L11.70|
000046  42a5              CMP      r5,r4                 ;195
000048  dbf4              BLT      |L11.52|
                  |L11.74|
00004a  bf00              NOP      
;;;199    		}
;;;200    		if (i < secremain) //需要擦除
00004c  42a5              CMP      r5,r4
00004e  da16              BGE      |L11.126|
;;;201    		{
;;;202    			w25qxx_erase_sector(secpos);	//擦除这个扇区
000050  4640              MOV      r0,r8
000052  f7fffffe          BL       w25qxx_erase_sector
;;;203    			for (i = 0; i < secremain; i++) //复制
000056  2500              MOVS     r5,#0
000058  e007              B        |L11.106|
                  |L11.90|
;;;204    			{
;;;205    				w25qxx_buf[i + secoff] = pBuffer[i];
00005a  f8190005          LDRB     r0,[r9,r5]
00005e  eb05010a          ADD      r1,r5,r10
000062  f80b0001          STRB     r0,[r11,r1]
000066  1c68              ADDS     r0,r5,#1              ;203
000068  b285              UXTH     r5,r0                 ;203
                  |L11.106|
00006a  42a5              CMP      r5,r4                 ;203
00006c  dbf5              BLT      |L11.90|
;;;206    			}
;;;207    			w25qxx_write_nocheck(w25qxx_buf, secpos * 4096, 4096); //写入整个扇区
00006e  ea4f3108          LSL      r1,r8,#12
000072  f44f5280          MOV      r2,#0x1000
000076  4658              MOV      r0,r11
000078  f7fffffe          BL       w25qxx_write_nocheck
00007c  e004              B        |L11.136|
                  |L11.126|
;;;208    		}
;;;209    		else
;;;210    			w25qxx_write_nocheck(pBuffer, writeaddr, secremain); //写已经擦除了的,直接写入扇区剩余区间.
00007e  4622              MOV      r2,r4
000080  4639              MOV      r1,r7
000082  4648              MOV      r0,r9
000084  f7fffffe          BL       w25qxx_write_nocheck
                  |L11.136|
;;;211    		if (numbytetowrite == secremain)
000088  42a6              CMP      r6,r4
00008a  d100              BNE      |L11.142|
;;;212    			break; //写入结束了
00008c  e00f              B        |L11.174|
                  |L11.142|
;;;213    		else	   //写入未结束
;;;214    		{
;;;215    			secpos++;	//扇区地址增1
00008e  f1080801          ADD      r8,r8,#1
;;;216    			secoff = 0; //偏移位置为0
000092  f04f0a00          MOV      r10,#0
;;;217    
;;;218    			pBuffer += secremain;		 //指针偏移
000096  44a1              ADD      r9,r9,r4
;;;219    			writeaddr += secremain;		 //写地址偏移
000098  4427              ADD      r7,r7,r4
;;;220    			numbytetowrite -= secremain; //字节数递减
00009a  1b30              SUBS     r0,r6,r4
00009c  b286              UXTH     r6,r0
;;;221    			if (numbytetowrite > 4096)
00009e  f5b65f80          CMP      r6,#0x1000
0000a2  dd02              BLE      |L11.170|
;;;222    				secremain = 4096; //下一个扇区还是写不完
0000a4  f44f5480          MOV      r4,#0x1000
0000a8  e000              B        |L11.172|
                  |L11.170|
;;;223    			else
;;;224    				secremain = numbytetowrite; //下一个扇区可以写完了
0000aa  4634              MOV      r4,r6
                  |L11.172|
0000ac  e7b9              B        |L11.34|
                  |L11.174|
0000ae  bf00              NOP                            ;212
;;;225    		}
;;;226    	};
;;;227    }
0000b0  e8bd9ff0          POP      {r4-r12,pc}
;;;228    //擦除整个芯片
                          ENDP

                  |L11.180|
                          DCD      w25qxx_buffer

                          AREA ||i.w25qxx_writeSR||, CODE, READONLY, ALIGN=1

                  w25qxx_writeSR PROC
;;;30     //只有SPR,TB,BP2,BP1,BP0(bit 7,5,4,3,2)可以写!!!
;;;31     void w25qxx_writeSR(uint8_t sr)
000000  b510              PUSH     {r4,lr}
;;;32     {
000002  4604              MOV      r4,r0
;;;33     	Spi1Select(Select); //使能器件
000004  2001              MOVS     r0,#1
000006  f7fffffe          BL       Spi1Select
;;;34     	Spi1WriteReadByte(W25X_WriteStatusReg); //发送写取状态寄存器命令
00000a  2001              MOVS     r0,#1
00000c  f7fffffe          BL       Spi1WriteReadByte
;;;35     	Spi1WriteReadByte(sr);					//写入一个字节
000010  4620              MOV      r0,r4
000012  f7fffffe          BL       Spi1WriteReadByte
;;;36     	Spi1Select(UnSelect);
000016  2000              MOVS     r0,#0
000018  f7fffffe          BL       Spi1Select
;;;37     }
00001c  bd10              POP      {r4,pc}
;;;38     //W25QXX写使能
                          ENDP


                          AREA ||i.w25qxx_write_disable||, CODE, READONLY, ALIGN=1

                  w25qxx_write_disable PROC
;;;47     //将WEL清零
;;;48     void w25qxx_write_disable(void)
000000  b510              PUSH     {r4,lr}
;;;49     {
;;;50     	Spi1Select(Select); //使能器件
000002  2001              MOVS     r0,#1
000004  f7fffffe          BL       Spi1Select
;;;51     	Spi1WriteReadByte(W25X_WriteDisable); //发送写禁止指令
000008  2004              MOVS     r0,#4
00000a  f7fffffe          BL       Spi1WriteReadByte
;;;52     	Spi1Select(UnSelect);
00000e  2000              MOVS     r0,#0
000010  f7fffffe          BL       Spi1Select
;;;53     }
000014  bd10              POP      {r4,pc}
;;;54     //读取芯片ID
                          ENDP


                          AREA ||i.w25qxx_write_enable||, CODE, READONLY, ALIGN=1

                  w25qxx_write_enable PROC
;;;39     //将WEL置位
;;;40     void w25qxx_write_enable(void)
000000  b510              PUSH     {r4,lr}
;;;41     {
;;;42     	Spi1Select(Select); //使能器件
000002  2001              MOVS     r0,#1
000004  f7fffffe          BL       Spi1Select
;;;43     	Spi1WriteReadByte(W25X_WriteEnable); //发送写使能
000008  2006              MOVS     r0,#6
00000a  f7fffffe          BL       Spi1WriteReadByte
;;;44     	Spi1Select(UnSelect);
00000e  2000              MOVS     r0,#0
000010  f7fffffe          BL       Spi1Select
;;;45     }
000014  bd10              POP      {r4,pc}
;;;46     //W25QXX写禁止
                          ENDP


                          AREA ||i.w25qxx_write_nocheck||, CODE, READONLY, ALIGN=1

                  w25qxx_write_nocheck PROC
;;;146    //CHECK OK
;;;147    void w25qxx_write_nocheck(uint8_t *pbuffer, uint32_t writeaddr, uint16_t numbytetowrite)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;148    {
000004  4607              MOV      r7,r0
000006  460e              MOV      r6,r1
000008  4614              MOV      r4,r2
;;;149    	uint16_t pageremain;
;;;150    	pageremain = 256 - writeaddr % 256; //单页剩余的字节数
00000a  b2f0              UXTB     r0,r6
00000c  f5c07580          RSB      r5,r0,#0x100
;;;151    	if (numbytetowrite <= pageremain)
000010  42ac              CMP      r4,r5
000012  dc00              BGT      |L15.22|
;;;152    		pageremain = numbytetowrite; //不大于256个字节
000014  4625              MOV      r5,r4
                  |L15.22|
;;;153    	while (1)
000016  e012              B        |L15.62|
                  |L15.24|
;;;154    	{
;;;155    		w25qxx_write_page(pbuffer, writeaddr, pageremain);
000018  462a              MOV      r2,r5
00001a  4631              MOV      r1,r6
00001c  4638              MOV      r0,r7
00001e  f7fffffe          BL       w25qxx_write_page
;;;156    		if (numbytetowrite == pageremain)
000022  42ac              CMP      r4,r5
000024  d100              BNE      |L15.40|
;;;157    			break; //写入结束了
000026  e00b              B        |L15.64|
                  |L15.40|
;;;158    		else	   //numbytetowrite>pageremain
;;;159    		{
;;;160    			pbuffer += pageremain;
000028  442f              ADD      r7,r7,r5
;;;161    			writeaddr += pageremain;
00002a  442e              ADD      r6,r6,r5
;;;162    
;;;163    			numbytetowrite -= pageremain; //减去已经写入了的字节数
00002c  1b60              SUBS     r0,r4,r5
00002e  b284              UXTH     r4,r0
;;;164    			if (numbytetowrite > 256)
000030  f5b47f80          CMP      r4,#0x100
000034  dd02              BLE      |L15.60|
;;;165    				pageremain = 256; //一次可以写入256个字节
000036  f44f7580          MOV      r5,#0x100
00003a  e000              B        |L15.62|
                  |L15.60|
;;;166    			else
;;;167    				pageremain = numbytetowrite; //不够256个字节了
00003c  4625              MOV      r5,r4
                  |L15.62|
00003e  e7eb              B        |L15.24|
                  |L15.64|
000040  bf00              NOP                            ;157
;;;168    		}
;;;169    	};
;;;170    }
000042  e8bd81f0          POP      {r4-r8,pc}
;;;171    //写SPI FLASH
                          ENDP


                          AREA ||i.w25qxx_write_page||, CODE, READONLY, ALIGN=1

                  w25qxx_write_page PROC
;;;117    //numbytetowrite:要写入的字节数(最大256),该数不应该超过该页的剩余字节数!!!
;;;118    void w25qxx_write_page(uint8_t *pbuffer, uint32_t writeaddr, uint16_t numbytetowrite)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;119    {
000004  4606              MOV      r6,r0
000006  460c              MOV      r4,r1
000008  4617              MOV      r7,r2
;;;120    	uint16_t i;
;;;121    	w25qxx_write_enable(); //SET WEL
00000a  f7fffffe          BL       w25qxx_write_enable
;;;122    	Spi1Select(Select);	   //使能器件	
00000e  2001              MOVS     r0,#1
000010  f7fffffe          BL       Spi1Select
;;;123    //	writeaddr <<= 8;
;;;124    //	writeaddr |= W25X_PageProgram;
;;;125    	//Spi1WriteDWord(writeaddr);
;;;126    	Spi1WriteReadByte(W25X_PageProgram);
000014  2002              MOVS     r0,#2
000016  f7fffffe          BL       Spi1WriteReadByte
;;;127    	Spi1WriteReadByte(writeaddr >> 16);
00001a  f3c44007          UBFX     r0,r4,#16,#8
00001e  f7fffffe          BL       Spi1WriteReadByte
;;;128    	Spi1WriteReadByte(writeaddr >> 8);
000022  f3c42007          UBFX     r0,r4,#8,#8
000026  f7fffffe          BL       Spi1WriteReadByte
;;;129    	Spi1WriteReadByte(writeaddr);
00002a  b2e0              UXTB     r0,r4
00002c  f7fffffe          BL       Spi1WriteReadByte
;;;130    	
;;;131    	for (i = 0; i < numbytetowrite; i++)
000030  2500              MOVS     r5,#0
000032  e004              B        |L16.62|
                  |L16.52|
;;;132    	{
;;;133    		Spi1WriteReadByte(pbuffer[i]); //循环写数
000034  5d70              LDRB     r0,[r6,r5]
000036  f7fffffe          BL       Spi1WriteReadByte
00003a  1c68              ADDS     r0,r5,#1              ;131
00003c  b285              UXTH     r5,r0                 ;131
                  |L16.62|
00003e  42bd              CMP      r5,r7                 ;131
000040  dbf8              BLT      |L16.52|
;;;134    	}
;;;135    	
;;;136    	Spi1Select(UnSelect); //取消片选
000042  2000              MOVS     r0,#0
000044  f7fffffe          BL       Spi1Select
;;;137    	w25qxx_wait_busy();	  //等待写入结束
000048  f7fffffe          BL       w25qxx_wait_busy
;;;138    }
00004c  e8bd81f0          POP      {r4-r8,pc}
;;;139    //无检验写SPI FLASH
                          ENDP


                          AREA ||.bss||, DATA, NOINIT, ALIGN=0

                  w25qxx_buffer
                          %        4096

                          AREA ||.constdata||, DATA, READONLY, ALIGN=0

                  CHANNEL_OFFSET_TAB
000000  081c3044          DCB      0x08,0x1c,0x30,0x44
000004  586c80            DCB      0x58,0x6c,0x80

;*** Start embedded assembler ***

#line 1 "..\\Src\\w25qxx.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___8_w25qxx_c_5e8b76a9____REV16|
#line 463 "../Drivers/CMSIS/Include/cmsis_armcc.h"
|__asm___8_w25qxx_c_5e8b76a9____REV16| PROC
#line 464

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___8_w25qxx_c_5e8b76a9____REVSH|
#line 478
|__asm___8_w25qxx_c_5e8b76a9____REVSH| PROC
#line 479

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___8_w25qxx_c_5e8b76a9____RRX|
#line 665
|__asm___8_w25qxx_c_5e8b76a9____RRX| PROC
#line 666

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
