; generated by Component: ARM Compiler 5.06 update 7 (build 960) Tool: ArmCC [4d365d]
; commandline ArmCC [--c99 --split_sections --debug -c --asm --interleave -otemplate\stm32f1xx_hal_gpio.o --asm_dir=./ --list_dir=--list --depend=template\stm32f1xx_hal_gpio.d --cpu=Cortex-M3 --apcs=interwork -O0 --diag_suppress=9931 -I../Inc -I../Drivers/STM32F1xx_HAL_Driver/Inc -I../Drivers/STM32F1xx_HAL_Driver/Inc/Legacy -I../Middlewares/Third_Party/FatFs/src -I../Drivers/CMSIS/Device/ST/STM32F1xx/Include -I../Drivers/CMSIS/Include -I.\RTE\_Template -ID:\Keil_v5\Pack\ARM\CMSIS\5.7.0\CMSIS\Core\Include -ID:\Keil_v5\Pack\Keil\STM32F1xx_DFP\2.3.0\Device\Include -D__MICROLIB -D__UVISION_VERSION=533 -D_RTE_ -DSTM32F10X_MD -D_RTE_ -DUSE_FULL_LL_DRIVER -DUSE_HAL_DRIVER -DSTM32F103xB --signed_chars --omf_browse=template\stm32f1xx_hal_gpio.crf ../Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_gpio.c]
                          THUMB

                          AREA ||i.HAL_GPIO_DeInit||, CODE, READONLY, ALIGN=2

                  HAL_GPIO_DeInit PROC
;;;350      */
;;;351    void HAL_GPIO_DeInit(GPIO_TypeDef  *GPIOx, uint32_t GPIO_Pin)
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;352    {
000004  4604              MOV      r4,r0
000006  460f              MOV      r7,r1
;;;353      uint32_t position = 0x00u;
000008  2500              MOVS     r5,#0
;;;354      uint32_t iocurrent;
;;;355      uint32_t tmp;
;;;356      __IO uint32_t *configregister; /* Store the address of CRL or CRH register based on pin number */
;;;357      uint32_t registeroffset;
;;;358    
;;;359      /* Check the parameters */
;;;360      assert_param(IS_GPIO_ALL_INSTANCE(GPIOx));
00000a  4849              LDR      r0,|L1.304|
00000c  4284              CMP      r4,r0
00000e  d00b              BEQ      |L1.40|
000010  4848              LDR      r0,|L1.308|
000012  4284              CMP      r4,r0
000014  d008              BEQ      |L1.40|
000016  4848              LDR      r0,|L1.312|
000018  4284              CMP      r4,r0
00001a  d005              BEQ      |L1.40|
00001c  4847              LDR      r0,|L1.316|
00001e  4284              CMP      r4,r0
000020  d002              BEQ      |L1.40|
000022  4847              LDR      r0,|L1.320|
000024  4284              CMP      r4,r0
000026  d100              BNE      |L1.42|
                  |L1.40|
000028  e004              B        |L1.52|
                  |L1.42|
00002a  f44f71b4          MOV      r1,#0x168
00002e  a045              ADR      r0,|L1.324|
000030  f7fffffe          BL       assert_failed
                  |L1.52|
;;;361      assert_param(IS_GPIO_PIN(GPIO_Pin));
000034  b2b8              UXTH     r0,r7
000036  b118              CBZ      r0,|L1.64|
000038  0c38              LSRS     r0,r7,#16
00003a  0400              LSLS     r0,r0,#16
00003c  b900              CBNZ     r0,|L1.64|
00003e  e004              B        |L1.74|
                  |L1.64|
000040  f2401169          MOV      r1,#0x169
000044  a03f              ADR      r0,|L1.324|
000046  f7fffffe          BL       assert_failed
                  |L1.74|
;;;362    
;;;363      /* Configure the port pins */
;;;364      while ((GPIO_Pin >> position) != 0u)
00004a  e06a              B        |L1.290|
                  |L1.76|
;;;365      {
;;;366        /* Get current io position */
;;;367        iocurrent = (GPIO_Pin) & (1uL << position);
00004c  2001              MOVS     r0,#1
00004e  40a8              LSLS     r0,r0,r5
000050  ea000607          AND      r6,r0,r7
;;;368    
;;;369        if (iocurrent)
000054  2e00              CMP      r6,#0
000056  d063              BEQ      |L1.288|
;;;370        {
;;;371          /*------------------------- EXTI Mode Configuration --------------------*/
;;;372          /* Clear the External Interrupt or Event for the current IO */
;;;373    
;;;374          tmp = AFIO->EXTICR[position >> 2u];
000058  4849              LDR      r0,|L1.384|
00005a  08a9              LSRS     r1,r5,#2
00005c  f8508021          LDR      r8,[r0,r1,LSL #2]
;;;375          tmp &= 0x0FuL << (4u * (position & 0x03u));
000060  07a8              LSLS     r0,r5,#30
000062  0f01              LSRS     r1,r0,#28
000064  200f              MOVS     r0,#0xf
000066  4088              LSLS     r0,r0,r1
000068  ea000808          AND      r8,r0,r8
;;;376          if (tmp == (GPIO_GET_INDEX(GPIOx) << (4u * (position & 0x03u))))
00006c  4830              LDR      r0,|L1.304|
00006e  4284              CMP      r4,r0
000070  d101              BNE      |L1.118|
000072  2000              MOVS     r0,#0
000074  e00f              B        |L1.150|
                  |L1.118|
000076  482f              LDR      r0,|L1.308|
000078  4284              CMP      r4,r0
00007a  d101              BNE      |L1.128|
00007c  2001              MOVS     r0,#1
00007e  e00a              B        |L1.150|
                  |L1.128|
000080  482d              LDR      r0,|L1.312|
000082  4284              CMP      r4,r0
000084  d101              BNE      |L1.138|
000086  2002              MOVS     r0,#2
000088  e005              B        |L1.150|
                  |L1.138|
00008a  482c              LDR      r0,|L1.316|
00008c  4284              CMP      r4,r0
00008e  d101              BNE      |L1.148|
000090  2003              MOVS     r0,#3
000092  e000              B        |L1.150|
                  |L1.148|
000094  2004              MOVS     r0,#4
                  |L1.150|
000096  07a9              LSLS     r1,r5,#30
000098  0f09              LSRS     r1,r1,#28
00009a  4088              LSLS     r0,r0,r1
00009c  4540              CMP      r0,r8
00009e  d122              BNE      |L1.230|
;;;377          {
;;;378            tmp = 0x0FuL << (4u * (position & 0x03u));
0000a0  07a8              LSLS     r0,r5,#30
0000a2  0f01              LSRS     r1,r0,#28
0000a4  200f              MOVS     r0,#0xf
0000a6  fa00f801          LSL      r8,r0,r1
;;;379            CLEAR_BIT(AFIO->EXTICR[position >> 2u], tmp);
0000aa  4835              LDR      r0,|L1.384|
0000ac  08a9              LSRS     r1,r5,#2
0000ae  f8500021          LDR      r0,[r0,r1,LSL #2]
0000b2  ea200008          BIC      r0,r0,r8
0000b6  4932              LDR      r1,|L1.384|
0000b8  08aa              LSRS     r2,r5,#2
0000ba  f8410022          STR      r0,[r1,r2,LSL #2]
;;;380    
;;;381            /* Clear EXTI line configuration */
;;;382            CLEAR_BIT(EXTI->IMR, (uint32_t)iocurrent);
0000be  4831              LDR      r0,|L1.388|
0000c0  6800              LDR      r0,[r0,#0]
0000c2  43b0              BICS     r0,r0,r6
0000c4  492f              LDR      r1,|L1.388|
0000c6  6008              STR      r0,[r1,#0]
;;;383            CLEAR_BIT(EXTI->EMR, (uint32_t)iocurrent);
0000c8  1d08              ADDS     r0,r1,#4
0000ca  6800              LDR      r0,[r0,#0]
0000cc  43b0              BICS     r0,r0,r6
0000ce  1d09              ADDS     r1,r1,#4
0000d0  6008              STR      r0,[r1,#0]
;;;384    
;;;385            /* Clear Rising Falling edge configuration */
;;;386            CLEAR_BIT(EXTI->RTSR, (uint32_t)iocurrent);
0000d2  1d08              ADDS     r0,r1,#4
0000d4  6800              LDR      r0,[r0,#0]
0000d6  43b0              BICS     r0,r0,r6
0000d8  1d09              ADDS     r1,r1,#4
0000da  6008              STR      r0,[r1,#0]
;;;387            CLEAR_BIT(EXTI->FTSR, (uint32_t)iocurrent);
0000dc  1d08              ADDS     r0,r1,#4
0000de  6800              LDR      r0,[r0,#0]
0000e0  43b0              BICS     r0,r0,r6
0000e2  1d09              ADDS     r1,r1,#4
0000e4  6008              STR      r0,[r1,#0]
                  |L1.230|
;;;388          }
;;;389          /*------------------------- GPIO Mode Configuration --------------------*/
;;;390          /* Check if the current bit belongs to first half or last half of the pin count number
;;;391           in order to address CRH or CRL register */
;;;392          configregister = (iocurrent < GPIO_PIN_8) ? &GPIOx->CRL     : &GPIOx->CRH;
0000e6  2eff              CMP      r6,#0xff
0000e8  d801              BHI      |L1.238|
0000ea  4620              MOV      r0,r4
0000ec  e000              B        |L1.240|
                  |L1.238|
0000ee  1d20              ADDS     r0,r4,#4
                  |L1.240|
0000f0  4681              MOV      r9,r0
;;;393          registeroffset = (iocurrent < GPIO_PIN_8) ? (position << 2u) : ((position - 8u) << 2u);
0000f2  2eff              CMP      r6,#0xff
0000f4  d801              BHI      |L1.250|
0000f6  00a8              LSLS     r0,r5,#2
0000f8  e002              B        |L1.256|
                  |L1.250|
0000fa  f1a50008          SUB      r0,r5,#8
0000fe  0080              LSLS     r0,r0,#2
                  |L1.256|
000100  4682              MOV      r10,r0
;;;394    
;;;395          /* CRL/CRH default value is floating input(0x04) shifted to correct position */
;;;396          MODIFY_REG(*configregister, ((GPIO_CRL_MODE0 | GPIO_CRL_CNF0) << registeroffset), GPIO_CRL_CNF0_0 << registeroffset);
000102  f8d90000          LDR      r0,[r9,#0]
000106  210f              MOVS     r1,#0xf
000108  fa01f10a          LSL      r1,r1,r10
00010c  4388              BICS     r0,r0,r1
00010e  2104              MOVS     r1,#4
000110  fa01f10a          LSL      r1,r1,r10
000114  4308              ORRS     r0,r0,r1
000116  f8c90000          STR      r0,[r9,#0]
;;;397    
;;;398          /* ODR default value is 0 */
;;;399          CLEAR_BIT(GPIOx->ODR, iocurrent);
00011a  68e0              LDR      r0,[r4,#0xc]
00011c  43b0              BICS     r0,r0,r6
00011e  60e0              STR      r0,[r4,#0xc]
                  |L1.288|
;;;400        }
;;;401    
;;;402        position++;
000120  1c6d              ADDS     r5,r5,#1
                  |L1.290|
000122  fa27f005          LSR      r0,r7,r5              ;364
000126  2800              CMP      r0,#0                 ;364
000128  d190              BNE      |L1.76|
;;;403      }
;;;404    }
00012a  e8bd87f0          POP      {r4-r10,pc}
;;;405    
                          ENDP

00012e  0000              DCW      0x0000
                  |L1.304|
                          DCD      0x40010800
                  |L1.308|
                          DCD      0x40010c00
                  |L1.312|
                          DCD      0x40011000
                  |L1.316|
                          DCD      0x40011400
                  |L1.320|
                          DCD      0x40011800
                  |L1.324|
000144  2e2e2f44          DCB      "../Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_gpio."
000148  72697665
00014c  72732f53
000150  544d3332
000154  46317878
000158  5f48414c
00015c  5f447269
000160  7665722f
000164  5372632f
000168  73746d33
00016c  32663178
000170  785f6861
000174  6c5f6770
000178  696f2e  
00017b  6300              DCB      "c",0
00017d  00                DCB      0
00017e  00                DCB      0
00017f  00                DCB      0
                  |L1.384|
                          DCD      0x40010008
                  |L1.388|
                          DCD      0x40010400

                          AREA ||i.HAL_GPIO_EXTI_Callback||, CODE, READONLY, ALIGN=1

                  HAL_GPIO_EXTI_Callback PROC
;;;560      */
;;;561    __weak void HAL_GPIO_EXTI_Callback(uint16_t GPIO_Pin)
000000  4770              BX       lr
;;;562    {
;;;563      /* Prevent unused argument(s) compilation warning */
;;;564      UNUSED(GPIO_Pin);
;;;565      /* NOTE: This function Should not be modified, when the callback is needed,
;;;566               the HAL_GPIO_EXTI_Callback could be implemented in the user file
;;;567       */
;;;568    }
;;;569    
                          ENDP


                          AREA ||i.HAL_GPIO_EXTI_IRQHandler||, CODE, READONLY, ALIGN=2

                  HAL_GPIO_EXTI_IRQHandler PROC
;;;545      */
;;;546    void HAL_GPIO_EXTI_IRQHandler(uint16_t GPIO_Pin)
000000  b510              PUSH     {r4,lr}
;;;547    {
000002  4604              MOV      r4,r0
;;;548      /* EXTI line interrupt detected */
;;;549      if (__HAL_GPIO_EXTI_GET_IT(GPIO_Pin) != 0x00u)
000004  4804              LDR      r0,|L3.24|
000006  6800              LDR      r0,[r0,#0]
000008  4020              ANDS     r0,r0,r4
00000a  b120              CBZ      r0,|L3.22|
;;;550      {
;;;551        __HAL_GPIO_EXTI_CLEAR_IT(GPIO_Pin);
00000c  4802              LDR      r0,|L3.24|
00000e  6004              STR      r4,[r0,#0]
;;;552        HAL_GPIO_EXTI_Callback(GPIO_Pin);
000010  4620              MOV      r0,r4
000012  f7fffffe          BL       HAL_GPIO_EXTI_Callback
                  |L3.22|
;;;553      }
;;;554    }
000016  bd10              POP      {r4,pc}
;;;555    
                          ENDP

                  |L3.24|
                          DCD      0x40010414

                          AREA ||i.HAL_GPIO_Init||, CODE, READONLY, ALIGN=2

                  HAL_GPIO_Init PROC
;;;177      */
;;;178    void HAL_GPIO_Init(GPIO_TypeDef  *GPIOx, GPIO_InitTypeDef *GPIO_Init)
000000  e92d5ffc          PUSH     {r2-r12,lr}
;;;179    {
000004  4605              MOV      r5,r0
000006  460c              MOV      r4,r1
;;;180      uint32_t position = 0x00u;
000008  2700              MOVS     r7,#0
;;;181      uint32_t ioposition;
;;;182      uint32_t iocurrent;
;;;183      uint32_t temp;
;;;184      uint32_t config = 0x00u;
00000a  2000              MOVS     r0,#0
00000c  9001              STR      r0,[sp,#4]
;;;185      __IO uint32_t *configregister; /* Store the address of CRL or CRH register based on pin number */
;;;186      uint32_t registeroffset;       /* offset used during computation of CNF and MODE bits placement inside CRL or CRH register */
;;;187    
;;;188      /* Check the parameters */
;;;189      assert_param(IS_GPIO_ALL_INSTANCE(GPIOx));
00000e  48db              LDR      r0,|L4.892|
000010  4285              CMP      r5,r0
000012  d00b              BEQ      |L4.44|
000014  48da              LDR      r0,|L4.896|
000016  4285              CMP      r5,r0
000018  d008              BEQ      |L4.44|
00001a  48da              LDR      r0,|L4.900|
00001c  4285              CMP      r5,r0
00001e  d005              BEQ      |L4.44|
000020  48d9              LDR      r0,|L4.904|
000022  4285              CMP      r5,r0
000024  d002              BEQ      |L4.44|
000026  48d9              LDR      r0,|L4.908|
000028  4285              CMP      r5,r0
00002a  d100              BNE      |L4.46|
                  |L4.44|
00002c  e003              B        |L4.54|
                  |L4.46|
00002e  21bd              MOVS     r1,#0xbd
000030  a0d7              ADR      r0,|L4.912|
000032  f7fffffe          BL       assert_failed
                  |L4.54|
;;;190      assert_param(IS_GPIO_PIN(GPIO_Init->Pin));
000036  8820              LDRH     r0,[r4,#0]
000038  b280              UXTH     r0,r0
00003a  b120              CBZ      r0,|L4.70|
00003c  6820              LDR      r0,[r4,#0]
00003e  f36f000f          BFC      r0,#0,#16
000042  b900              CBNZ     r0,|L4.70|
000044  e003              B        |L4.78|
                  |L4.70|
000046  21be              MOVS     r1,#0xbe
000048  a0d1              ADR      r0,|L4.912|
00004a  f7fffffe          BL       assert_failed
                  |L4.78|
;;;191      assert_param(IS_GPIO_MODE(GPIO_Init->Mode));
00004e  6860              LDR      r0,[r4,#4]
000050  b330              CBZ      r0,|L4.160|
000052  6860              LDR      r0,[r4,#4]
000054  2801              CMP      r0,#1
000056  d023              BEQ      |L4.160|
000058  6860              LDR      r0,[r4,#4]
00005a  2811              CMP      r0,#0x11
00005c  d020              BEQ      |L4.160|
00005e  6860              LDR      r0,[r4,#4]
000060  2802              CMP      r0,#2
000062  d01d              BEQ      |L4.160|
000064  6860              LDR      r0,[r4,#4]
000066  2812              CMP      r0,#0x12
000068  d01a              BEQ      |L4.160|
00006a  49d8              LDR      r1,|L4.972|
00006c  6860              LDR      r0,[r4,#4]
00006e  4288              CMP      r0,r1
000070  d016              BEQ      |L4.160|
000072  49d7              LDR      r1,|L4.976|
000074  6860              LDR      r0,[r4,#4]
000076  4288              CMP      r0,r1
000078  d012              BEQ      |L4.160|
00007a  49d6              LDR      r1,|L4.980|
00007c  6860              LDR      r0,[r4,#4]
00007e  4288              CMP      r0,r1
000080  d00e              BEQ      |L4.160|
000082  49d5              LDR      r1,|L4.984|
000084  6860              LDR      r0,[r4,#4]
000086  4288              CMP      r0,r1
000088  d00a              BEQ      |L4.160|
00008a  49d4              LDR      r1,|L4.988|
00008c  6860              LDR      r0,[r4,#4]
00008e  4288              CMP      r0,r1
000090  d006              BEQ      |L4.160|
000092  49d3              LDR      r1,|L4.992|
000094  6860              LDR      r0,[r4,#4]
000096  4288              CMP      r0,r1
000098  d002              BEQ      |L4.160|
00009a  6860              LDR      r0,[r4,#4]
00009c  2803              CMP      r0,#3
00009e  d100              BNE      |L4.162|
                  |L4.160|
0000a0  e003              B        |L4.170|
                  |L4.162|
0000a2  21bf              MOVS     r1,#0xbf
0000a4  a0ba              ADR      r0,|L4.912|
0000a6  f7fffffe          BL       assert_failed
                  |L4.170|
;;;192    
;;;193      /* Configure the port pins */
;;;194      while (((GPIO_Init->Pin) >> position) != 0x00u)
0000aa  e160              B        |L4.878|
                  |L4.172|
;;;195      {
;;;196        /* Get the IO position */
;;;197        ioposition = (0x01uL << position);
0000ac  2001              MOVS     r0,#1
0000ae  fa00f807          LSL      r8,r0,r7
;;;198    
;;;199        /* Get the current IO position */
;;;200        iocurrent = (uint32_t)(GPIO_Init->Pin) & ioposition;
0000b2  6820              LDR      r0,[r4,#0]
0000b4  ea000608          AND      r6,r0,r8
;;;201    
;;;202        if (iocurrent == ioposition)
0000b8  4546              CMP      r6,r8
0000ba  d16f              BNE      |L4.412|
;;;203        {
;;;204          /* Check the Alternate function parameters */
;;;205          assert_param(IS_GPIO_AF_INSTANCE(GPIOx));
0000bc  48af              LDR      r0,|L4.892|
0000be  4285              CMP      r5,r0
0000c0  d00b              BEQ      |L4.218|
0000c2  48af              LDR      r0,|L4.896|
0000c4  4285              CMP      r5,r0
0000c6  d008              BEQ      |L4.218|
0000c8  48ae              LDR      r0,|L4.900|
0000ca  4285              CMP      r5,r0
0000cc  d005              BEQ      |L4.218|
0000ce  48ae              LDR      r0,|L4.904|
0000d0  4285              CMP      r5,r0
0000d2  d002              BEQ      |L4.218|
0000d4  48ad              LDR      r0,|L4.908|
0000d6  4285              CMP      r5,r0
0000d8  d100              BNE      |L4.220|
                  |L4.218|
0000da  e003              B        |L4.228|
                  |L4.220|
0000dc  21cd              MOVS     r1,#0xcd
0000de  a0ac              ADR      r0,|L4.912|
0000e0  f7fffffe          BL       assert_failed
                  |L4.228|
;;;206    
;;;207          /* Based on the required mode, filling config variable with MODEy[1:0] and CNFy[3:2] corresponding bits */
;;;208          switch (GPIO_Init->Mode)
0000e4  4ab9              LDR      r2,|L4.972|
0000e6  6860              LDR      r0,[r4,#4]
0000e8  1a81              SUBS     r1,r0,r2
0000ea  4290              CMP      r0,r2
0000ec  d06a              BEQ      |L4.452|
0000ee  dc0e              BGT      |L4.270|
0000f0  2803              CMP      r0,#3
0000f2  d075              BEQ      |L4.480|
0000f4  dc06              BGT      |L4.260|
0000f6  2800              CMP      r0,#0
0000f8  d063              BEQ      |L4.450|
0000fa  2801              CMP      r0,#1
0000fc  d019              BEQ      |L4.306|
0000fe  2802              CMP      r0,#2
                  |L4.256|
000100  d16f              BNE      |L4.482|
000102  e039              B        |L4.376|
                  |L4.260|
000104  2811              CMP      r0,#0x11
000106  d025              BEQ      |L4.340|
000108  2812              CMP      r0,#0x12
00010a  d1f9              BNE      |L4.256|
00010c  e047              B        |L4.414|
                  |L4.270|
00010e  f5b11f88          CMP      r1,#0x110000
000112  d05b              BEQ      |L4.460|
000114  dc06              BGT      |L4.292|
000116  f5b13f80          CMP      r1,#0x10000
00011a  d056              BEQ      |L4.458|
00011c  f5b11f80          CMP      r1,#0x100000
000120  d179              BNE      |L4.534|
000122  e050              B        |L4.454|
                  |L4.292|
000124  f5b11f00          CMP      r1,#0x200000
000128  d04e              BEQ      |L4.456|
00012a  f5b11f04          CMP      r1,#0x210000
00012e  d172              BNE      |L4.534|
000130  e04d              B        |L4.462|
                  |L4.306|
;;;209          {
;;;210            /* If we are configuring the pin in OUTPUT push-pull mode */
;;;211            case GPIO_MODE_OUTPUT_PP:
;;;212              /* Check the GPIO speed parameter */
;;;213              assert_param(IS_GPIO_SPEED(GPIO_Init->Speed));
000132  68e0              LDR      r0,[r4,#0xc]
000134  2802              CMP      r0,#2
000136  d005              BEQ      |L4.324|
000138  68e0              LDR      r0,[r4,#0xc]
00013a  2801              CMP      r0,#1
00013c  d002              BEQ      |L4.324|
00013e  68e0              LDR      r0,[r4,#0xc]
000140  2803              CMP      r0,#3
000142  d100              BNE      |L4.326|
                  |L4.324|
000144  e003              B        |L4.334|
                  |L4.326|
000146  21d5              MOVS     r1,#0xd5
000148  a091              ADR      r0,|L4.912|
00014a  f7fffffe          BL       assert_failed
                  |L4.334|
;;;214              config = GPIO_Init->Speed + GPIO_CR_CNF_GP_OUTPUT_PP;
00014e  68e0              LDR      r0,[r4,#0xc]
000150  9001              STR      r0,[sp,#4]
;;;215              break;
000152  e061              B        |L4.536|
                  |L4.340|
;;;216    
;;;217            /* If we are configuring the pin in OUTPUT open-drain mode */
;;;218            case GPIO_MODE_OUTPUT_OD:
;;;219              /* Check the GPIO speed parameter */
;;;220              assert_param(IS_GPIO_SPEED(GPIO_Init->Speed));
000154  68e0              LDR      r0,[r4,#0xc]
000156  2802              CMP      r0,#2
000158  d005              BEQ      |L4.358|
00015a  68e0              LDR      r0,[r4,#0xc]
00015c  2801              CMP      r0,#1
00015e  d002              BEQ      |L4.358|
000160  68e0              LDR      r0,[r4,#0xc]
000162  2803              CMP      r0,#3
000164  d100              BNE      |L4.360|
                  |L4.358|
000166  e003              B        |L4.368|
                  |L4.360|
000168  21dc              MOVS     r1,#0xdc
00016a  a089              ADR      r0,|L4.912|
00016c  f7fffffe          BL       assert_failed
                  |L4.368|
;;;221              config = GPIO_Init->Speed + GPIO_CR_CNF_GP_OUTPUT_OD;
000170  68e0              LDR      r0,[r4,#0xc]
000172  1d00              ADDS     r0,r0,#4
000174  9001              STR      r0,[sp,#4]
;;;222              break;
000176  e04f              B        |L4.536|
                  |L4.376|
;;;223    
;;;224            /* If we are configuring the pin in ALTERNATE FUNCTION push-pull mode */
;;;225            case GPIO_MODE_AF_PP:
;;;226              /* Check the GPIO speed parameter */
;;;227              assert_param(IS_GPIO_SPEED(GPIO_Init->Speed));
000178  68e0              LDR      r0,[r4,#0xc]
00017a  2802              CMP      r0,#2
00017c  d005              BEQ      |L4.394|
00017e  68e0              LDR      r0,[r4,#0xc]
000180  2801              CMP      r0,#1
000182  d002              BEQ      |L4.394|
000184  68e0              LDR      r0,[r4,#0xc]
000186  2803              CMP      r0,#3
000188  d100              BNE      |L4.396|
                  |L4.394|
00018a  e003              B        |L4.404|
                  |L4.396|
00018c  21e3              MOVS     r1,#0xe3
00018e  a080              ADR      r0,|L4.912|
000190  f7fffffe          BL       assert_failed
                  |L4.404|
;;;228              config = GPIO_Init->Speed + GPIO_CR_CNF_AF_OUTPUT_PP;
000194  68e0              LDR      r0,[r4,#0xc]
000196  3008              ADDS     r0,r0,#8
000198  9001              STR      r0,[sp,#4]
;;;229              break;
00019a  e03d              B        |L4.536|
                  |L4.412|
00019c  e0dc              B        |L4.856|
                  |L4.414|
;;;230    
;;;231            /* If we are configuring the pin in ALTERNATE FUNCTION open-drain mode */
;;;232            case GPIO_MODE_AF_OD:
;;;233              /* Check the GPIO speed parameter */
;;;234              assert_param(IS_GPIO_SPEED(GPIO_Init->Speed));
00019e  68e0              LDR      r0,[r4,#0xc]
0001a0  2802              CMP      r0,#2
0001a2  d005              BEQ      |L4.432|
0001a4  68e0              LDR      r0,[r4,#0xc]
0001a6  2801              CMP      r0,#1
0001a8  d002              BEQ      |L4.432|
0001aa  68e0              LDR      r0,[r4,#0xc]
0001ac  2803              CMP      r0,#3
0001ae  d100              BNE      |L4.434|
                  |L4.432|
0001b0  e003              B        |L4.442|
                  |L4.434|
0001b2  21ea              MOVS     r1,#0xea
0001b4  a076              ADR      r0,|L4.912|
0001b6  f7fffffe          BL       assert_failed
                  |L4.442|
;;;235              config = GPIO_Init->Speed + GPIO_CR_CNF_AF_OUTPUT_OD;
0001ba  68e0              LDR      r0,[r4,#0xc]
0001bc  300c              ADDS     r0,r0,#0xc
0001be  9001              STR      r0,[sp,#4]
;;;236              break;
0001c0  e02a              B        |L4.536|
                  |L4.450|
;;;237    
;;;238            /* If we are configuring the pin in INPUT (also applicable to EVENT and IT mode) */
;;;239            case GPIO_MODE_INPUT:
;;;240            case GPIO_MODE_IT_RISING:
0001c2  bf00              NOP      
                  |L4.452|
;;;241            case GPIO_MODE_IT_FALLING:
0001c4  bf00              NOP      
                  |L4.454|
;;;242            case GPIO_MODE_IT_RISING_FALLING:
0001c6  bf00              NOP      
                  |L4.456|
;;;243            case GPIO_MODE_EVT_RISING:
0001c8  bf00              NOP      
                  |L4.458|
;;;244            case GPIO_MODE_EVT_FALLING:
0001ca  bf00              NOP      
                  |L4.460|
;;;245            case GPIO_MODE_EVT_RISING_FALLING:
0001cc  bf00              NOP      
                  |L4.462|
;;;246              /* Check the GPIO pull parameter */
;;;247              assert_param(IS_GPIO_PULL(GPIO_Init->Pull));
0001ce  68a0              LDR      r0,[r4,#8]
0001d0  b128              CBZ      r0,|L4.478|
0001d2  68a0              LDR      r0,[r4,#8]
0001d4  2801              CMP      r0,#1
0001d6  d002              BEQ      |L4.478|
0001d8  68a0              LDR      r0,[r4,#8]
0001da  2802              CMP      r0,#2
0001dc  d102              BNE      |L4.484|
                  |L4.478|
0001de  e005              B        |L4.492|
                  |L4.480|
0001e0  e016              B        |L4.528|
                  |L4.482|
0001e2  e018              B        |L4.534|
                  |L4.484|
0001e4  21f7              MOVS     r1,#0xf7
0001e6  a06a              ADR      r0,|L4.912|
0001e8  f7fffffe          BL       assert_failed
                  |L4.492|
;;;248              if (GPIO_Init->Pull == GPIO_NOPULL)
0001ec  68a0              LDR      r0,[r4,#8]
0001ee  b910              CBNZ     r0,|L4.502|
;;;249              {
;;;250                config = GPIO_CR_MODE_INPUT + GPIO_CR_CNF_INPUT_FLOATING;
0001f0  2004              MOVS     r0,#4
0001f2  9001              STR      r0,[sp,#4]
0001f4  e00b              B        |L4.526|
                  |L4.502|
;;;251              }
;;;252              else if (GPIO_Init->Pull == GPIO_PULLUP)
0001f6  68a0              LDR      r0,[r4,#8]
0001f8  2801              CMP      r0,#1
0001fa  d104              BNE      |L4.518|
;;;253              {
;;;254                config = GPIO_CR_MODE_INPUT + GPIO_CR_CNF_INPUT_PU_PD;
0001fc  2008              MOVS     r0,#8
0001fe  9001              STR      r0,[sp,#4]
;;;255    
;;;256                /* Set the corresponding ODR bit */
;;;257                GPIOx->BSRR = ioposition;
000200  f8c58010          STR      r8,[r5,#0x10]
000204  e003              B        |L4.526|
                  |L4.518|
;;;258              }
;;;259              else /* GPIO_PULLDOWN */
;;;260              {
;;;261                config = GPIO_CR_MODE_INPUT + GPIO_CR_CNF_INPUT_PU_PD;
000206  2008              MOVS     r0,#8
000208  9001              STR      r0,[sp,#4]
;;;262    
;;;263                /* Reset the corresponding ODR bit */
;;;264                GPIOx->BRR = ioposition;
00020a  f8c58014          STR      r8,[r5,#0x14]
                  |L4.526|
;;;265              }
;;;266              break;
00020e  e003              B        |L4.536|
                  |L4.528|
;;;267    
;;;268            /* If we are configuring the pin in INPUT analog mode */
;;;269            case GPIO_MODE_ANALOG:
;;;270              config = GPIO_CR_MODE_INPUT + GPIO_CR_CNF_ANALOG;
000210  2000              MOVS     r0,#0
000212  9001              STR      r0,[sp,#4]
;;;271              break;
000214  e000              B        |L4.536|
                  |L4.534|
;;;272    
;;;273            /* Parameters are checked with assert_param */
;;;274            default:
;;;275              break;
000216  bf00              NOP      
                  |L4.536|
000218  bf00              NOP                            ;215
;;;276          }
;;;277    
;;;278          /* Check if the current bit belongs to first half or last half of the pin count number
;;;279           in order to address CRH or CRL register*/
;;;280          configregister = (iocurrent < GPIO_PIN_8) ? &GPIOx->CRL     : &GPIOx->CRH;
00021a  2eff              CMP      r6,#0xff
00021c  d801              BHI      |L4.546|
00021e  4628              MOV      r0,r5
000220  e000              B        |L4.548|
                  |L4.546|
000222  1d28              ADDS     r0,r5,#4
                  |L4.548|
000224  4682              MOV      r10,r0
;;;281          registeroffset = (iocurrent < GPIO_PIN_8) ? (position << 2u) : ((position - 8u) << 2u);
000226  2eff              CMP      r6,#0xff
000228  d801              BHI      |L4.558|
00022a  00b8              LSLS     r0,r7,#2
00022c  e002              B        |L4.564|
                  |L4.558|
00022e  f1a70008          SUB      r0,r7,#8
000232  0080              LSLS     r0,r0,#2
                  |L4.564|
000234  4683              MOV      r11,r0
;;;282    
;;;283          /* Apply the new configuration of the pin to the register */
;;;284          MODIFY_REG((*configregister), ((GPIO_CRL_MODE0 | GPIO_CRL_CNF0) << registeroffset), (config << registeroffset));
000236  f8da0000          LDR      r0,[r10,#0]
00023a  210f              MOVS     r1,#0xf
00023c  fa01f10b          LSL      r1,r1,r11
000240  4388              BICS     r0,r0,r1
000242  9901              LDR      r1,[sp,#4]
000244  fa01f10b          LSL      r1,r1,r11
000248  4308              ORRS     r0,r0,r1
00024a  f8ca0000          STR      r0,[r10,#0]
;;;285    
;;;286          /*--------------------- EXTI Mode Configuration ------------------------*/
;;;287          /* Configure the External Interrupt or event for the current IO */
;;;288          if ((GPIO_Init->Mode & EXTI_MODE) == EXTI_MODE)
00024e  6860              LDR      r0,[r4,#4]
000250  f0005080          AND      r0,r0,#0x10000000
000254  f1b05f80          CMP      r0,#0x10000000
000258  d17e              BNE      |L4.856|
;;;289          {
;;;290            /* Enable AFIO Clock */
;;;291            __HAL_RCC_AFIO_CLK_ENABLE();
00025a  bf00              NOP      
00025c  4861              LDR      r0,|L4.996|
00025e  6980              LDR      r0,[r0,#0x18]
000260  f0400001          ORR      r0,r0,#1
000264  495f              LDR      r1,|L4.996|
000266  6188              STR      r0,[r1,#0x18]
000268  4608              MOV      r0,r1
00026a  6980              LDR      r0,[r0,#0x18]
00026c  f0000001          AND      r0,r0,#1
000270  9000              STR      r0,[sp,#0]
000272  bf00              NOP      
000274  bf00              NOP      
;;;292            temp = AFIO->EXTICR[position >> 2u];
000276  ea4f30b1          ROR      r0,r1,#14
00027a  08b9              LSRS     r1,r7,#2
00027c  f8509021          LDR      r9,[r0,r1,LSL #2]
;;;293            CLEAR_BIT(temp, (0x0Fu) << (4u * (position & 0x03u)));
000280  07b8              LSLS     r0,r7,#30
000282  0f01              LSRS     r1,r0,#28
000284  200f              MOVS     r0,#0xf
000286  4088              LSLS     r0,r0,r1
000288  ea290900          BIC      r9,r9,r0
;;;294            SET_BIT(temp, (GPIO_GET_INDEX(GPIOx)) << (4u * (position & 0x03u)));
00028c  483b              LDR      r0,|L4.892|
00028e  4285              CMP      r5,r0
000290  d101              BNE      |L4.662|
000292  2000              MOVS     r0,#0
000294  e00f              B        |L4.694|
                  |L4.662|
000296  483a              LDR      r0,|L4.896|
000298  4285              CMP      r5,r0
00029a  d101              BNE      |L4.672|
00029c  2001              MOVS     r0,#1
00029e  e00a              B        |L4.694|
                  |L4.672|
0002a0  4838              LDR      r0,|L4.900|
0002a2  4285              CMP      r5,r0
0002a4  d101              BNE      |L4.682|
0002a6  2002              MOVS     r0,#2
0002a8  e005              B        |L4.694|
                  |L4.682|
0002aa  4837              LDR      r0,|L4.904|
0002ac  4285              CMP      r5,r0
0002ae  d101              BNE      |L4.692|
0002b0  2003              MOVS     r0,#3
0002b2  e000              B        |L4.694|
                  |L4.692|
0002b4  2004              MOVS     r0,#4
                  |L4.694|
0002b6  07b9              LSLS     r1,r7,#30
0002b8  0f09              LSRS     r1,r1,#28
0002ba  4088              LSLS     r0,r0,r1
0002bc  ea400909          ORR      r9,r0,r9
;;;295            AFIO->EXTICR[position >> 2u] = temp;
0002c0  4849              LDR      r0,|L4.1000|
0002c2  08b9              LSRS     r1,r7,#2
0002c4  f8409021          STR      r9,[r0,r1,LSL #2]
;;;296    
;;;297    
;;;298            /* Configure the interrupt mask */
;;;299            if ((GPIO_Init->Mode & GPIO_MODE_IT) == GPIO_MODE_IT)
0002c8  6860              LDR      r0,[r4,#4]
0002ca  f4003080          AND      r0,r0,#0x10000
0002ce  f5b03f80          CMP      r0,#0x10000
0002d2  d105              BNE      |L4.736|
;;;300            {
;;;301              SET_BIT(EXTI->IMR, iocurrent);
0002d4  4845              LDR      r0,|L4.1004|
0002d6  6800              LDR      r0,[r0,#0]
0002d8  4330              ORRS     r0,r0,r6
0002da  4944              LDR      r1,|L4.1004|
0002dc  6008              STR      r0,[r1,#0]
0002de  e004              B        |L4.746|
                  |L4.736|
;;;302            }
;;;303            else
;;;304            {
;;;305              CLEAR_BIT(EXTI->IMR, iocurrent);
0002e0  4842              LDR      r0,|L4.1004|
0002e2  6800              LDR      r0,[r0,#0]
0002e4  43b0              BICS     r0,r0,r6
0002e6  4941              LDR      r1,|L4.1004|
0002e8  6008              STR      r0,[r1,#0]
                  |L4.746|
;;;306            }
;;;307    
;;;308            /* Configure the event mask */
;;;309            if ((GPIO_Init->Mode & GPIO_MODE_EVT) == GPIO_MODE_EVT)
0002ea  6860              LDR      r0,[r4,#4]
0002ec  f4003000          AND      r0,r0,#0x20000
0002f0  f5b03f00          CMP      r0,#0x20000
0002f4  d107              BNE      |L4.774|
;;;310            {
;;;311              SET_BIT(EXTI->EMR, iocurrent);
0002f6  483d              LDR      r0,|L4.1004|
0002f8  1d00              ADDS     r0,r0,#4
0002fa  6800              LDR      r0,[r0,#0]
0002fc  4330              ORRS     r0,r0,r6
0002fe  493b              LDR      r1,|L4.1004|
000300  1d09              ADDS     r1,r1,#4
000302  6008              STR      r0,[r1,#0]
000304  e006              B        |L4.788|
                  |L4.774|
;;;312            }
;;;313            else
;;;314            {
;;;315              CLEAR_BIT(EXTI->EMR, iocurrent);
000306  4839              LDR      r0,|L4.1004|
000308  1d00              ADDS     r0,r0,#4
00030a  6800              LDR      r0,[r0,#0]
00030c  43b0              BICS     r0,r0,r6
00030e  4937              LDR      r1,|L4.1004|
000310  1d09              ADDS     r1,r1,#4
000312  6008              STR      r0,[r1,#0]
                  |L4.788|
;;;316            }
;;;317    
;;;318            /* Enable or disable the rising trigger */
;;;319            if ((GPIO_Init->Mode & RISING_EDGE) == RISING_EDGE)
000314  6860              LDR      r0,[r4,#4]
000316  f4001080          AND      r0,r0,#0x100000
00031a  f5b01f80          CMP      r0,#0x100000
00031e  d107              BNE      |L4.816|
;;;320            {
;;;321              SET_BIT(EXTI->RTSR, iocurrent);
000320  4832              LDR      r0,|L4.1004|
000322  3008              ADDS     r0,r0,#8
000324  6800              LDR      r0,[r0,#0]
000326  4330              ORRS     r0,r0,r6
000328  4930              LDR      r1,|L4.1004|
00032a  3108              ADDS     r1,r1,#8
00032c  6008              STR      r0,[r1,#0]
00032e  e006              B        |L4.830|
                  |L4.816|
;;;322            }
;;;323            else
;;;324            {
;;;325              CLEAR_BIT(EXTI->RTSR, iocurrent);
000330  482e              LDR      r0,|L4.1004|
000332  3008              ADDS     r0,r0,#8
000334  6800              LDR      r0,[r0,#0]
000336  43b0              BICS     r0,r0,r6
000338  492c              LDR      r1,|L4.1004|
00033a  3108              ADDS     r1,r1,#8
00033c  6008              STR      r0,[r1,#0]
                  |L4.830|
;;;326            }
;;;327    
;;;328            /* Enable or disable the falling trigger */
;;;329            if ((GPIO_Init->Mode & FALLING_EDGE) == FALLING_EDGE)
00033e  6860              LDR      r0,[r4,#4]
000340  f4001000          AND      r0,r0,#0x200000
000344  f5b01f00          CMP      r0,#0x200000
000348  d109              BNE      |L4.862|
;;;330            {
;;;331              SET_BIT(EXTI->FTSR, iocurrent);
00034a  4828              LDR      r0,|L4.1004|
00034c  300c              ADDS     r0,r0,#0xc
00034e  6800              LDR      r0,[r0,#0]
000350  4330              ORRS     r0,r0,r6
000352  4926              LDR      r1,|L4.1004|
000354  310c              ADDS     r1,r1,#0xc
000356  e000              B        |L4.858|
                  |L4.856|
000358  e008              B        |L4.876|
                  |L4.858|
00035a  6008              STR      r0,[r1,#0]
00035c  e006              B        |L4.876|
                  |L4.862|
;;;332            }
;;;333            else
;;;334            {
;;;335              CLEAR_BIT(EXTI->FTSR, iocurrent);
00035e  4823              LDR      r0,|L4.1004|
000360  300c              ADDS     r0,r0,#0xc
000362  6800              LDR      r0,[r0,#0]
000364  43b0              BICS     r0,r0,r6
000366  4921              LDR      r1,|L4.1004|
000368  310c              ADDS     r1,r1,#0xc
00036a  6008              STR      r0,[r1,#0]
                  |L4.876|
;;;336            }
;;;337          }
;;;338        }
;;;339    
;;;340    	position++;
00036c  1c7f              ADDS     r7,r7,#1
                  |L4.878|
00036e  6820              LDR      r0,[r4,#0]            ;194
000370  40f8              LSRS     r0,r0,r7              ;194
000372  2800              CMP      r0,#0                 ;194
000374  f47fae9a          BNE      |L4.172|
;;;341      }
;;;342    }
000378  e8bd9ffc          POP      {r2-r12,pc}
;;;343    
                          ENDP

                  |L4.892|
                          DCD      0x40010800
                  |L4.896|
                          DCD      0x40010c00
                  |L4.900|
                          DCD      0x40011000
                  |L4.904|
                          DCD      0x40011400
                  |L4.908|
                          DCD      0x40011800
                  |L4.912|
000390  2e2e2f44          DCB      "../Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_gpio."
000394  72697665
000398  72732f53
00039c  544d3332
0003a0  46317878
0003a4  5f48414c
0003a8  5f447269
0003ac  7665722f
0003b0  5372632f
0003b4  73746d33
0003b8  32663178
0003bc  785f6861
0003c0  6c5f6770
0003c4  696f2e  
0003c7  6300              DCB      "c",0
0003c9  00                DCB      0
0003ca  00                DCB      0
0003cb  00                DCB      0
                  |L4.972|
                          DCD      0x10110000
                  |L4.976|
                          DCD      0x10210000
                  |L4.980|
                          DCD      0x10310000
                  |L4.984|
                          DCD      0x10120000
                  |L4.988|
                          DCD      0x10220000
                  |L4.992|
                          DCD      0x10320000
                  |L4.996|
                          DCD      0x40021000
                  |L4.1000|
                          DCD      0x40010008
                  |L4.1004|
                          DCD      0x40010400

                          AREA ||i.HAL_GPIO_LockPin||, CODE, READONLY, ALIGN=2

                  HAL_GPIO_LockPin PROC
;;;510    */
;;;511    HAL_StatusTypeDef HAL_GPIO_LockPin(GPIO_TypeDef *GPIOx, uint16_t GPIO_Pin)
000000  b538              PUSH     {r3-r5,lr}
;;;512    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;513      __IO uint32_t tmp = GPIO_LCKR_LCKK;
000006  f44f3080          MOV      r0,#0x10000
00000a  9000              STR      r0,[sp,#0]
;;;514    
;;;515      /* Check the parameters */
;;;516      assert_param(IS_GPIO_LOCK_INSTANCE(GPIOx));
00000c  4818              LDR      r0,|L5.112|
00000e  4284              CMP      r4,r0
000010  d00b              BEQ      |L5.42|
000012  4818              LDR      r0,|L5.116|
000014  4284              CMP      r4,r0
000016  d008              BEQ      |L5.42|
000018  4817              LDR      r0,|L5.120|
00001a  4284              CMP      r4,r0
00001c  d005              BEQ      |L5.42|
00001e  4817              LDR      r0,|L5.124|
000020  4284              CMP      r4,r0
000022  d002              BEQ      |L5.42|
000024  4816              LDR      r0,|L5.128|
000026  4284              CMP      r4,r0
000028  d100              BNE      |L5.44|
                  |L5.42|
00002a  e004              B        |L5.54|
                  |L5.44|
00002c  f44f7101          MOV      r1,#0x204
000030  a014              ADR      r0,|L5.132|
000032  f7fffffe          BL       assert_failed
                  |L5.54|
;;;517      assert_param(IS_GPIO_PIN(GPIO_Pin));
000036  b2a8              UXTH     r0,r5
000038  b118              CBZ      r0,|L5.66|
00003a  0c28              LSRS     r0,r5,#16
00003c  0400              LSLS     r0,r0,#16
00003e  b900              CBNZ     r0,|L5.66|
000040  e004              B        |L5.76|
                  |L5.66|
000042  f2402105          MOV      r1,#0x205
000046  a00f              ADR      r0,|L5.132|
000048  f7fffffe          BL       assert_failed
                  |L5.76|
;;;518    
;;;519      /* Apply lock key write sequence */
;;;520      SET_BIT(tmp, GPIO_Pin);
00004c  9800              LDR      r0,[sp,#0]
00004e  4328              ORRS     r0,r0,r5
000050  9000              STR      r0,[sp,#0]
;;;521      /* Set LCKx bit(s): LCKK='1' + LCK[15-0] */
;;;522      GPIOx->LCKR = tmp;
000052  9800              LDR      r0,[sp,#0]
000054  61a0              STR      r0,[r4,#0x18]
;;;523      /* Reset LCKx bit(s): LCKK='0' + LCK[15-0] */
;;;524      GPIOx->LCKR = GPIO_Pin;
000056  61a5              STR      r5,[r4,#0x18]
;;;525      /* Set LCKx bit(s): LCKK='1' + LCK[15-0] */
;;;526      GPIOx->LCKR = tmp;
000058  9800              LDR      r0,[sp,#0]
00005a  61a0              STR      r0,[r4,#0x18]
;;;527      /* Read LCKK register. This read is mandatory to complete key lock sequence */
;;;528      tmp = GPIOx->LCKR;
00005c  69a0              LDR      r0,[r4,#0x18]
00005e  9000              STR      r0,[sp,#0]
;;;529    
;;;530      /* read again in order to confirm lock is active */
;;;531      if ((uint32_t)(GPIOx->LCKR & GPIO_LCKR_LCKK))
000060  69a0              LDR      r0,[r4,#0x18]
000062  f4003080          AND      r0,r0,#0x10000
000066  b108              CBZ      r0,|L5.108|
;;;532      {
;;;533        return HAL_OK;
000068  2000              MOVS     r0,#0
                  |L5.106|
;;;534      }
;;;535      else
;;;536      {
;;;537        return HAL_ERROR;
;;;538      }
;;;539    }
00006a  bd38              POP      {r3-r5,pc}
                  |L5.108|
00006c  2001              MOVS     r0,#1                 ;537
00006e  e7fc              B        |L5.106|
;;;540    
                          ENDP

                  |L5.112|
                          DCD      0x40010800
                  |L5.116|
                          DCD      0x40010c00
                  |L5.120|
                          DCD      0x40011000
                  |L5.124|
                          DCD      0x40011400
                  |L5.128|
                          DCD      0x40011800
                  |L5.132|
000084  2e2e2f44          DCB      "../Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_gpio."
000088  72697665
00008c  72732f53
000090  544d3332
000094  46317878
000098  5f48414c
00009c  5f447269
0000a0  7665722f
0000a4  5372632f
0000a8  73746d33
0000ac  32663178
0000b0  785f6861
0000b4  6c5f6770
0000b8  696f2e  
0000bb  6300              DCB      "c",0
0000bd  00                DCB      0
0000be  00                DCB      0
0000bf  00                DCB      0

                          AREA ||i.HAL_GPIO_ReadPin||, CODE, READONLY, ALIGN=2

                  HAL_GPIO_ReadPin PROC
;;;430      */
;;;431    GPIO_PinState HAL_GPIO_ReadPin(GPIO_TypeDef *GPIOx, uint16_t GPIO_Pin)
000000  b570              PUSH     {r4-r6,lr}
;;;432    {
000002  4606              MOV      r6,r0
000004  460c              MOV      r4,r1
;;;433      GPIO_PinState bitstatus;
;;;434    
;;;435      /* Check the parameters */
;;;436      assert_param(IS_GPIO_PIN(GPIO_Pin));
000006  b2a0              UXTH     r0,r4
000008  b118              CBZ      r0,|L6.18|
00000a  0c20              LSRS     r0,r4,#16
00000c  0400              LSLS     r0,r0,#16
00000e  b900              CBNZ     r0,|L6.18|
000010  e004              B        |L6.28|
                  |L6.18|
000012  f44f71da          MOV      r1,#0x1b4
000016  a005              ADR      r0,|L6.44|
000018  f7fffffe          BL       assert_failed
                  |L6.28|
;;;437    
;;;438      if ((GPIOx->IDR & GPIO_Pin) != (uint32_t)GPIO_PIN_RESET)
00001c  68b0              LDR      r0,[r6,#8]
00001e  4020              ANDS     r0,r0,r4
000020  b108              CBZ      r0,|L6.38|
;;;439      {
;;;440        bitstatus = GPIO_PIN_SET;
000022  2501              MOVS     r5,#1
000024  e000              B        |L6.40|
                  |L6.38|
;;;441      }
;;;442      else
;;;443      {
;;;444        bitstatus = GPIO_PIN_RESET;
000026  2500              MOVS     r5,#0
                  |L6.40|
;;;445      }
;;;446      return bitstatus;
000028  4628              MOV      r0,r5
;;;447    }
00002a  bd70              POP      {r4-r6,pc}
;;;448    
                          ENDP

                  |L6.44|
00002c  2e2e2f44          DCB      "../Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_gpio."
000030  72697665
000034  72732f53
000038  544d3332
00003c  46317878
000040  5f48414c
000044  5f447269
000048  7665722f
00004c  5372632f
000050  73746d33
000054  32663178
000058  785f6861
00005c  6c5f6770
000060  696f2e  
000063  6300              DCB      "c",0
000065  00                DCB      0
000066  00                DCB      0
000067  00                DCB      0

                          AREA ||i.HAL_GPIO_TogglePin||, CODE, READONLY, ALIGN=2

                  HAL_GPIO_TogglePin PROC
;;;486      */
;;;487    void HAL_GPIO_TogglePin(GPIO_TypeDef *GPIOx, uint16_t GPIO_Pin)
000000  b570              PUSH     {r4-r6,lr}
;;;488    {
000002  4605              MOV      r5,r0
000004  460c              MOV      r4,r1
;;;489      uint32_t odr;
;;;490    
;;;491      /* Check the parameters */
;;;492      assert_param(IS_GPIO_PIN(GPIO_Pin));
000006  b2a0              UXTH     r0,r4
000008  b118              CBZ      r0,|L7.18|
00000a  0c20              LSRS     r0,r4,#16
00000c  0400              LSLS     r0,r0,#16
00000e  b900              CBNZ     r0,|L7.18|
000010  e004              B        |L7.28|
                  |L7.18|
000012  f44f71f6          MOV      r1,#0x1ec
000016  a006              ADR      r0,|L7.48|
000018  f7fffffe          BL       assert_failed
                  |L7.28|
;;;493    
;;;494      /* get current Ouput Data Register value */
;;;495      odr = GPIOx->ODR;
00001c  68ee              LDR      r6,[r5,#0xc]
;;;496    
;;;497      /* Set selected pins that were at low level, and reset ones that were high */
;;;498      GPIOx->BSRR = ((odr & GPIO_Pin) << GPIO_NUMBER) | (~odr & GPIO_Pin);
00001e  ea240006          BIC      r0,r4,r6
000022  ea060104          AND      r1,r6,r4
000026  ea404001          ORR      r0,r0,r1,LSL #16
00002a  6128              STR      r0,[r5,#0x10]
;;;499    }
00002c  bd70              POP      {r4-r6,pc}
;;;500    
                          ENDP

00002e  0000              DCW      0x0000
                  |L7.48|
000030  2e2e2f44          DCB      "../Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_gpio."
000034  72697665
000038  72732f53
00003c  544d3332
000040  46317878
000044  5f48414c
000048  5f447269
00004c  7665722f
000050  5372632f
000054  73746d33
000058  32663178
00005c  785f6861
000060  6c5f6770
000064  696f2e  
000067  6300              DCB      "c",0
000069  00                DCB      0
00006a  00                DCB      0
00006b  00                DCB      0

                          AREA ||i.HAL_GPIO_WritePin||, CODE, READONLY, ALIGN=2

                  HAL_GPIO_WritePin PROC
;;;464      */
;;;465    void HAL_GPIO_WritePin(GPIO_TypeDef *GPIOx, uint16_t GPIO_Pin, GPIO_PinState PinState)
000000  b570              PUSH     {r4-r6,lr}
;;;466    {
000002  4606              MOV      r6,r0
000004  460c              MOV      r4,r1
000006  4615              MOV      r5,r2
;;;467      /* Check the parameters */
;;;468      assert_param(IS_GPIO_PIN(GPIO_Pin));
000008  b2a0              UXTH     r0,r4
00000a  b118              CBZ      r0,|L8.20|
00000c  0c20              LSRS     r0,r4,#16
00000e  0400              LSLS     r0,r0,#16
000010  b900              CBNZ     r0,|L8.20|
000012  e004              B        |L8.30|
                  |L8.20|
000014  f44f71ea          MOV      r1,#0x1d4
000018  a008              ADR      r0,|L8.60|
00001a  f7fffffe          BL       assert_failed
                  |L8.30|
;;;469      assert_param(IS_GPIO_PIN_ACTION(PinState));
00001e  b10d              CBZ      r5,|L8.36|
000020  2d01              CMP      r5,#1
000022  d100              BNE      |L8.38|
                  |L8.36|
000024  e004              B        |L8.48|
                  |L8.38|
000026  f24011d5          MOV      r1,#0x1d5
00002a  a004              ADR      r0,|L8.60|
00002c  f7fffffe          BL       assert_failed
                  |L8.48|
;;;470    
;;;471      if (PinState != GPIO_PIN_RESET)
000030  b10d              CBZ      r5,|L8.54|
;;;472      {
;;;473        GPIOx->BSRR = GPIO_Pin;
000032  6134              STR      r4,[r6,#0x10]
000034  e001              B        |L8.58|
                  |L8.54|
;;;474      }
;;;475      else
;;;476      {
;;;477        GPIOx->BSRR = (uint32_t)GPIO_Pin << 16u;
000036  0420              LSLS     r0,r4,#16
000038  6130              STR      r0,[r6,#0x10]
                  |L8.58|
;;;478      }
;;;479    }
00003a  bd70              POP      {r4-r6,pc}
;;;480    
                          ENDP

                  |L8.60|
00003c  2e2e2f44          DCB      "../Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_gpio."
000040  72697665
000044  72732f53
000048  544d3332
00004c  46317878
000050  5f48414c
000054  5f447269
000058  7665722f
00005c  5372632f
000060  73746d33
000064  32663178
000068  785f6861
00006c  6c5f6770
000070  696f2e  
000073  6300              DCB      "c",0
000075  00                DCB      0
000076  00                DCB      0
000077  00                DCB      0

;*** Start embedded assembler ***

#line 1 "../Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_gpio.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___20_stm32f1xx_hal_gpio_c_ea787061____REV16|
#line 463 "../Drivers/CMSIS/Include/cmsis_armcc.h"
|__asm___20_stm32f1xx_hal_gpio_c_ea787061____REV16| PROC
#line 464

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___20_stm32f1xx_hal_gpio_c_ea787061____REVSH|
#line 478
|__asm___20_stm32f1xx_hal_gpio_c_ea787061____REVSH| PROC
#line 479

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___20_stm32f1xx_hal_gpio_c_ea787061____RRX|
#line 665
|__asm___20_stm32f1xx_hal_gpio_c_ea787061____RRX| PROC
#line 666

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
